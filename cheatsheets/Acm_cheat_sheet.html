<html class="translated-ltr"><head><meta charset="utf-8"><title>ACM-ICPC Cheat Sheet.md</title><style>@charset "UTF-8";@import 'https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.css';code{color:#c7254e;background-color:#f9f2f4;border-radius:4px}code,kbd{padding:2px 4px}kbd{color:#fff;background-color:#333;border-radius:3px;box-shadow:inset 0 -1px 0 rgba(0,0,0,.25)}kbd kbd{padding:0;font-size:100%;box-shadow:none}pre{display:block;margin:0 0 10px;word-break:break-all;word-wrap:break-word;color:#333;background-color:#f5f5f5;border:1px solid #ccc;border-radius:4px}pre code{padding:0;font-size:inherit;color:inherit;white-space:pre-wrap;background-color:transparent;border-radius:0}.pre-scrollable{max-height:340px;overflow-y:scroll}table{background-color:transparent}th{text-align:left}.table{width:100%;max-width:100%;margin-bottom:20px}.table>thead>tr>th{padding:8px;line-height:1.4285714;border-top:1px solid #ddd}.table>thead>tr>td,.table>tbody>tr>th,.table>tbody>tr>td,.table>tfoot>tr>th,.table>tfoot>tr>td{padding:8px;line-height:1.4285714;vertical-align:top;border-top:1px solid #ddd}.table>thead>tr>th{vertical-align:bottom;border-bottom:2px solid #ddd}.table>caption+thead>tr:first-child>th,.table>caption+thead>tr:first-child>td,.table>colgroup+thead>tr:first-child>th,.table>colgroup+thead>tr:first-child>td,.table>thead:first-child>tr:first-child>th,.table>thead:first-child>tr:first-child>td{border-top:0}.table>tbody+tbody{border-top:2px solid #ddd}.table .table{background-color:#fff}.table-condensed>thead>tr>th,.table-condensed>thead>tr>td,.table-condensed>tbody>tr>th,.table-condensed>tbody>tr>td,.table-condensed>tfoot>tr>th,.table-condensed>tfoot>tr>td{padding:5px}.table-bordered,.table-bordered>thead>tr>th,.table-bordered>thead>tr>td,.table-bordered>tbody>tr>th,.table-bordered>tbody>tr>td,.table-bordered>tfoot>tr>th,.table-bordered>tfoot>tr>td{border:1px solid #ddd}.table-bordered>thead>tr>th,.table-bordered>thead>tr>td{border-bottom-width:2px}.table-striped>tbody>tr:nth-child(odd)>td,.table-striped>tbody>tr:nth-child(odd)>th{background-color:#f9f9f9}.table-hover>tbody>tr:hover>td,.table-hover>tbody>tr:hover>th{background-color:#f5f5f5}table col[class*="col-"]{position:static;float:none;display:table-column}table td[class*="col-"],table th[class*="col-"]{position:static;float:none;display:table-cell}.table>thead>tr>td.active,.table>thead>tr>th.active,.table>thead>tr.active>td,.table>thead>tr.active>th,.table>tbody>tr>td.active,.table>tbody>tr>th.active,.table>tbody>tr.active>td,.table>tbody>tr.active>th,.table>tfoot>tr>td.active,.table>tfoot>tr>th.active,.table>tfoot>tr.active>td,.table>tfoot>tr.active>th{background-color:#f5f5f5}.table-hover>tbody>tr>td.active:hover,.table-hover>tbody>tr>th.active:hover,.table-hover>tbody>tr.active:hover>td,.table-hover>tbody>tr:hover>.active,.table-hover>tbody>tr.active:hover>th{background-color:#e8e8e8}.table>thead>tr>td.success,.table>thead>tr>th.success,.table>thead>tr.success>td,.table>thead>tr.success>th,.table>tbody>tr>td.success,.table>tbody>tr>th.success,.table>tbody>tr.success>td,.table>tbody>tr.success>th,.table>tfoot>tr>td.success,.table>tfoot>tr>th.success,.table>tfoot>tr.success>td,.table>tfoot>tr.success>th{background-color:#dff0d8}.table-hover>tbody>tr>td.success:hover,.table-hover>tbody>tr>th.success:hover,.table-hover>tbody>tr.success:hover>td,.table-hover>tbody>tr:hover>.success,.table-hover>tbody>tr.success:hover>th{background-color:#d0e9c6}.table>thead>tr>td.info,.table>thead>tr>th.info,.table>thead>tr.info>td,.table>thead>tr.info>th,.table>tbody>tr>td.info,.table>tbody>tr>th.info,.table>tbody>tr.info>td,.table>tbody>tr.info>th,.table>tfoot>tr>td.info,.table>tfoot>tr>th.info,.table>tfoot>tr.info>td,.table>tfoot>tr.info>th{background-color:#d9edf7}.table-hover>tbody>tr>td.info:hover,.table-hover>tbody>tr>th.info:hover,.table-hover>tbody>tr.info:hover>td,.table-hover>tbody>tr:hover>.info,.table-hover>tbody>tr.info:hover>th{background-color:#c4e3f3}.table>thead>tr>td.warning,.table>thead>tr>th.warning,.table>thead>tr.warning>td,.table>thead>tr.warning>th,.table>tbody>tr>td.warning,.table>tbody>tr>th.warning,.table>tbody>tr.warning>td,.table>tbody>tr.warning>th,.table>tfoot>tr>td.warning,.table>tfoot>tr>th.warning,.table>tfoot>tr.warning>td,.table>tfoot>tr.warning>th{background-color:#fcf8e3}.table-hover>tbody>tr>td.warning:hover,.table-hover>tbody>tr>th.warning:hover,.table-hover>tbody>tr.warning:hover>td,.table-hover>tbody>tr:hover>.warning,.table-hover>tbody>tr.warning:hover>th{background-color:#faf2cc}.table>thead>tr>td.danger,.table>thead>tr>th.danger,.table>thead>tr.danger>td,.table>thead>tr.danger>th,.table>tbody>tr>td.danger,.table>tbody>tr>th.danger,.table>tbody>tr.danger>td,.table>tbody>tr.danger>th,.table>tfoot>tr>td.danger,.table>tfoot>tr>th.danger,.table>tfoot>tr.danger>td,.table>tfoot>tr.danger>th{background-color:#f2dede}.table-hover>tbody>tr>td.danger:hover,.table-hover>tbody>tr>th.danger:hover,.table-hover>tbody>tr.danger:hover>td,.table-hover>tbody>tr:hover>.danger,.table-hover>tbody>tr.danger:hover>th{background-color:#ebcccc}fieldset{border:0;min-width:0}legend{display:block;width:100%;margin-bottom:20px;font-size:21px;line-height:inherit;color:#333;border-bottom:1px solid #e5e5e5}label{display:inline-block;max-width:100%;margin-bottom:5px;font-weight:700}input[type="radio"],input[type="checkbox"]{margin:4px 0 0;margin-top:1px \9;line-height:normal}input[type="file"]{display:block}input[type="range"]{display:block;width:100%}select[multiple],select[size]{height:auto}input[type="file"]:focus,input[type="radio"]:focus,input[type="checkbox"]:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}output{padding-top:7px}output,.form-control{display:block;font-size:14px;line-height:1.4285714;color:#555}.form-control{width:100%;height:34px;padding:6px 12px;background-color:#fff;background-image:none;border:1px solid #ccc;border-radius:4px;box-shadow:inset 0 1px 1px rgba(0,0,0,.075);transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s}.form-control:focus{border-color:#66afe9;outline:0;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6)}.form-control::-moz-placeholder{color:#777;opacity:1}.form-control:-ms-input-placeholder{color:#777}.form-control::-webkit-input-placeholder{color:#777}.form-control[disabled],.form-control[readonly],fieldset[disabled] .form-control{cursor:not-allowed;background-color:#eee;opacity:1}textarea.form-control{height:auto}input[type="date"],input[type="time"],input[type="datetime-local"],input[type="month"]{line-height:34px;line-height:1.4285714 \0}input[type="date"].input-sm,.form-horizontal .form-group-sm input.form-control[type="date"],.input-group-sm>input.form-control[type="date"],.input-group-sm>input.input-group-addon[type="date"],.input-group-sm>.input-group-btn>input.btn[type="date"],input[type="time"].input-sm,.form-horizontal .form-group-sm input.form-control[type="time"],.input-group-sm>input.form-control[type="time"],.input-group-sm>input.input-group-addon[type="time"],.input-group-sm>.input-group-btn>input.btn[type="time"],input[type="datetime-local"].input-sm,.form-horizontal .form-group-sm input.form-control[type="datetime-local"],.input-group-sm>input.form-control[type="datetime-local"],.input-group-sm>input.input-group-addon[type="datetime-local"],.input-group-sm>.input-group-btn>input.btn[type="datetime-local"],input[type="month"].input-sm,.form-horizontal .form-group-sm input.form-control[type="month"],.input-group-sm>input.form-control[type="month"],.input-group-sm>input.input-group-addon[type="month"],.input-group-sm>.input-group-btn>input.btn[type="month"]{line-height:30px}input[type="date"].input-lg,.form-horizontal .form-group-lg input.form-control[type="date"],.input-group-lg>input.form-control[type="date"],.input-group-lg>input.input-group-addon[type="date"],.input-group-lg>.input-group-btn>input.btn[type="date"],input[type="time"].input-lg,.form-horizontal .form-group-lg input.form-control[type="time"],.input-group-lg>input.form-control[type="time"],.input-group-lg>input.input-group-addon[type="time"],.input-group-lg>.input-group-btn>input.btn[type="time"],input[type="datetime-local"].input-lg,.form-horizontal .form-group-lg input.form-control[type="datetime-local"],.input-group-lg>input.form-control[type="datetime-local"],.input-group-lg>input.input-group-addon[type="datetime-local"],.input-group-lg>.input-group-btn>input.btn[type="datetime-local"],input[type="month"].input-lg,.form-horizontal .form-group-lg input.form-control[type="month"],.input-group-lg>input.form-control[type="month"],.input-group-lg>input.input-group-addon[type="month"],.input-group-lg>.input-group-btn>input.btn[type="month"]{line-height:46px}.form-group{margin-bottom:15px}.radio,.checkbox{position:relative;display:block;min-height:20px;margin-top:10px;margin-bottom:10px}.radio label,.checkbox label{padding-left:20px;margin-bottom:0;font-weight:400;cursor:pointer}.radio input[type="radio"],.radio-inline input[type="radio"],.checkbox input[type="checkbox"],.checkbox-inline input[type="checkbox"]{position:absolute;margin-left:-20px;margin-top:4px \9}.radio+.radio,.checkbox+.checkbox{margin-top:-5px}.radio-inline,.checkbox-inline{display:inline-block;padding-left:20px;margin-bottom:0;vertical-align:middle;font-weight:400;cursor:pointer}.radio-inline+.radio-inline,.checkbox-inline+.checkbox-inline{margin-top:0;margin-left:10px}input[type="radio"][disabled],input[type="radio"].disabled,fieldset[disabled] input[type="radio"],input[type="checkbox"][disabled],input[type="checkbox"].disabled,fieldset[disabled] input[type="checkbox"],.radio-inline.disabled,fieldset[disabled] .radio-inline,.checkbox-inline.disabled,fieldset[disabled] .checkbox-inline,.radio.disabled label,fieldset[disabled] .radio label,.checkbox.disabled label,fieldset[disabled] .checkbox label{cursor:not-allowed}.form-control-static{padding-top:7px;padding-bottom:7px;margin-bottom:0}.form-control-static.input-lg,.form-horizontal .form-group-lg .form-control-static.form-control,.input-group-lg>.form-control-static.form-control,.input-group-lg>.form-control-static.input-group-addon,.input-group-lg>.input-group-btn>.form-control-static.btn,.form-control-static.input-sm,.form-horizontal .form-group-sm .form-control-static.form-control,.input-group-sm>.form-control-static.form-control,.input-group-sm>.form-control-static.input-group-addon,.input-group-sm>.input-group-btn>.form-control-static.btn{padding-left:0;padding-right:0}.input-sm,.form-horizontal .form-group-sm .form-control,.input-group-sm>.form-control{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}.input-group-sm>.input-group-addon{height:30px;line-height:1.5}.input-group-sm>.input-group-btn>.btn{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}select.input-sm,.form-horizontal .form-group-sm select.form-control,.input-group-sm>select.form-control,.input-group-sm>select.input-group-addon,.input-group-sm>.input-group-btn>select.btn{height:30px;line-height:30px}textarea.input-sm,.form-horizontal .form-group-sm textarea.form-control,.input-group-sm>textarea.form-control,.input-group-sm>textarea.input-group-addon,.input-group-sm>.input-group-btn>textarea.btn,select[multiple].input-sm,.form-horizontal .form-group-sm select.form-control[multiple],.input-group-sm>select.form-control[multiple],.input-group-sm>select.input-group-addon[multiple],.input-group-sm>.input-group-btn>select.btn[multiple]{height:auto}.input-lg,.form-horizontal .form-group-lg .form-control,.input-group-lg>.form-control{height:46px;padding:10px 16px;font-size:18px;line-height:1.33;border-radius:6px}.input-group-lg>.input-group-addon{height:46px;line-height:1.33}.input-group-lg>.input-group-btn>.btn{height:46px;padding:10px 16px;font-size:18px;line-height:1.33;border-radius:6px}select.input-lg,.form-horizontal .form-group-lg select.form-control,.input-group-lg>select.form-control,.input-group-lg>select.input-group-addon,.input-group-lg>.input-group-btn>select.btn{height:46px;line-height:46px}textarea.input-lg,.form-horizontal .form-group-lg textarea.form-control,.input-group-lg>textarea.form-control,.input-group-lg>textarea.input-group-addon,.input-group-lg>.input-group-btn>textarea.btn,select[multiple].input-lg,.form-horizontal .form-group-lg select.form-control[multiple],.input-group-lg>select.form-control[multiple],.input-group-lg>select.input-group-addon[multiple],.input-group-lg>.input-group-btn>select.btn[multiple]{height:auto}.has-feedback{position:relative}.has-feedback .form-control{padding-right:42.5px}.form-control-feedback{position:absolute;top:25px;right:0;z-index:2;display:block;width:34px;height:34px;line-height:34px;text-align:center}.input-lg+.form-control-feedback,.form-horizontal .form-group-lg .form-control+.form-control-feedback,.input-group-lg>.form-control+.form-control-feedback,.input-group-lg>.input-group-addon+.form-control-feedback,.input-group-lg>.input-group-btn>.btn+.form-control-feedback{width:46px;height:46px;line-height:46px}.input-sm+.form-control-feedback,.form-horizontal .form-group-sm .form-control+.form-control-feedback,.input-group-sm>.form-control+.form-control-feedback,.input-group-sm>.input-group-addon+.form-control-feedback,.input-group-sm>.input-group-btn>.btn+.form-control-feedback{width:30px;height:30px;line-height:30px}.has-success .help-block,.has-success .control-label,.has-success .radio,.has-success .checkbox,.has-success .radio-inline,.has-success .checkbox-inline{color:#3c763d}.has-success .form-control{border-color:#3c763d;box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-success .form-control:focus{border-color:#2b542c;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #67b168}.has-success .input-group-addon{color:#3c763d;border-color:#3c763d;background-color:#dff0d8}.has-success .form-control-feedback{color:#3c763d}.has-warning .help-block,.has-warning .control-label,.has-warning .radio,.has-warning .checkbox,.has-warning .radio-inline,.has-warning .checkbox-inline{color:#8a6d3b}.has-warning .form-control{border-color:#8a6d3b;box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-warning .form-control:focus{border-color:#66512c;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #c0a16b}.has-warning .input-group-addon{color:#8a6d3b;border-color:#8a6d3b;background-color:#fcf8e3}.has-warning .form-control-feedback{color:#8a6d3b}.has-error .help-block,.has-error .control-label,.has-error .radio,.has-error .checkbox,.has-error .radio-inline,.has-error .checkbox-inline{color:#a94442}.has-error .form-control{border-color:#a94442;box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-error .form-control:focus{border-color:#843534;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #ce8483}.has-error .input-group-addon{color:#a94442;border-color:#a94442;background-color:#f2dede}.has-error .form-control-feedback{color:#a94442}.has-feedback label.sr-only~.form-control-feedback{top:0}.help-block{display:block;margin-top:5px;margin-bottom:10px;color:#737373}.form-horizontal .radio,.form-horizontal .checkbox,.form-horizontal .radio-inline,.form-horizontal .checkbox-inline{margin-top:0;margin-bottom:0;padding-top:7px}.form-horizontal .radio,.form-horizontal .checkbox{min-height:27px}.form-horizontal .form-group{margin-left:-15px;margin-right:-15px}.form-horizontal .form-group:before{content:" ";display:table}.form-horizontal .form-group:after{content:" ";display:table;clear:both}.form-horizontal .has-feedback .form-control-feedback{top:0;right:15px}.btn{display:inline-block;vertical-align:middle;cursor:pointer;background-image:none;border:1px solid transparent;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.btn:focus,.btn:active:focus,.btn.active:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.btn:hover,.btn:focus{color:#333;text-decoration:none}.btn:active,.btn.active{outline:0;background-image:none;box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn.disabled,.btn[disabled],fieldset[disabled] .btn{cursor:not-allowed;pointer-events:none;opacity:.65;filter:alpha(opacity=65);box-shadow:none}.btn-default{color:#333;background-color:#fff;border-color:#ccc}.btn-default:hover,.btn-default:focus,.btn-default:active,.btn-default.active,.open>.btn-default.dropdown-toggle{color:#333;background-color:#e6e6e6;border-color:#adadad}.btn-default:active,.btn-default.active,.open>.btn-default.dropdown-toggle{background-image:none}.btn-default.disabled,.btn-default.disabled:hover,.btn-default.disabled:focus,.btn-default.disabled:active,.btn-default.disabled.active,.btn-default[disabled],.btn-default[disabled]:hover,.btn-default[disabled]:focus,.btn-default[disabled]:active,.btn-default[disabled].active,fieldset[disabled] .btn-default,fieldset[disabled] .btn-default:hover,fieldset[disabled] .btn-default:focus,fieldset[disabled] .btn-default:active,fieldset[disabled] .btn-default.active{background-color:#fff;border-color:#ccc}.btn-default .badge{color:#fff;background-color:#333}.btn-primary{color:#fff;background-color:#428bca;border-color:#357ebd}.btn-primary:hover,.btn-primary:focus,.btn-primary:active,.btn-primary.active,.open>.btn-primary.dropdown-toggle{color:#fff;background-color:#3071a9;border-color:#285e8e}.btn-primary:active,.btn-primary.active,.open>.btn-primary.dropdown-toggle{background-image:none}.btn-primary.disabled,.btn-primary.disabled:hover,.btn-primary.disabled:focus,.btn-primary.disabled:active,.btn-primary.disabled.active,.btn-primary[disabled],.btn-primary[disabled]:hover,.btn-primary[disabled]:focus,.btn-primary[disabled]:active,.btn-primary[disabled].active,fieldset[disabled] .btn-primary,fieldset[disabled] .btn-primary:hover,fieldset[disabled] .btn-primary:focus,fieldset[disabled] .btn-primary:active,fieldset[disabled] .btn-primary.active{background-color:#428bca;border-color:#357ebd}.btn-primary .badge{color:#428bca;background-color:#fff}.btn-success{color:#fff;background-color:#5cb85c;border-color:#4cae4c}.btn-success:hover,.btn-success:focus,.btn-success:active,.btn-success.active,.open>.btn-success.dropdown-toggle{color:#fff;background-color:#449d44;border-color:#398439}.btn-success:active,.btn-success.active,.open>.btn-success.dropdown-toggle{background-image:none}.btn-success.disabled,.btn-success.disabled:hover,.btn-success.disabled:focus,.btn-success.disabled:active,.btn-success.disabled.active,.btn-success[disabled],.btn-success[disabled]:hover,.btn-success[disabled]:focus,.btn-success[disabled]:active,.btn-success[disabled].active,fieldset[disabled] .btn-success,fieldset[disabled] .btn-success:hover,fieldset[disabled] .btn-success:focus,fieldset[disabled] .btn-success:active,fieldset[disabled] .btn-success.active{background-color:#5cb85c;border-color:#4cae4c}.btn-success .badge{color:#5cb85c;background-color:#fff}.btn-info{color:#fff;background-color:#5bc0de;border-color:#46b8da}.btn-info:hover,.btn-info:focus,.btn-info:active,.btn-info.active,.open>.btn-info.dropdown-toggle{color:#fff;background-color:#31b0d5;border-color:#269abc}.btn-info:active,.btn-info.active,.open>.btn-info.dropdown-toggle{background-image:none}.btn-info.disabled,.btn-info.disabled:hover,.btn-info.disabled:focus,.btn-info.disabled:active,.btn-info.disabled.active,.btn-info[disabled],.btn-info[disabled]:hover,.btn-info[disabled]:focus,.btn-info[disabled]:active,.btn-info[disabled].active,fieldset[disabled] .btn-info,fieldset[disabled] .btn-info:hover,fieldset[disabled] .btn-info:focus,fieldset[disabled] .btn-info:active,fieldset[disabled] .btn-info.active{background-color:#5bc0de;border-color:#46b8da}.btn-info .badge{color:#5bc0de;background-color:#fff}.btn-warning{color:#fff;background-color:#f0ad4e;border-color:#eea236}.btn-warning:hover,.btn-warning:focus,.btn-warning:active,.btn-warning.active,.open>.btn-warning.dropdown-toggle{color:#fff;background-color:#ec971f;border-color:#d58512}.btn-warning:active,.btn-warning.active,.open>.btn-warning.dropdown-toggle{background-image:none}.btn-warning.disabled,.btn-warning.disabled:hover,.btn-warning.disabled:focus,.btn-warning.disabled:active,.btn-warning.disabled.active,.btn-warning[disabled],.btn-warning[disabled]:hover,.btn-warning[disabled]:focus,.btn-warning[disabled]:active,.btn-warning[disabled].active,fieldset[disabled] .btn-warning,fieldset[disabled] .btn-warning:hover,fieldset[disabled] .btn-warning:focus,fieldset[disabled] .btn-warning:active,fieldset[disabled] .btn-warning.active{background-color:#f0ad4e;border-color:#eea236}.btn-warning .badge{color:#f0ad4e;background-color:#fff}.btn-danger{color:#fff;background-color:#d9534f;border-color:#d43f3a}.btn-danger:hover,.btn-danger:focus,.btn-danger:active,.btn-danger.active,.open>.btn-danger.dropdown-toggle{color:#fff;background-color:#c9302c;border-color:#ac2925}.btn-danger:active,.btn-danger.active,.open>.btn-danger.dropdown-toggle{background-image:none}.btn-danger.disabled,.btn-danger.disabled:hover,.btn-danger.disabled:focus,.btn-danger.disabled:active,.btn-danger.disabled.active,.btn-danger[disabled],.btn-danger[disabled]:hover,.btn-danger[disabled]:focus,.btn-danger[disabled]:active,.btn-danger[disabled].active,fieldset[disabled] .btn-danger,fieldset[disabled] .btn-danger:hover,fieldset[disabled] .btn-danger:focus,fieldset[disabled] .btn-danger:active,fieldset[disabled] .btn-danger.active{background-color:#d9534f;border-color:#d43f3a}.btn-danger .badge{color:#d9534f;background-color:#fff}.btn-link{color:#428bca;font-weight:400;cursor:pointer;border-radius:0}.btn-link,.btn-link:active,.btn-link[disabled],fieldset[disabled] .btn-link{background-color:transparent;box-shadow:none}.btn-link,.btn-link:hover,.btn-link:focus,.btn-link:active{border-color:transparent}.btn-link:hover,.btn-link:focus{color:#2a6496;text-decoration:underline;background-color:transparent}.btn-link[disabled]:hover,.btn-link[disabled]:focus,fieldset[disabled] .btn-link:hover,fieldset[disabled] .btn-link:focus{color:#777;text-decoration:none}.btn-lg{padding:10px 16px;font-size:18px;line-height:1.33;border-radius:6px}.btn-sm{padding:5px 10px}.btn-sm,.btn-xs{font-size:12px;line-height:1.5;border-radius:3px}.btn-xs{padding:1px 5px}.btn-block{display:block;width:100%}.btn-block+.btn-block{margin-top:5px}input[type="submit"].btn-block,input[type="reset"].btn-block,input[type="button"].btn-block{width:100%}.fade{opacity:0;transition:opacity .15s linear}.fade.in{opacity:1}.collapse{display:none}.collapse.in{display:block}tr.collapse.in{display:table-row}tbody.collapse.in{display:table-row-group}.collapsing{position:relative;height:0;overflow:hidden;transition:height .35s ease}.input-group{position:relative;display:table;border-collapse:separate}.input-group[class*="col-"]{float:none;padding-left:0;padding-right:0}.input-group .form-control{position:relative;z-index:2;float:left;width:100%;margin-bottom:0}.input-group-addon,.input-group-btn,.input-group .form-control{display:table-cell}.input-group-addon:not(:first-child):not(:last-child),.input-group-btn:not(:first-child):not(:last-child),.input-group .form-control:not(:first-child):not(:last-child){border-radius:0}.input-group-addon{white-space:nowrap}.input-group-addon,.input-group-btn{width:1%;vertical-align:middle}.input-group-addon{padding:6px 12px;font-size:14px;font-weight:400;line-height:1;color:#555;text-align:center;background-color:#eee;border:1px solid #ccc;border-radius:4px}.input-group-addon.input-sm,.form-horizontal .form-group-sm .input-group-addon.form-control,.input-group-sm>.input-group-addon,.input-group-sm>.input-group-btn>.input-group-addon.btn{padding:5px 10px;font-size:12px;border-radius:3px}.input-group-addon.input-lg,.form-horizontal .form-group-lg .input-group-addon.form-control,.input-group-lg>.input-group-addon,.input-group-lg>.input-group-btn>.input-group-addon.btn{padding:10px 16px;font-size:18px;border-radius:6px}.input-group-addon input[type="radio"],.input-group-addon input[type="checkbox"]{margin-top:0}.input-group .form-control:first-child,.input-group-addon:first-child,.input-group-btn:first-child>.btn,.input-group-btn:first-child>.btn-group>.btn,.input-group-btn:first-child>.dropdown-toggle,.input-group-btn:last-child>.btn:not(:last-child):not(.dropdown-toggle),.input-group-btn:last-child>.btn-group:not(:last-child)>.btn{border-bottom-right-radius:0;border-top-right-radius:0}.input-group-addon:first-child{border-right:0}.input-group .form-control:last-child,.input-group-addon:last-child,.input-group-btn:last-child>.btn,.input-group-btn:last-child>.btn-group>.btn,.input-group-btn:last-child>.dropdown-toggle,.input-group-btn:first-child>.btn:not(:first-child),.input-group-btn:first-child>.btn-group:not(:first-child)>.btn{border-bottom-left-radius:0;border-top-left-radius:0}.input-group-addon:last-child{border-left:0}.input-group-btn{font-size:0;white-space:nowrap}.input-group-btn,.input-group-btn>.btn{position:relative}.input-group-btn>.btn+.btn{margin-left:-1px}.input-group-btn>.btn:hover,.input-group-btn>.btn:focus,.input-group-btn>.btn:active{z-index:2}.input-group-btn:first-child>.btn,.input-group-btn:first-child>.btn-group{margin-right:-1px}.input-group-btn:last-child>.btn,.input-group-btn:last-child>.btn-group{margin-left:-1px}.pagination{display:inline-block;padding-left:0;margin:20px 0;border-radius:4px}.pagination>li{display:inline}.pagination>li>a,.pagination>li>span{position:relative;float:left;padding:6px 12px;line-height:1.4285714;text-decoration:none;color:#428bca;background-color:#fff;border:1px solid #ddd;margin-left:-1px}.pagination>li:first-child>a,.pagination>li:first-child>span{margin-left:0;border-bottom-left-radius:4px;border-top-left-radius:4px}.pagination>li:last-child>a,.pagination>li:last-child>span{border-bottom-right-radius:4px;border-top-right-radius:4px}.pagination>li>a:hover,.pagination>li>a:focus,.pagination>li>span:hover,.pagination>li>span:focus{color:#2a6496;background-color:#eee;border-color:#ddd}.pagination>.active>a,.pagination>.active>a:hover,.pagination>.active>a:focus,.pagination>.active>span,.pagination>.active>span:hover,.pagination>.active>span:focus{z-index:2;color:#fff;background-color:#428bca;border-color:#428bca;cursor:default}.pagination>.disabled>span,.pagination>.disabled>span:hover,.pagination>.disabled>span:focus,.pagination>.disabled>a,.pagination>.disabled>a:hover,.pagination>.disabled>a:focus{color:#777;background-color:#fff;border-color:#ddd;cursor:not-allowed}.pagination-lg>li>a,.pagination-lg>li>span{padding:10px 16px;font-size:18px}.pagination-lg>li:first-child>a,.pagination-lg>li:first-child>span{border-bottom-left-radius:6px;border-top-left-radius:6px}.pagination-lg>li:last-child>a,.pagination-lg>li:last-child>span{border-bottom-right-radius:6px;border-top-right-radius:6px}.pagination-sm>li>a,.pagination-sm>li>span{padding:5px 10px;font-size:12px}.pagination-sm>li:first-child>a,.pagination-sm>li:first-child>span{border-bottom-left-radius:3px;border-top-left-radius:3px}.pagination-sm>li:last-child>a,.pagination-sm>li:last-child>span{border-bottom-right-radius:3px;border-top-right-radius:3px}.close{float:right;font-size:21px;font-weight:700;line-height:1;color:#000;text-shadow:0 1px 0 #fff;opacity:.2;filter:alpha(opacity=20)}.close:hover,.close:focus{color:#000;text-decoration:none;cursor:pointer;opacity:.5;filter:alpha(opacity=50)}button.close{padding:0;cursor:pointer;background:0 0;border:0;-webkit-appearance:none}.modal-open,.modal{overflow:hidden}.modal{display:none;position:fixed;top:0;right:0;bottom:0;left:0;z-index:1050;-webkit-overflow-scrolling:touch;outline:0}.modal.fade .modal-dialog{transform:translate3d(0,-25%,0);transition:transform .3s ease-out}.modal.in .modal-dialog{transform:translate3d(0,0,0)}.modal-open .modal{overflow-x:hidden;overflow-y:auto}.modal-dialog{position:relative;width:auto;margin:10px}.modal-content{position:relative;background-color:#fff;border:1px solid #999;border:1px solid rgba(0,0,0,.2);border-radius:6px;box-shadow:0 3px 9px rgba(0,0,0,.5);background-clip:padding-box;outline:0}.modal-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1040;background-color:#000}.modal-backdrop.fade{opacity:0;filter:alpha(opacity=0)}.modal-backdrop.in{opacity:.5;filter:alpha(opacity=50)}.modal-header{padding:15px;border-bottom:1px solid #e5e5e5;min-height:16.4285714px}.modal-header .close{margin-top:-2px}.modal-title{margin:0;line-height:1.4285714}.modal-body{position:relative;padding:15px}.modal-footer{padding:15px;text-align:right;border-top:1px solid #e5e5e5}.modal-footer:before,.modal-footer:after{content:" ";display:table}.modal-footer:after{clear:both}.modal-footer .btn+.btn{margin-left:5px;margin-bottom:0}.modal-footer .btn-group .btn+.btn{margin-left:-1px}.modal-footer .btn-block+.btn-block{margin-left:0}.modal-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.clearfix:before,.clearfix:after{content:" ";display:table}.clearfix:after{clear:both}.center-block{display:block;margin-left:auto;margin-right:auto}.pull-right{float:right!important}.pull-left{float:left!important}.hide{display:none!important}.show{display:block!important}.invisible{visibility:hidden}.text-hide{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.hidden{display:none!important;visibility:hidden!important}.affix{position:fixed;transform:translate3d(0,0,0)}.hljs{display:block;overflow-x:auto;padding:.5em;background:#002b36;color:#839496;-webkit-text-size-adjust:none}.hljs-comment,.hljs-template_comment,.diff .hljs-header,.hljs-doctype,.hljs-pi,.lisp .hljs-string,.hljs-javadoc{color:#586e75}.hljs-keyword,.hljs-winutils,.method,.hljs-addition,.css .hljs-tag,.hljs-request,.hljs-status,.nginx .hljs-title{color:#859900}.hljs-number,.hljs-command,.hljs-string,.hljs-tag .hljs-value,.hljs-rules .hljs-value,.hljs-phpdoc,.hljs-dartdoc,.tex .hljs-formula,.hljs-regexp,.hljs-hexcolor,.hljs-link_url{color:#2aa198}.hljs-title,.hljs-localvars,.hljs-chunk,.hljs-decorator,.hljs-built_in,.hljs-identifier,.vhdl .hljs-literal,.hljs-id,.css .hljs-function{color:#268bd2}.hljs-attribute,.hljs-variable,.lisp .hljs-body,.smalltalk .hljs-number,.hljs-constant,.hljs-class .hljs-title,.hljs-parent,.hljs-type,.hljs-link_reference{color:#b58900}.hljs-preprocessor,.hljs-preprocessor .hljs-keyword,.hljs-pragma,.hljs-shebang,.hljs-symbol,.hljs-symbol .hljs-string,.diff .hljs-change,.hljs-special,.hljs-attr_selector,.hljs-subst,.hljs-cdata,.css .hljs-pseudo,.hljs-header{color:#cb4b16}.hljs-deletion,.hljs-important{color:#dc322f}.hljs-link_label{color:#6c71c4}.tex .hljs-formula{background:#073642}*,*:before,*:after{box-sizing:border-box}html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background:0 0}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{margin:.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}images{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}pre{overflow:auto}code,kbd{font-size:1em}code,kbd,pre,samp{font-family:monospace,monospace}samp{font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0;margin-right:5px}input[type="number"]::-webkit-inner-spin-button,input[type="number"]::-webkit-outer-spin-button{height:auto}input[type="search"]{-webkit-appearance:textfield;box-sizing:content-box}input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:700}table{border-collapse:collapse;border-spacing:0}.debug{background-color:#ffc0cb!important}.ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ir{background-color:transparent;border:0;overflow:hidden}.ir::before{content:'';display:block;height:150%;width:0}html{font-size:.875em;background:#fff;color:#373D49}html,body{font-family:Georgia,Cambria,serif;height:100%}body{font-size:1rem;font-weight:400;line-height:2rem}ul,ol{margin-bottom:.83999rem;padding-top:.16001rem}li{font-feature-settings:'kern' 1,'onum' 1,'liga' 1;margin-left:1rem}li>ul,li>ol{margin-bottom:0}p{padding-top:.66001rem;font-feature-settings:'kern' 1,'onum' 1,'liga' 1;margin-top:0}p,pre{margin-bottom:1.33999rem}pre{font-size:1rem;padding:.66001rem 9.5px 9.5px;line-height:2rem;background:linear-gradient(to bottom,#fff 0,#fff .75rem,#f5f7fa .75rem,#f5f7fa 2.75rem,#fff 2.75rem,#fff 4rem);background-size:100% 4rem;border-color:#D3DAEA}blockquote{margin:0}blockquote p{font-size:1rem;margin-bottom:.33999rem;font-style:italic;padding:.66001rem 1rem 1rem;border-left:3px solid #A0AABF}th,td{padding:12px}h1,h2,h3,h4,h5,h6{font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;font-feature-settings:'dlig' 1,'liga' 1,'lnum' 1,'kern' 1;font-style:normal;font-weight:600;margin-top:0}h1{line-height:3rem;font-size:2.0571429rem;margin-bottom:.21999rem;padding-top:.78001rem}h2{font-size:1.953125rem;margin-bottom:.1835837rem;padding-top:.8164163rem}h2,h3{line-height:3rem}h3{font-size:1.6457143rem;margin-bottom:.07599rem;padding-top:.92401rem}h4{font-size:1.5625rem;margin-bottom:.546865rem;padding-top:.453135rem}h5{font-size:1.25rem;margin-bottom:-.56251rem;padding-top:.56251rem}h6{font-size:1rem;margin-bottom:-.65001rem;padding-top:.65001rem}a{cursor:pointer;color:#35D7BB;text-decoration:none}a:hover,a:focus{border-bottom-color:#35D7BB;color:#dff9f4}img{height:auto;max-width:100%}dt{font-style:italic;font-weight:600}.g{display:block}.g:after{clear:both;content:'';display:table}.g-b{float:left;margin:0;width:100%}.g{margin-left:-16px;margin-right:-16px}.g-b{padding-left:16px;padding-right:16px}.g-b--center{display:block;float:none;margin:0 auto}.g-b--right{float:right}.g-b--1of1{width:100%}.g-b--1of2,.g-b--2of4,.g-b--3of6,.g-b--4of8,.g-b--5of10,.g-b--6of12{width:50%}.g-b--1of3,.g-b--2of6,.g-b--4of12{width:33.333%}.g-b--2of3,.g-b--4of6,.g-b--8of12{width:66.666%}.g-b--1of4,.g-b--2of8,.g-b--3of12{width:25%}.g-b--3of4,.g-b--6of8,.g-b--9of12{width:75%}.g-b--1of5,.g-b--2of10{width:20%}.g-b--2of5,.g-b--4of10{width:40%}.g-b--3of5,.g-b--6of10{width:60%}.g-b--4of5,.g-b--8of10{width:80%}.g-b--1of6,.g-b--2of12{width:16.666%}.g-b--5of6,.g-b--10of12{width:83.333%}.g-b--1of8{width:12.5%}.g-b--3of8{width:37.5%}.g-b--5of8{width:62.5%}.g-b--7of8{width:87.5%}.g-b--1of10{width:10%}.g-b--3of10{width:30%}.g-b--7of10{width:70%}.g-b--9of10{width:90%}.g-b--1of12{width:8.333%}.g-b--5of12{width:41.666%}.g-b--7of12{width:58.333%}.g-b--11of12{width:91.666%}.g-b--push--1of1{margin-left:100%}.g-b--push--1of2,.g-b--push--2of4,.g-b--push--3of6,.g-b--push--4of8,.g-b--push--5of10,.g-b--push--6of12{margin-left:50%}.g-b--push--1of3,.g-b--push--2of6,.g-b--push--4of12{margin-left:33.333%}.g-b--push--2of3,.g-b--push--4of6,.g-b--push--8of12{margin-left:66.666%}.g-b--push--1of4,.g-b--push--2of8,.g-b--push--3of12{margin-left:25%}.g-b--push--3of4,.g-b--push--6of8,.g-b--push--9of12{margin-left:75%}.g-b--push--1of5,.g-b--push--2of10{margin-left:20%}.g-b--push--2of5,.g-b--push--4of10{margin-left:40%}.g-b--push--3of5,.g-b--push--6of10{margin-left:60%}.g-b--push--4of5,.g-b--push--8of10{margin-left:80%}.g-b--push--1of6,.g-b--push--2of12{margin-left:16.666%}.g-b--push--5of6,.g-b--push--10of12{margin-left:83.333%}.g-b--push--1of8{margin-left:12.5%}.g-b--push--3of8{margin-left:37.5%}.g-b--push--5of8{margin-left:62.5%}.g-b--push--7of8{margin-left:87.5%}.g-b--push--1of10{margin-left:10%}.g-b--push--3of10{margin-left:30%}.g-b--push--7of10{margin-left:70%}.g-b--push--9of10{margin-left:90%}.g-b--push--1of12{margin-left:8.333%}.g-b--push--5of12{margin-left:41.666%}.g-b--push--7of12{margin-left:58.333%}.g-b--push--11of12{margin-left:91.666%}.g-b--pull--1of1{margin-right:100%}.g-b--pull--1of2,.g-b--pull--2of4,.g-b--pull--3of6,.g-b--pull--4of8,.g-b--pull--5of10,.g-b--pull--6of12{margin-right:50%}.g-b--pull--1of3,.g-b--pull--2of6,.g-b--pull--4of12{margin-right:33.333%}.g-b--pull--2of3,.g-b--pull--4of6,.g-b--pull--8of12{margin-right:66.666%}.g-b--pull--1of4,.g-b--pull--2of8,.g-b--pull--3of12{margin-right:25%}.g-b--pull--3of4,.g-b--pull--6of8,.g-b--pull--9of12{margin-right:75%}.g-b--pull--1of5,.g-b--pull--2of10{margin-right:20%}.g-b--pull--2of5,.g-b--pull--4of10{margin-right:40%}.g-b--pull--3of5,.g-b--pull--6of10{margin-right:60%}.g-b--pull--4of5,.g-b--pull--8of10{margin-right:80%}.g-b--pull--1of6,.g-b--pull--2of12{margin-right:16.666%}.g-b--pull--5of6,.g-b--pull--10of12{margin-right:83.333%}.g-b--pull--1of8{margin-right:12.5%}.g-b--pull--3of8{margin-right:37.5%}.g-b--pull--5of8{margin-right:62.5%}.g-b--pull--7of8{margin-right:87.5%}.g-b--pull--1of10{margin-right:10%}.g-b--pull--3of10{margin-right:30%}.g-b--pull--7of10{margin-right:70%}.g-b--pull--9of10{margin-right:90%}.g-b--pull--1of12{margin-right:8.333%}.g-b--pull--5of12{margin-right:41.666%}.g-b--pull--7of12{margin-right:58.333%}.g-b--pull--11of12{margin-right:91.666%}.splashscreen{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#373D49;z-index:22}.splashscreen-dillinger{width:260px;height:auto;display:block;margin:0 auto;padding-bottom:3rem}.splashscreen p{font-size:1.25rem;padding-top:.56251rem;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;font-weight:400;text-align:center;max-width:500px;margin:0 auto;color:#FFF}.sp-center{position:relative;transform:translateY(-50%);top:50%}.open-menu>.wrapper{overflow-x:hidden}.page{margin:0 auto;position:relative;top:0;left:0;width:100%;height:100%;z-index:2;transition:all .25s ease-in-out;background-color:#fff;padding-top:51px;will-change:left}.open-menu .page{left:270px}.title{line-height:1rem;font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem;font-weight:500;color:#A0AABF;letter-spacing:1px;text-transform:uppercase;padding-left:16px;padding-right:16px;margin-top:1rem}.split-preview .title{padding-left:0}.title-document{line-height:1rem;font-size:1.25rem;margin-bottom:.89999rem;padding-top:.10001rem;font-weight:400;font-family:"Ubuntu Mono",Monaco;color:#373D49;padding-left:16px;padding-right:16px;width:80%;min-width:300px;outline:0;border:none}.icon{display:block;margin:0 auto;width:36px;height:36px;border-radius:3px;text-align:center}.icon svg{display:inline-block;margin-left:auto;margin-right:auto}.icon-preview{background-color:#373D49;line-height:40px}.icon-preview svg{width:19px;height:12px}.icon-settings{background-color:#373D49;line-height:44px}.icon-settings svg{width:18px;height:18px}.icon-link{width:16px;height:16px;line-height:1;margin-right:24px;text-align:right}.navbar{background-color:#373D49;height:51px;width:100%;position:fixed;top:0;left:0;z-index:6;transition:all .25s ease-in-out;will-change:left}.navbar:after{content:"";display:table;clear:both}.open-menu .navbar{left:270px}.navbar-brand{float:left;margin:0 0 0 24px;padding:0;line-height:42px}.navbar-brand svg{width:85px;height:11px}.nav-left{float:left}.nav-right{float:right}.nav-sidebar{width:100%}.menu{list-style:none;margin:0;padding:0}.menu a{border:0;color:#A0AABF;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;outline:none;text-transform:uppercase}.menu a:hover{color:#35D7BB}.menu .menu-item{border:0;display:none;float:left;margin:0;position:relative}.menu .menu-item>a{display:block;font-size:12px;height:51px;letter-spacing:1px;line-height:51px;padding:0 24px}.menu .menu-item--settings,.menu .menu-item--preview,.menu .menu-item--save-to.in-sidebar,.menu .menu-item--import-from.in-sidebar,.menu .menu-item--link-unlink.in-sidebar,.menu .menu-item--documents.in-sidebar{display:block}.menu .menu-item--documents{padding-bottom:1rem}.menu .menu-item.open>a{background-color:#1D212A}.menu .menu-item-icon>a{height:auto;padding:0}.menu .menu-item-icon:hover>a{background-color:transparent}.menu .menu-link.open i{background-color:#1D212A}.menu .menu-link.open g{fill:#35D7BB}.menu .menu-link-preview,.menu .menu-link-settings{margin-top:8px;width:51px}.menu-sidebar{width:100%}.menu-sidebar .menu-item{float:none;margin-bottom:1px;width:100%}.menu-sidebar .menu-item.open>a{background-color:#373D49}.menu-sidebar .open .caret{transform:rotate(180deg)}.menu-sidebar>.menu-item:hover .dropdown a,.menu-sidebar>.menu-item:hover .settings a{background-color:transparent}.menu-sidebar .menu-link{background-color:#373D49;font-weight:600}.menu-sidebar .menu-link:after{content:"";display:table;clear:both}.menu-sidebar .menu-link>span{float:left}.menu-sidebar .menu-link>.caret{float:right;text-align:right;top:22px}.menu-sidebar .dropdown,.menu-sidebar .settings{background-color:transparent;position:static;width:100%}.dropdown{position:absolute;right:0;top:51px;width:188px}.dropdown,.settings{display:none;background-color:#1D212A}.dropdown{padding:0}.dropdown,.settings,.sidebar-list{list-style:none;margin:0}.sidebar-list{padding:0}.dropdown li{margin:32px 0;padding:0 0 0 32px}.dropdown li,.settings li{line-height:1}.sidebar-list li{line-height:1;margin:32px 0;padding:0 0 0 32px}.dropdown a{color:#D0D6E2}.dropdown a,.settings a,.sidebar-list a{display:block;text-transform:none}.sidebar-list a{color:#D0D6E2}.dropdown a:after,.settings a:after,.sidebar-list a:after{content:"";display:table;clear:both}.dropdown .icon,.settings .icon,.sidebar-list .icon{float:right}.open .dropdown,.open .settings,.open .sidebar-list{display:block}.open .dropdown.collapse,.open .collapse.settings,.open .sidebar-list.collapse{display:none}.open .dropdown.collapse.in,.open .collapse.in.settings,.open .sidebar-list.collapse.in{display:block}.dropdown .unlinked .icon,.settings .unlinked .icon,.sidebar-list .unlinked .icon{opacity:.3}.dropdown.documents li,.documents.settings li,.sidebar-list.documents li{background-image:url("../img/icons/file.svg");background-position:240px center;background-repeat:no-repeat;background-size:14px 16px;padding:3px 32px}.dropdown.documents li.octocat,.documents.settings li.octocat,.sidebar-list.documents li.octocat{background-image:url("../img/icons/octocat.svg");background-position:234px center;background-size:24px 24px}.dropdown.documents li:last-child,.documents.settings li:last-child,.sidebar-list.documents li:last-child{margin-bottom:1rem}.dropdown.documents li.active a,.documents.settings li.active a,.sidebar-list.documents li.active a{color:#35D7BB}.settings{position:fixed;top:67px;right:16px;border-radius:3px;width:288px;background-color:#373D49;padding:16px;z-index:7}.show-settings .settings{display:block}.settings .has-checkbox{float:left}.settings form{display:-ms-flexbox;display:flex;-ms-flex-direction:row;flex-direction:row;-ms-flex-pack:justify;justify-content:space-between}.settings input{width:20%}.settings a{font-size:1.25rem;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;font-weight:400;-webkit-font-smoothing:antialiased;line-height:28px;color:#D0D6E2}.settings a:after{content:"";display:table;clear:both}.settings a:hover{color:#35D7BB}.settings li{border-bottom:1px solid #4F535B;margin:0;padding:16px 0}.settings li:last-child{border-bottom:none}.brand{border:none;display:block}.brand:hover g{fill:#35D7BB}.toggle{display:block;float:left;height:16px;padding:25px 16px 26px;width:40px}.toggle span:after,.toggle span:before{content:'';left:0;position:absolute;top:-6px}.toggle span:after{top:6px}.toggle span{display:block;position:relative}.toggle span,.toggle span:after,.toggle span:before{-webkit-backface-visibility:hidden;backface-visibility:hidden;background-color:#D3DAEA;height:2px;transition:all .3s;width:20px}.open-menu .toggle span{background-color:transparent}.open-menu .toggle span:before{transform:rotate(45deg) translate(3px,3px)}.open-menu .toggle span:after{transform:rotate(-45deg) translate(5px,-6px)}.caret{display:inline-block;width:0;height:0;margin-left:6px;vertical-align:middle;position:relative;top:-1px;border-top:4px solid;border-right:4px solid transparent;border-left:4px solid transparent}.sidebar{overflow:auto;height:100%;padding-right:15px;padding-bottom:15px;width:285px}.sidebar-wrapper{-webkit-overflow-scrolling:touch;background-color:#2B2F36;left:0;height:100%;overflow-y:hidden;position:fixed;top:0;width:285px;z-index:1}.sidebar-branding{width:160px;padding:0;margin:16px auto}.header{border-bottom:1px solid #E8E8E8;position:relative}.words,.characters{line-height:1rem;font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem;font-weight:500;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;letter-spacing:1px;text-transform:uppercase;z-index:5;position:absolute;right:16px;top:0}.words span,.characters span{color:#A0AABF}.words .counter,.characters .counter{color:#000}.words+.characters{top:22px}.mr10{margin-right:10px}.btn{text-align:center;display:inline-block;width:100%;text-transform:uppercase;font-weight:600;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;font-size:14px;text-shadow:0 1px 0 #1b8b77;padding:16px 24px;background-color:#35D7BB;border-radius:3px;margin:0 auto 16px;line-height:1;color:#fff;transition:all .15s linear;-webkit-font-smoothing:antialiased}.btn--new,.btn--save{display:block;width:238px}.btn--new:hover,.btn--new:focus,.btn--save:hover,.btn--save:focus{color:#fff;border-bottom-color:transparent;box-shadow:0 1px 3px #24b59c;text-shadow:0 1px 0 #24b59c}.btn--save{background-color:#4A5261;text-shadow:0 1px 1px #1e2127}.btn--save:hover,.btn--save:focus{color:#fff;border-bottom-color:transparent;box-shadow:0 1px 5px #08090a;text-shadow:none}.btn--delete{display:block;width:238px;background-color:transparent;font-size:12px;text-shadow:none}.btn--delete:hover,.btn--delete:focus{color:#fff;border-bottom-color:transparent;text-shadow:0 1px 0 #08090a;opacity:.8}.btn--delete-modal,.btn--ok,.btn--close{border-top:0;background-color:#4A5261;text-shadow:0 1px 0 #08090a;margin:0}.btn--delete-modal:hover,.btn--delete-modal:focus,.btn--ok:hover,.btn--ok:focus,.btn--close:hover,.btn--close:focus{color:#fff;background-color:#292d36;text-shadow:none}.btn--delete-modal{display:inline;width:auto}.overlay{position:absolute;top:0;left:0;width:100%;height:100%;background-color:rgba(55,61,73,.8);transition:all .25s ease-in-out;transition-timing-function:ease-out;will-change:left,opacity,visibility;z-index:5;opacity:0;visibility:hidden}.show-settings .overlay{visibility:visible;opacity:1}.switch{float:right;line-height:1}.switch input{display:none}.switch small{display:inline-block;cursor:pointer;padding:0 24px 0 0;transition:all ease .2s;background-color:#2B2F36;border-color:#2B2F36}.switch small,.switch small:before{border-radius:30px;box-shadow:inset 0 0 2px 0 #14171F}.switch small:before{display:block;content:'';width:28px;height:28px;background:#fff}.switch.checked small{padding-right:0;padding-left:24px;background-color:#35D7BB;box-shadow:none}.modal--dillinger.about .modal-dialog{font-size:1.25rem;max-width:500px}.modal--dillinger.scope .modal-dialog{max-width:300px;margin:5rem auto}.modal--dillinger .modal-dialog{max-width:600px;width:auto;margin:5rem auto}.modal--dillinger .modal-content{background:#373D49;border-radius:3px;box-shadow:0 2px 5px 0 #2C3B59;color:#fff;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;font-weight:400;padding:2rem}.modal--dillinger ul{list-style-type:disc;margin:1rem 0;padding:0 0 0 1rem}.modal--dillinger li{padding:0;margin:0}.modal--dillinger .modal-header{border:0;padding:0}.modal--dillinger .modal-body{padding:0}.modal--dillinger .modal-footer{border:0;padding:0}.modal--dillinger .close{color:#fff;opacity:1}.modal-backdrop{background-color:#373D49}.pagination--dillinger{padding:0!important;margin:1.5rem 0!important;display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between;-ms-flex-direction:row;flex-direction:row;-ms-flex-align:center;align-items:center;-ms-flex-line-pack:stretch;align-content:stretch}.pagination--dillinger li{display:-ms-flexbox;display:flex;-ms-flex-positive:1;flex-grow:1;text-align:center}.pagination--dillinger li:first-child>a,.pagination--dillinger li.disabled>a,.pagination--dillinger li.disabled>a:hover,.pagination--dillinger li.disabled>a:focus,.pagination--dillinger li>a{background-color:transparent;border-color:#4F535B;border-right-color:transparent}.pagination--dillinger li.active>a,.pagination--dillinger li.active>a:hover,.pagination--dillinger li.active>a:focus{border-color:#4A5261;background-color:#4A5261;color:#fff}.pagination--dillinger li>a{float:none;color:#fff;width:100%;display:block;text-align:center;margin:0;border-right-color:transparent;padding:6px}.pagination--dillinger li>a:hover,.pagination--dillinger li>a:focus{border-color:#35D7BB;background-color:#35D7BB;color:#fff}.pagination--dillinger li:last-child a{border-color:#4F535B}.pagination--dillinger li:first-child a{border-right-color:transparent}.diNotify{position:absolute;z-index:9999;left:0;right:0;top:0;margin:0 auto;max-width:400px;text-align:center;transition:top .5s ease-in-out,opacity .5s ease-in-out;visibility:hidden}.diNotify-body{-webkit-font-smoothing:antialiased;background-color:#35D7BB;background:#666E7F;border-radius:3px;color:#fff;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;font-weight:400;overflow:hidden;padding:1rem 2rem .5rem;display:-ms-flexbox;display:flex;-ms-flex-align:baseline;align-items:baseline;-ms-flex-pack:center;justify-content:center}.diNotify-icon{display:block;width:16px;height:16px;line-height:16px;position:relative;top:3px}.diNotify-message{padding-left:1rem}.zen-wrapper{position:fixed;top:0;left:0;right:0;bottom:0;width:100%;height:100%;z-index:10;background-color:#FFF;opacity:0;transition:opacity .25s ease-in-out}.zen-wrapper.on{opacity:1}.enter-zen-mode{background-image:url("../img/icons/enter-zen.svg");right:.5rem;top:.313rem;display:none}.enter-zen-mode,.close-zen-mode{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0;background-repeat:no-repeat;width:32px;height:32px;display:block;position:absolute}.close-zen-mode{background-image:url("../img/icons/exit-zen.svg");right:1rem;top:1rem}.zen-page{position:relative;top:0;bottom:0;z-index:11;height:100%;width:100%}#zen{font-size:1.25rem;width:300px;height:80%;margin:0 auto;position:relative;top:10%}#zen:before,#zen:after{content:"";position:absolute;height:10%;width:100%;z-index:12;pointer-events:none}#preview .table{width:auto}.ui-resizable{position:relative}.ui-resizable-handle{position:absolute;font-size:.1px;z-index:99999;display:block}.ui-resizable-e{background-color:#666;border-right:8px solid #e8e8e8;border-left:1px solid #222;width:10px;z-index:88!important;position:relative}.ui-resizable-e:after{content:"-";display:block;position:absolute;top:calc(50% - 16px);left:0;height:25px;width:2px;background-color:rgba(0,0,0,.4);margin:3px}#editor{cursor:ew-resize;position:relative;z-index:auto}.profile-pic{float:left;width:250px}#_default_ a::before{color:#A0AABF}#_default_ img{display:none}#_default_ #_default_{display:block;float:left;max-width:38%;word-wrap:break-word}#_default_ .default-ad{display:none}#_default_ ._default_{display:block}#_default_ a{color:#35d7bb;text-decoration:none}#_default_ a:hover{color:#8ae8d8}#_default_ .default-image{display:none}#_default_ .default-title:after{content:"&nbsp;—&nbsp;"}#_default_ .default-title,#_default_ .default-text,#_default_ .default-description{display:inline}#_default_ .default-title{position:relative;font-weight:600;display:none}#_default_ a:before{position:relative;top:0;padding:5px;color:#a0aabf;content:"Ad";text-transform:uppercase;font-size:8px;font-family:Verdana,sans-serif}#_default_{display:block;float:left;max-width:38%;word-wrap:break-word}#_default_ ._default_{display:block;font-size:.75rem;height:51px;letter-spacing:1px;line-height:1rem;padding:18px 24px}body{max-width:1024px;margin:0 auto;overflow:auto;padding:2%}.split{overflow:scroll;padding:0!important;-webkit-overflow-scrolling:touch}.split-editor{padding-left:0;padding-right:0;position:relative;z-index:3}.show-preview .split-editor{display:none}.split-preview{background-color:#fff;display:none;top:0;position:relative;z-index:4}.show-preview .split-preview{display:block}#editor{font-size:1rem;font-family:"Ubuntu Mono",Monaco;font-weight:400;line-height:2rem;width:100%;height:100%}#editor .ace_gutter{-webkit-font-smoothing:antialiased}.editor-header{width:50%;float:left;border-bottom:1px solid #E8E8E8;position:relative}.editor-header--first{border-right:1px solid #E8E8E8}.editor-header .title{display:inline-block}.preview-html{padding:15px}.preview-html a{color:#A0AABF;text-decoration:underline}.preview-src{white-space:normal}.preview-mode-toggle-src{background-image:url("../img/icons/code.svg")}.preview-mode-toggle-src,.preview-mode-toggle-html{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0;background-repeat:no-repeat;width:32px;height:32px;display:block;position:absolute;right:.5rem;top:.5rem;display:none}.preview-mode-toggle-html{background-image:url("../img/icons/eye.svg")}.sr-only{visibility:hidden;text-overflow:110%;overflow:hidden;top:-100px;position:absolute}.mnone{margin:0!important}@media screen and (min-width:27.5em){html{font-size:.875em}body{font-size:1rem}ul,ol{margin-bottom:.83999rem;padding-top:.16001rem}p{padding-top:.66001rem}p,pre{margin-bottom:1.33999rem}pre,blockquote p{font-size:1rem;padding-top:.66001rem}blockquote p{margin-bottom:.33999rem}h1{font-size:2.0571429rem;margin-bottom:.21999rem;padding-top:.78001rem}h2{font-size:1.953125rem;margin-bottom:.1835837rem;padding-top:.8164163rem}h3{font-size:1.6457143rem;margin-bottom:.07599rem;padding-top:.92401rem}h4{font-size:1.5625rem;margin-bottom:.546865rem;padding-top:.453135rem}h5{font-size:1.25rem;margin-bottom:-.56251rem;padding-top:.56251rem}h6{font-size:1rem;margin-bottom:-.65001rem;padding-top:.65001rem}.g{margin-left:-16px;margin-right:-16px}.g-b{padding-left:16px;padding-right:16px}.g-b--m1of1{width:100%}.g-b--m1of2,.g-b--m2of4,.g-b--m3of6,.g-b--m4of8,.g-b--m5of10,.g-b--m6of12{width:50%}.g-b--m1of3,.g-b--m2of6,.g-b--m4of12{width:33.333%}.g-b--m2of3,.g-b--m4of6,.g-b--m8of12{width:66.666%}.g-b--m1of4,.g-b--m2of8,.g-b--m3of12{width:25%}.g-b--m3of4,.g-b--m6of8,.g-b--m9of12{width:75%}.g-b--m1of5,.g-b--m2of10{width:20%}.g-b--m2of5,.g-b--m4of10{width:40%}.g-b--m3of5,.g-b--m6of10{width:60%}.g-b--m4of5,.g-b--m8of10{width:80%}.g-b--m1of6,.g-b--m2of12{width:16.666%}.g-b--m5of6,.g-b--m10of12{width:83.333%}.g-b--m1of8{width:12.5%}.g-b--m3of8{width:37.5%}.g-b--m5of8{width:62.5%}.g-b--m7of8{width:87.5%}.g-b--m1of10{width:10%}.g-b--m3of10{width:30%}.g-b--m7of10{width:70%}.g-b--m9of10{width:90%}.g-b--m1of12{width:8.333%}.g-b--m5of12{width:41.666%}.g-b--m7of12{width:58.333%}.g-b--m11of12{width:91.666%}.g-b--push--m1of1{margin-left:100%}.g-b--push--m1of2,.g-b--push--m2of4,.g-b--push--m3of6,.g-b--push--m4of8,.g-b--push--m5of10,.g-b--push--m6of12{margin-left:50%}.g-b--push--m1of3,.g-b--push--m2of6,.g-b--push--m4of12{margin-left:33.333%}.g-b--push--m2of3,.g-b--push--m4of6,.g-b--push--m8of12{margin-left:66.666%}.g-b--push--m1of4,.g-b--push--m2of8,.g-b--push--m3of12{margin-left:25%}.g-b--push--m3of4,.g-b--push--m6of8,.g-b--push--m9of12{margin-left:75%}.g-b--push--m1of5,.g-b--push--m2of10{margin-left:20%}.g-b--push--m2of5,.g-b--push--m4of10{margin-left:40%}.g-b--push--m3of5,.g-b--push--m6of10{margin-left:60%}.g-b--push--m4of5,.g-b--push--m8of10{margin-left:80%}.g-b--push--m1of6,.g-b--push--m2of12{margin-left:16.666%}.g-b--push--m5of6,.g-b--push--m10of12{margin-left:83.333%}.g-b--push--m1of8{margin-left:12.5%}.g-b--push--m3of8{margin-left:37.5%}.g-b--push--m5of8{margin-left:62.5%}.g-b--push--m7of8{margin-left:87.5%}.g-b--push--m1of10{margin-left:10%}.g-b--push--m3of10{margin-left:30%}.g-b--push--m7of10{margin-left:70%}.g-b--push--m9of10{margin-left:90%}.g-b--push--m1of12{margin-left:8.333%}.g-b--push--m5of12{margin-left:41.666%}.g-b--push--m7of12{margin-left:58.333%}.g-b--push--m11of12{margin-left:91.666%}.g-b--pull--m1of1{margin-right:100%}.g-b--pull--m1of2,.g-b--pull--m2of4,.g-b--pull--m3of6,.g-b--pull--m4of8,.g-b--pull--m5of10,.g-b--pull--m6of12{margin-right:50%}.g-b--pull--m1of3,.g-b--pull--m2of6,.g-b--pull--m4of12{margin-right:33.333%}.g-b--pull--m2of3,.g-b--pull--m4of6,.g-b--pull--m8of12{margin-right:66.666%}.g-b--pull--m1of4,.g-b--pull--m2of8,.g-b--pull--m3of12{margin-right:25%}.g-b--pull--m3of4,.g-b--pull--m6of8,.g-b--pull--m9of12{margin-right:75%}.g-b--pull--m1of5,.g-b--pull--m2of10{margin-right:20%}.g-b--pull--m2of5,.g-b--pull--m4of10{margin-right:40%}.g-b--pull--m3of5,.g-b--pull--m6of10{margin-right:60%}.g-b--pull--m4of5,.g-b--pull--m8of10{margin-right:80%}.g-b--pull--m1of6,.g-b--pull--m2of12{margin-right:16.666%}.g-b--pull--m5of6,.g-b--pull--m10of12{margin-right:83.333%}.g-b--pull--m1of8{margin-right:12.5%}.g-b--pull--m3of8{margin-right:37.5%}.g-b--pull--m5of8{margin-right:62.5%}.g-b--pull--m7of8{margin-right:87.5%}.g-b--pull--m1of10{margin-right:10%}.g-b--pull--m3of10{margin-right:30%}.g-b--pull--m7of10{margin-right:70%}.g-b--pull--m9of10{margin-right:90%}.g-b--pull--m1of12{margin-right:8.333%}.g-b--pull--m5of12{margin-right:41.666%}.g-b--pull--m7of12{margin-right:58.333%}.g-b--pull--m11of12{margin-right:91.666%}.splashscreen p{font-size:1.25rem;margin-bottom:1.43749rem;padding-top:.56251rem}.title{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.title-document{margin-bottom:.89999rem;padding-top:.10001rem}.title-document,.settings a{font-size:1.25rem}.words,.characters{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.modal--dillinger.about .modal-dialog,#zen{font-size:1.25rem}#zen{width:400px}#editor{font-size:1rem}}@media screen and (min-width:46.25em){html{font-size:.875em}body{font-size:1rem}ul,ol{margin-bottom:.83999rem;padding-top:.16001rem}p{padding-top:.66001rem}p,pre{margin-bottom:1.33999rem}pre,blockquote p{font-size:1rem;padding-top:.66001rem}blockquote p{margin-bottom:.33999rem}h1{font-size:2.0571429rem;margin-bottom:.21999rem;padding-top:.78001rem}h2{font-size:1.953125rem;margin-bottom:.1835837rem;padding-top:.8164163rem}h3{font-size:1.6457143rem;margin-bottom:.07599rem;padding-top:.92401rem}h4{font-size:1.5625rem;margin-bottom:.546865rem;padding-top:.453135rem}h5{font-size:1.25rem;margin-bottom:-.56251rem;padding-top:.56251rem}h6{font-size:1rem;margin-bottom:-.65001rem;padding-top:.65001rem}.g{margin-left:-16px;margin-right:-16px}.g-b{padding-left:16px;padding-right:16px}.g-b--t1of1{width:100%}.g-b--t1of2,.g-b--t2of4,.g-b--t3of6,.g-b--t4of8,.g-b--t5of10,.g-b--t6of12{width:50%}.g-b--t1of3,.g-b--t2of6,.g-b--t4of12{width:33.333%}.g-b--t2of3,.g-b--t4of6,.g-b--t8of12{width:66.666%}.g-b--t1of4,.g-b--t2of8,.g-b--t3of12{width:25%}.g-b--t3of4,.g-b--t6of8,.g-b--t9of12{width:75%}.g-b--t1of5,.g-b--t2of10{width:20%}.g-b--t2of5,.g-b--t4of10{width:40%}.g-b--t3of5,.g-b--t6of10{width:60%}.g-b--t4of5,.g-b--t8of10{width:80%}.g-b--t1of6,.g-b--t2of12{width:16.666%}.g-b--t5of6,.g-b--t10of12{width:83.333%}.g-b--t1of8{width:12.5%}.g-b--t3of8{width:37.5%}.g-b--t5of8{width:62.5%}.g-b--t7of8{width:87.5%}.g-b--t1of10{width:10%}.g-b--t3of10{width:30%}.g-b--t7of10{width:70%}.g-b--t9of10{width:90%}.g-b--t1of12{width:8.333%}.g-b--t5of12{width:41.666%}.g-b--t7of12{width:58.333%}.g-b--t11of12{width:91.666%}.g-b--push--t1of1{margin-left:100%}.g-b--push--t1of2,.g-b--push--t2of4,.g-b--push--t3of6,.g-b--push--t4of8,.g-b--push--t5of10,.g-b--push--t6of12{margin-left:50%}.g-b--push--t1of3,.g-b--push--t2of6,.g-b--push--t4of12{margin-left:33.333%}.g-b--push--t2of3,.g-b--push--t4of6,.g-b--push--t8of12{margin-left:66.666%}.g-b--push--t1of4,.g-b--push--t2of8,.g-b--push--t3of12{margin-left:25%}.g-b--push--t3of4,.g-b--push--t6of8,.g-b--push--t9of12{margin-left:75%}.g-b--push--t1of5,.g-b--push--t2of10{margin-left:20%}.g-b--push--t2of5,.g-b--push--t4of10{margin-left:40%}.g-b--push--t3of5,.g-b--push--t6of10{margin-left:60%}.g-b--push--t4of5,.g-b--push--t8of10{margin-left:80%}.g-b--push--t1of6,.g-b--push--t2of12{margin-left:16.666%}.g-b--push--t5of6,.g-b--push--t10of12{margin-left:83.333%}.g-b--push--t1of8{margin-left:12.5%}.g-b--push--t3of8{margin-left:37.5%}.g-b--push--t5of8{margin-left:62.5%}.g-b--push--t7of8{margin-left:87.5%}.g-b--push--t1of10{margin-left:10%}.g-b--push--t3of10{margin-left:30%}.g-b--push--t7of10{margin-left:70%}.g-b--push--t9of10{margin-left:90%}.g-b--push--t1of12{margin-left:8.333%}.g-b--push--t5of12{margin-left:41.666%}.g-b--push--t7of12{margin-left:58.333%}.g-b--push--t11of12{margin-left:91.666%}.g-b--pull--t1of1{margin-right:100%}.g-b--pull--t1of2,.g-b--pull--t2of4,.g-b--pull--t3of6,.g-b--pull--t4of8,.g-b--pull--t5of10,.g-b--pull--t6of12{margin-right:50%}.g-b--pull--t1of3,.g-b--pull--t2of6,.g-b--pull--t4of12{margin-right:33.333%}.g-b--pull--t2of3,.g-b--pull--t4of6,.g-b--pull--t8of12{margin-right:66.666%}.g-b--pull--t1of4,.g-b--pull--t2of8,.g-b--pull--t3of12{margin-right:25%}.g-b--pull--t3of4,.g-b--pull--t6of8,.g-b--pull--t9of12{margin-right:75%}.g-b--pull--t1of5,.g-b--pull--t2of10{margin-right:20%}.g-b--pull--t2of5,.g-b--pull--t4of10{margin-right:40%}.g-b--pull--t3of5,.g-b--pull--t6of10{margin-right:60%}.g-b--pull--t4of5,.g-b--pull--t8of10{margin-right:80%}.g-b--pull--t1of6,.g-b--pull--t2of12{margin-right:16.666%}.g-b--pull--t5of6,.g-b--pull--t10of12{margin-right:83.333%}.g-b--pull--t1of8{margin-right:12.5%}.g-b--pull--t3of8{margin-right:37.5%}.g-b--pull--t5of8{margin-right:62.5%}.g-b--pull--t7of8{margin-right:87.5%}.g-b--pull--t1of10{margin-right:10%}.g-b--pull--t3of10{margin-right:30%}.g-b--pull--t7of10{margin-right:70%}.g-b--pull--t9of10{margin-right:90%}.g-b--pull--t1of12{margin-right:8.333%}.g-b--pull--t5of12{margin-right:41.666%}.g-b--pull--t7of12{margin-right:58.333%}.g-b--pull--t11of12{margin-right:91.666%}.splashscreen-dillinger{width:500px}.splashscreen p{font-size:1.25rem;margin-bottom:1.43749rem;padding-top:.56251rem}.title{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.title-document{font-size:1.25rem;margin-bottom:.89999rem;padding-top:.10001rem}.menu .menu-item--save-to,.menu .menu-item--import-from{display:block}.menu .menu-item--preview,.menu .menu-item--save-to.in-sidebar,.menu .menu-item--import-from.in-sidebar{display:none}.settings a{font-size:1.25rem}.words,.characters{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.modal--dillinger.about .modal-dialog{font-size:1.25rem}.enter-zen-mode{display:block}.close-zen-mode{right:3rem;top:3rem}#zen{font-size:1.25rem;width:500px}.split-editor{border-right:1px solid #E8E8E8;float:left;padding-right:16px;width:50%}.show-preview .split-editor{display:block}.split-preview{display:block;float:right;position:relative;top:0;width:50%}#editor{font-size:1rem}.preview-mode-toggle-src,.preview-mode-toggle-html{display:block}}@media screen and (min-width:62.5em){html{font-size:.875em}body{font-size:1rem}ul,ol{margin-bottom:.83999rem;padding-top:.16001rem}p{padding-top:.66001rem}p,pre{margin-bottom:1.33999rem}pre,blockquote p{font-size:1rem;padding-top:.66001rem}blockquote p{margin-bottom:.33999rem}h1{font-size:2.0571429rem;margin-bottom:.21999rem;padding-top:.78001rem}h2{font-size:1.953125rem;margin-bottom:.1835837rem;padding-top:.8164163rem}h3{font-size:1.6457143rem;margin-bottom:.07599rem;padding-top:.92401rem}h4{font-size:1.5625rem;margin-bottom:.546865rem;padding-top:.453135rem}h5{font-size:1.25rem;margin-bottom:-.56251rem;padding-top:.56251rem}h6{font-size:1rem;margin-bottom:-.65001rem;padding-top:.65001rem}.g{margin-left:-16px;margin-right:-16px}.g-b{padding-left:16px;padding-right:16px}.g-b--d1of1{width:100%}.g-b--d1of2,.g-b--d2of4,.g-b--d3of6,.g-b--d4of8,.g-b--d5of10,.g-b--d6of12{width:50%}.g-b--d1of3,.g-b--d2of6,.g-b--d4of12{width:33.333%}.g-b--d2of3,.g-b--d4of6,.g-b--d8of12{width:66.666%}.g-b--d1of4,.g-b--d2of8,.g-b--d3of12{width:25%}.g-b--d3of4,.g-b--d6of8,.g-b--d9of12{width:75%}.g-b--d1of5,.g-b--d2of10{width:20%}.g-b--d2of5,.g-b--d4of10{width:40%}.g-b--d3of5,.g-b--d6of10{width:60%}.g-b--d4of5,.g-b--d8of10{width:80%}.g-b--d1of6,.g-b--d2of12{width:16.666%}.g-b--d5of6,.g-b--d10of12{width:83.333%}.g-b--d1of8{width:12.5%}.g-b--d3of8{width:37.5%}.g-b--d5of8{width:62.5%}.g-b--d7of8{width:87.5%}.g-b--d1of10{width:10%}.g-b--d3of10{width:30%}.g-b--d7of10{width:70%}.g-b--d9of10{width:90%}.g-b--d1of12{width:8.333%}.g-b--d5of12{width:41.666%}.g-b--d7of12{width:58.333%}.g-b--d11of12{width:91.666%}.g-b--push--d1of1{margin-left:100%}.g-b--push--d1of2,.g-b--push--d2of4,.g-b--push--d3of6,.g-b--push--d4of8,.g-b--push--d5of10,.g-b--push--d6of12{margin-left:50%}.g-b--push--d1of3,.g-b--push--d2of6,.g-b--push--d4of12{margin-left:33.333%}.g-b--push--d2of3,.g-b--push--d4of6,.g-b--push--d8of12{margin-left:66.666%}.g-b--push--d1of4,.g-b--push--d2of8,.g-b--push--d3of12{margin-left:25%}.g-b--push--d3of4,.g-b--push--d6of8,.g-b--push--d9of12{margin-left:75%}.g-b--push--d1of5,.g-b--push--d2of10{margin-left:20%}.g-b--push--d2of5,.g-b--push--d4of10{margin-left:40%}.g-b--push--d3of5,.g-b--push--d6of10{margin-left:60%}.g-b--push--d4of5,.g-b--push--d8of10{margin-left:80%}.g-b--push--d1of6,.g-b--push--d2of12{margin-left:16.666%}.g-b--push--d5of6,.g-b--push--d10of12{margin-left:83.333%}.g-b--push--d1of8{margin-left:12.5%}.g-b--push--d3of8{margin-left:37.5%}.g-b--push--d5of8{margin-left:62.5%}.g-b--push--d7of8{margin-left:87.5%}.g-b--push--d1of10{margin-left:10%}.g-b--push--d3of10{margin-left:30%}.g-b--push--d7of10{margin-left:70%}.g-b--push--d9of10{margin-left:90%}.g-b--push--d1of12{margin-left:8.333%}.g-b--push--d5of12{margin-left:41.666%}.g-b--push--d7of12{margin-left:58.333%}.g-b--push--d11of12{margin-left:91.666%}.g-b--pull--d1of1{margin-right:100%}.g-b--pull--d1of2,.g-b--pull--d2of4,.g-b--pull--d3of6,.g-b--pull--d4of8,.g-b--pull--d5of10,.g-b--pull--d6of12{margin-right:50%}.g-b--pull--d1of3,.g-b--pull--d2of6,.g-b--pull--d4of12{margin-right:33.333%}.g-b--pull--d2of3,.g-b--pull--d4of6,.g-b--pull--d8of12{margin-right:66.666%}.g-b--pull--d1of4,.g-b--pull--d2of8,.g-b--pull--d3of12{margin-right:25%}.g-b--pull--d3of4,.g-b--pull--d6of8,.g-b--pull--d9of12{margin-right:75%}.g-b--pull--d1of5,.g-b--pull--d2of10{margin-right:20%}.g-b--pull--d2of5,.g-b--pull--d4of10{margin-right:40%}.g-b--pull--d3of5,.g-b--pull--d6of10{margin-right:60%}.g-b--pull--d4of5,.g-b--pull--d8of10{margin-right:80%}.g-b--pull--d1of6,.g-b--pull--d2of12{margin-right:16.666%}.g-b--pull--d5of6,.g-b--pull--d10of12{margin-right:83.333%}.g-b--pull--d1of8{margin-right:12.5%}.g-b--pull--d3of8{margin-right:37.5%}.g-b--pull--d5of8{margin-right:62.5%}.g-b--pull--d7of8{margin-right:87.5%}.g-b--pull--d1of10{margin-right:10%}.g-b--pull--d3of10{margin-right:30%}.g-b--pull--d7of10{margin-right:70%}.g-b--pull--d9of10{margin-right:90%}.g-b--pull--d1of12{margin-right:8.333%}.g-b--pull--d5of12{margin-right:41.666%}.g-b--pull--d7of12{margin-right:58.333%}.g-b--pull--d11of12{margin-right:91.666%}.splashscreen-dillinger{width:700px}.splashscreen p{font-size:1.25rem;margin-bottom:1.43749rem;padding-top:.56251rem}.title{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.title-document{font-size:1.25rem;margin-bottom:.89999rem;padding-top:.10001rem}.menu .menu-item--export-as{display:block}.menu .menu-item--preview{display:none}.settings a{font-size:1.25rem}.words,.characters{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.modal--dillinger.about .modal-dialog,#zen{font-size:1.25rem}#zen{width:700px}#editor{font-size:1rem}}@media screen and (min-width:87.5em){html{font-size:.875em}body{font-size:1rem}ul,ol{margin-bottom:.83999rem;padding-top:.16001rem}p{padding-top:.66001rem}p,pre{margin-bottom:1.33999rem}pre,blockquote p{font-size:1rem;padding-top:.66001rem}blockquote p{margin-bottom:.33999rem}h1{font-size:2.0571429rem;margin-bottom:.21999rem;padding-top:.78001rem}h2{font-size:1.953125rem;margin-bottom:.1835837rem;padding-top:.8164163rem}h3{font-size:1.6457143rem;margin-bottom:.07599rem;padding-top:.92401rem}h4{font-size:1.5625rem;margin-bottom:.546865rem;padding-top:.453135rem}h5{font-size:1.25rem;margin-bottom:-.56251rem;padding-top:.56251rem}h6{font-size:1rem;margin-bottom:-.65001rem;padding-top:.65001rem}.splashscreen-dillinger{width:800px}.splashscreen p{font-size:1.25rem;margin-bottom:1.43749rem;padding-top:.56251rem}.title{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.title-document{margin-bottom:.89999rem;padding-top:.10001rem}.title-document,.settings a{font-size:1.25rem}.words,.characters{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.modal--dillinger.about .modal-dialog,#zen{font-size:1.25rem}#editor{font-size:1rem}}@media (min-width:768px){.form-inline .form-group{display:inline-block;margin-bottom:0;vertical-align:middle}.form-inline .form-control{display:inline-block;width:auto;vertical-align:middle}.form-inline .input-group{display:inline-table;vertical-align:middle}.form-inline .input-group .input-group-addon,.form-inline .input-group .input-group-btn,.form-inline .input-group .form-control{width:auto}.form-inline .input-group>.form-control{width:100%}.form-inline .control-label{margin-bottom:0;vertical-align:middle}.form-inline .radio,.form-inline .checkbox{display:inline-block;margin-top:0;margin-bottom:0;vertical-align:middle}.form-inline .radio label,.form-inline .checkbox label{padding-left:0}.form-inline .radio input[type="radio"],.form-inline .checkbox input[type="checkbox"]{position:relative;margin-left:0}.form-inline .has-feedback .form-control-feedback{top:0}.form-horizontal .control-label{text-align:right;margin-bottom:0;padding-top:7px}.form-horizontal .form-group-lg .control-label{padding-top:14.3px}.form-horizontal .form-group-sm .control-label{padding-top:6px}.modal-dialog{width:600px;margin:30px auto}.modal-content{box-shadow:0 5px 15px rgba(0,0,0,.5)}.modal-sm{width:300px}}@media (min-width:992px){.modal-lg{width:900px}}@media screen and (max-width:1200px){#_default_{max-width:30%}#_default_ ._default_{font-size:.825rem;line-height:.875rem;padding:12px 12px 6px 24px;text-align:justify}}@media screen and (max-width:1100px){#_default_{max-width:27%}#_default_ ._default_{font-size:.8rem;line-height:.85rem;padding:12px 6px 6px 24px;text-align:justify}}@media screen and (max-width:1000px){#_default_{max-width:24%}#_default_ ._default_{font-size:.775rem;line-height:.8rem;padding:12px 6px 6px 24px;text-align:justify}}@media screen and (max-width:900px){#_default_{max-width:30%}}@media screen and (max-width:767px){.table-responsive{width:100%;margin-bottom:15px;overflow-y:hidden;overflow-x:auto;-ms-overflow-style:-ms-autohiding-scrollbar;border:1px solid #ddd;-webkit-overflow-scrolling:touch}.table-responsive>.table{margin-bottom:0}.table-responsive>.table>thead>tr>th,.table-responsive>.table>thead>tr>td,.table-responsive>.table>tbody>tr>th,.table-responsive>.table>tbody>tr>td,.table-responsive>.table>tfoot>tr>th,.table-responsive>.table>tfoot>tr>td{white-space:nowrap}.table-responsive>.table-bordered{border:0}.table-responsive>.table-bordered>thead>tr>th:first-child,.table-responsive>.table-bordered>thead>tr>td:first-child,.table-responsive>.table-bordered>tbody>tr>th:first-child,.table-responsive>.table-bordered>tbody>tr>td:first-child,.table-responsive>.table-bordered>tfoot>tr>th:first-child,.table-responsive>.table-bordered>tfoot>tr>td:first-child{border-left:0}.table-responsive>.table-bordered>thead>tr>th:last-child,.table-responsive>.table-bordered>thead>tr>td:last-child,.table-responsive>.table-bordered>tbody>tr>th:last-child,.table-responsive>.table-bordered>tbody>tr>td:last-child,.table-responsive>.table-bordered>tfoot>tr>th:last-child,.table-responsive>.table-bordered>tfoot>tr>td:last-child{border-right:0}.table-responsive>.table-bordered>tbody>tr:last-child>th,.table-responsive>.table-bordered>tbody>tr:last-child>td,.table-responsive>.table-bordered>tfoot>tr:last-child>th,.table-responsive>.table-bordered>tfoot>tr:last-child>td{border-bottom:0}}@media screen and (max-width:720px){#_default_{max-width:60%}#_default_ ._default_{font-size:.75rem;line-height:1rem;padding:12px 24px}}@media screen and (max-width:620px){#_default_{max-width:50%}#_default_ ._default_{font-size:.66rem;letter-spacing:1px;line-height:1rem;padding:10px 24px}}@media screen and (max-width:520px){#_default_ ._default_{font-size:.4rem;line-height:.875rem;padding:6px 12px 6px 24px;text-align:justify}}@media screen and (max-width:460px){#_default_{display:none}}@media screen and (max-width:46.1875em){.editor-header{display:none}.editor-header--first{display:block;width:100%}}</style><link type="text/css" rel="stylesheet" charset="UTF-8" href="https://translate.googleapis.com/translate_static/css/translateelement.css"><link type="text/css" rel="stylesheet" charset="UTF-8" href="https://translate.googleapis.com/translate_static/css/translateelement.css"></head><body id="preview">
<h1 class="code-line" data-line-start="0" data-line-end="2"><a id="ACMICPC_Cheat_Sheet_0"></a>ACM-ICPC Cheat Sheet</h1>
<p class="has-line-data" data-line-start="4" data-line-end="5"><strong>Table of Contents</strong> <em>generated with <a href="https://github.com/thlorenz/doctoc">DocToc</a></em></p>
<ul>
<li class="has-line-data" data-line-start="6" data-line-end="45"><a href="#1-basic">1. Basic</a>
<ul>
<li class="has-line-data" data-line-start="7" data-line-end="9"><a href="#11-c-solution-template">1.1 C++ Solution Template</a>
<ul>
<li class="has-line-data" data-line-start="8" data-line-end="9"><a href="#111-optional-include-list">1.1.1 Optional include list</a></li>
</ul>
</li>
<li class="has-line-data" data-line-start="9" data-line-end="16"><a href="#12-strings">1.2 Strings</a>
<ul>
<li class="has-line-data" data-line-start="10" data-line-end="13"><a href="#121-c-string">1.2.1 C++ String</a>
<ul>
<li class="has-line-data" data-line-start="11" data-line-end="12"><a href="#read-one-line">read one line</a></li>
<li class="has-line-data" data-line-start="12" data-line-end="13"><a href="#convert-to-char-array">Convert to char array</a></li>
</ul>
</li>
<li class="has-line-data" data-line-start="13" data-line-end="16"><a href="#122-c-string-character-array">1.2.2 C String (Character Array)</a>
<ul>
<li class="has-line-data" data-line-start="14" data-line-end="15"><a href="#input-c-string">Input C String</a></li>
<li class="has-line-data" data-line-start="15" data-line-end="16"><a href="#convert-to-c-string">Convert to C++ string</a></li>
</ul>
</li>
</ul>
</li>
<li class="has-line-data" data-line-start="16" data-line-end="28"><a href="#13-stl-algorithm">1.3 STL Algorithm</a>
<ul>
<li class="has-line-data" data-line-start="17" data-line-end="18"><a href="#131-permutation">1.3.1 Permutation</a></li>
<li class="has-line-data" data-line-start="18" data-line-end="19"><a href="#132-binary-search">1.3.2 Binary Search</a></li>
<li class="has-line-data" data-line-start="19" data-line-end="20"><a href="#133-lower-bound">1.3.3 Lower Bound</a></li>
<li class="has-line-data" data-line-start="20" data-line-end="21"><a href="#134-swap">1.3.4 Swap</a></li>
<li class="has-line-data" data-line-start="21" data-line-end="22"><a href="#135-heap">1.3.5 Heap</a></li>
<li class="has-line-data" data-line-start="22" data-line-end="23"><a href="#136-sort">1.3.6 Sort</a></li>
<li class="has-line-data" data-line-start="23" data-line-end="28"><a href="#137-compare">1.3.7 Compare</a>
<ul>
<li class="has-line-data" data-line-start="24" data-line-end="25"><a href="#using-lambda-expression">Using lambda expression</a></li>
<li class="has-line-data" data-line-start="25" data-line-end="26"><a href="#compare-function">Compare function</a></li>
<li class="has-line-data" data-line-start="26" data-line-end="27"><a href="#define-operator-">Define operator &lt;()</a></li>
<li class="has-line-data" data-line-start="27" data-line-end="28"><a href="#define-operator">Define operator()()</a></li>
</ul>
</li>
</ul>
</li>
<li class="has-line-data" data-line-start="28" data-line-end="45"><a href="#14-stl-containers">1.4 STL Containers</a>
<ul>
<li class="has-line-data" data-line-start="29" data-line-end="35"><a href="#141-map">1.4.1 Map</a>
<ul>
<li class="has-line-data" data-line-start="30" data-line-end="31"><a href="#define-a-map">Define a Map</a></li>
<li class="has-line-data" data-line-start="31" data-line-end="32"><a href="#commonly-used-method">Commonly used method</a></li>
<li class="has-line-data" data-line-start="32" data-line-end="33"><a href="#red-black-tree">Red-black Tree</a></li>
<li class="has-line-data" data-line-start="33" data-line-end="34"><a href="#hash-map-unordered-map">Hash Map (Unordered Map)</a></li>
<li class="has-line-data" data-line-start="34" data-line-end="35"><a href="#commonly-used-method-1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commonly used method</font></font></a></li>
</ul>
</li>
<li class="has-line-data" data-line-start="35" data-line-end="36"><a href="#142-pair">1.4.2 Pair</a></li>
<li class="has-line-data" data-line-start="36" data-line-end="39"><a href="#143-vector">1.4.3 Vector</a>
<ul>
<li class="has-line-data" data-line-start="37" data-line-end="38"><a href="#constructor">Constructor</a></li>
<li class="has-line-data" data-line-start="38" data-line-end="39"><a href="#methods">Methods</a></li>
</ul>
</li>
<li class="has-line-data" data-line-start="39" data-line-end="41"><a href="#144-list">1.4.4 List</a>
<ul>
<li class="has-line-data" data-line-start="40" data-line-end="41"><a href="#methods-1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methods</font></font></a></li>
</ul>
</li>
<li class="has-line-data" data-line-start="41" data-line-end="42"><a href="#145-queue">1.4.5 Queue</a></li>
<li class="has-line-data" data-line-start="42" data-line-end="43"><a href="#146-double-ended-queue">1.4.6 Double-ended Queue</a></li>
<li class="has-line-data" data-line-start="43" data-line-end="44"><a href="#147-stack">1.4.7 Stack</a></li>
<li class="has-line-data" data-line-start="44" data-line-end="45"><a href="#148-priority-queue">1.4.8 Priority Queue</a></li>
</ul>
</li>
</ul>
</li>
<li class="has-line-data" data-line-start="45" data-line-end="71"><a href="#2-advanced-data-structures">2. Advanced Data Structures</a>
<ul>
<li class="has-line-data" data-line-start="46" data-line-end="47"><a href="#21-heap">2.1 Heap</a></li>
<li class="has-line-data" data-line-start="47" data-line-end="54"><a href="#22-tree">2.2 Tree</a>
<ul>
<li class="has-line-data" data-line-start="48" data-line-end="49"><a href="#220-tree-traversal">2.2.0 Tree Traversal</a></li>
<li class="has-line-data" data-line-start="49" data-line-end="50"><a href="#221-pointer-jumping">2.2.1 Pointer Jumping</a></li>
<li class="has-line-data" data-line-start="50" data-line-end="51"><a href="#222-heavy-light-decomposition">2.2.2 Heavy-Light Decomposition</a></li>
<li class="has-line-data" data-line-start="51" data-line-end="53"><a href="#223-lowest-common-ancestor">2.2.3 Lowest Common Ancestor</a>
<ul>
<li class="has-line-data" data-line-start="52" data-line-end="53"><a href="#2231-tarjans-off-line-algorithm">2.2.3.1 Tarjan’s Off-line Algorithm</a></li>
</ul>
</li>
<li class="has-line-data" data-line-start="53" data-line-end="54"><a href="#224-centroid-decomposition">2.2.4 Centroid Decomposition</a></li>
</ul>
</li>
<li class="has-line-data" data-line-start="54" data-line-end="55"><a href="#23-trie--trie-graph--ac-automaton">2.3 Trie / Trie Graph / AC Automaton</a></li>
<li class="has-line-data" data-line-start="55" data-line-end="56"><a href="#24-suffix-tree">2.4 Suffix Tree</a></li>
<li class="has-line-data" data-line-start="56" data-line-end="62"><a href="#25-suffix-array">2.5 Suffix Array</a>
<ul>
<li class="has-line-data" data-line-start="57" data-line-end="58"><a href="#251-build-suffix-array">2.5.1 Build Suffix Array</a></li>
<li class="has-line-data" data-line-start="58" data-line-end="59"><a href="#252-pattern-matching">2.5.2 Pattern Matching</a></li>
<li class="has-line-data" data-line-start="59" data-line-end="60"><a href="#253-longest-common-prefix">2.5.3 Longest Common Prefix</a></li>
<li class="has-line-data" data-line-start="60" data-line-end="61"><a href="#254-longest-repeated-substring">2.5.4 Longest Repeated Substring</a></li>
<li class="has-line-data" data-line-start="61" data-line-end="62"><a href="#255-longest-common-substring">2.5.5 Longest Common Substring</a></li>
</ul>
</li>
<li class="has-line-data" data-line-start="62" data-line-end="63"><a href="#26-binary-indexed-tree">2.6 Binary Indexed Tree</a></li>
<li class="has-line-data" data-line-start="63" data-line-end="67"><a href="#27-segment-tree">2.7 Segment Tree</a>
<ul>
<li class="has-line-data" data-line-start="64" data-line-end="65"><a href="#270-range-update--range-query">2.7.0 Range Update + Range Query</a></li>
<li class="has-line-data" data-line-start="65" data-line-end="66"><a href="#271-color">2.7.1 Color</a></li>
<li class="has-line-data" data-line-start="66" data-line-end="67"><a href="#272-range-sum--range-replace">2.7.2 Range Sum + Range Replace</a></li>
</ul>
</li>
<li class="has-line-data" data-line-start="67" data-line-end="68"><a href="#28-range-minimum-query-rmq">2.8 Range Minimum Query RMQ</a></li>
<li class="has-line-data" data-line-start="68" data-line-end="70"><a href="#29-union-find-set">2.9 Union-find Set</a>
<ul>
<li class="has-line-data" data-line-start="69" data-line-end="70"><a href="#291-union-find-set---application">2.9.1 Union-find Set - application</a></li>
</ul>
</li>
<li class="has-line-data" data-line-start="70" data-line-end="71"><a href="#210-bloom-filter--similar">2.10 Bloom Filter (?) (Similar)</a></li>
</ul>
</li>
<li class="has-line-data" data-line-start="71" data-line-end="85"><a href="#3-methodology">3. Methodology</a>
<ul>
<li class="has-line-data" data-line-start="72" data-line-end="73"><a href="#30-greedy">3.0 Greedy</a></li>
<li class="has-line-data" data-line-start="73" data-line-end="75"><a href="#31-recursive">3.1 Recursive</a>
<ul>
<li class="has-line-data" data-line-start="74" data-line-end="75"><a href="#311-hanoi">3.1.1 Hanoi</a></li>
</ul>
</li>
<li class="has-line-data" data-line-start="75" data-line-end="77"><a href="#32-dynamic-programming">3.2 Dynamic Programming</a>
<ul>
<li class="has-line-data" data-line-start="76" data-line-end="77"><a href="#321-longest-increasing-subsequence-lis">3.2.1 Longest Increasing Subsequence (LIS)</a></li>
</ul>
</li>
<li class="has-line-data" data-line-start="77" data-line-end="79"><a href="#33-divide-and-conquer">3.3 Divide and Conquer</a>
<ul>
<li class="has-line-data" data-line-start="78" data-line-end="79"><a href="#331-binary-search">3.3.1 binary search</a></li>
</ul>
</li>
<li class="has-line-data" data-line-start="79" data-line-end="83"><a href="#34-search">3.4 Search</a>
<ul>
<li class="has-line-data" data-line-start="80" data-line-end="81"><a href="#342-%E5%8F%8C%E5%90%91-bfs"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.4.2 Bidirectional BFS</font></font></a></li>
<li class="has-line-data" data-line-start="81" data-line-end="82"><a href="#343-%E4%BB%8E%E7%BB%88%E7%82%B9%E5%BC%80%E5%A7%8B%E6%90%9C"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.4.3 Search from the end</font></font></a></li>
<li class="has-line-data" data-line-start="82" data-line-end="83"><a href="#344-%E8%BF%AD%E4%BB%A3%E5%8A%A0%E6%B7%B1%E6%90%9C%E7%B4%A2-binary-increasedecrease"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.4.4 Iterative deepening search (binary increase/decrease)</font></font></a></li>
</ul>
</li>
<li class="has-line-data" data-line-start="83" data-line-end="85"><a href="#35-brute-force">3.5 Brute Force</a>
<ul>
<li class="has-line-data" data-line-start="84" data-line-end="85"><a href="#351-%E5%AD%90%E9%9B%86%E7%94%9F%E6%88%90"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.5.1 Subset generation</font></font></a></li>
</ul>
</li>
</ul>
</li>
<li class="has-line-data" data-line-start="85" data-line-end="89"><a href="#4-string">4. String</a>
<ul>
<li class="has-line-data" data-line-start="86" data-line-end="87"><a href="#41-kmp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1 KMP</font></font></font></font></a></li>
<li class="has-line-data" data-line-start="87" data-line-end="88"><a href="#42-boyer-moore">4.2 Boyer-Moore</a></li>
<li class="has-line-data" data-line-start="88" data-line-end="89"><a href="#43-longest-palindromic-substring-manachers-algorithm">4.3 Longest palindromic substring (Manacher’s algorithm)</a></li>
</ul>
</li>
<li class="has-line-data" data-line-start="89" data-line-end="114"><a href="#5-graph">5. Graph</a>
<ul>
<li class="has-line-data" data-line-start="90" data-line-end="91"><a href="#51-graph-structure">5.1 Graph Structure</a></li>
<li class="has-line-data" data-line-start="91" data-line-end="94"><a href="#52-minimium-spanning-tree">5.2 Minimium Spanning Tree</a>
<ul>
<li class="has-line-data" data-line-start="92" data-line-end="93"><a href="#521-prims"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2.1 Prim's</font></font></font></font></a></li>
<li class="has-line-data" data-line-start="93" data-line-end="94"><a href="#522-kruskal">5.2.2 Kruskal</a></li>
</ul>
</li>
<li class="has-line-data" data-line-start="94" data-line-end="99"><a href="#53-shortest-path">5.3 Shortest Path</a>
<ul>
<li class="has-line-data" data-line-start="95" data-line-end="96"><a href="#531-%E4%BB%BB%E6%84%8F%E4%B8%A4%E7%82%B9"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.3.1 Any two points</font></font></a></li>
<li class="has-line-data" data-line-start="96" data-line-end="97"><a href="#532-bellman%E2%80%93ford">5.3.2 Bellman–Ford</a></li>
<li class="has-line-data" data-line-start="97" data-line-end="98"><a href="#533-spfa"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.3.3 SPFA</font></font></font></font></a></li>
<li class="has-line-data" data-line-start="98" data-line-end="99"><a href="#534-dijkstra">5.3.4 Dijkstra</a></li>
</ul>
</li>
<li class="has-line-data" data-line-start="99" data-line-end="105"><a href="#54-maximum-matching">5.4 Maximum Matching</a>
<ul>
<li class="has-line-data" data-line-start="100" data-line-end="103"><a href="#541-on-bipartite-graph-%E4%BA%8C%E5%88%86%E5%9B%BE"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.4.1 on Bipartite Graph</font></font></a>
<ul>
<li class="has-line-data" data-line-start="101" data-line-end="102"><a href="#5411-hungarian-algorithm-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.4.1.1 Hungarian algorithm</font></font></a></li>
<li class="has-line-data" data-line-start="102" data-line-end="103"><a href="#5412-hopcroft%E2%80%93karp-algorithm">5.4.1.2 Hopcroft–Karp Algorithm</a></li>
</ul>
</li>
<li class="has-line-data" data-line-start="103" data-line-end="105"><a href="#542-on-general-graph">5.4.2 on General Graph</a>
<ul>
<li class="has-line-data" data-line-start="104" data-line-end="105"><a href="#5421-blossom-algorithm">5.4.2.1 Blossom Algorithm</a></li>
</ul>
</li>
</ul>
</li>
<li class="has-line-data" data-line-start="105" data-line-end="110"><a href="#55-maximum-flow-problem-%E6%9C%80%E5%A4%A7%E6%B5%81"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.5 Maximum Flow Problem</font></font></a>
<ul>
<li class="has-line-data" data-line-start="106" data-line-end="107"><a href="#551-dinic">5.5.1 Dinic</a></li>
<li class="has-line-data" data-line-start="107" data-line-end="108"><a href="#552-improved-sap--gap-optimization">5.5.2 Improved SAP + Gap Optimization</a></li>
<li class="has-line-data" data-line-start="108" data-line-end="109"><a href="#553-minimum-cost-maximum-flow">5.5.3 Minimum-Cost Maximum-Flow</a></li>
<li class="has-line-data" data-line-start="109" data-line-end="110"><a href="#554-more-applications-and-properties">5.5.4 More Applications and Properties</a></li>
</ul>
</li>
<li class="has-line-data" data-line-start="110" data-line-end="111"><a href="#56-%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F-%E5%9B%BE%E7%9A%84-%E5%89%B2%E7%82%B9-%E6%A1%A5-%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E6%94%AF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.6 Cut points, bridges, and bi-connected components of strongly connected component graphs</font></font></a></li>
<li class="has-line-data" data-line-start="111" data-line-end="112"><a href="#57-topological-sort--%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.7 Topological Sort / Topological Sort</font></font></a></li>
<li class="has-line-data" data-line-start="112" data-line-end="113"><a href="#58-euler-cyclepath-hamilton-cyclepath">5.8 Euler Cycle/Path, Hamilton Cycle/Path</a></li>
<li class="has-line-data" data-line-start="113" data-line-end="114"><a href="#59-find-negative-weight-cycle-on-a-graph">5.9 find negative (weight) Cycle on a graph</a></li>
</ul>
</li>
<li class="has-line-data" data-line-start="114" data-line-end="141"><a href="#6-number--mathematics">6. Number + Mathematics</a>
<ul>
<li class="has-line-data" data-line-start="115" data-line-end="118"><a href="#61-biginteger--bigdecimal">6.1 BigInteger + BigDecimal</a>
<ul>
<li class="has-line-data" data-line-start="116" data-line-end="117"><a href="#611-c-big-integer">6.1.1 C++ Big Integer</a></li>
<li class="has-line-data" data-line-start="117" data-line-end="118"><a href="#612-the-java-approach">6.1.2 The Java Approach</a></li>
</ul>
</li>
<li class="has-line-data" data-line-start="118" data-line-end="119"><a href="#62-matrix">6.2 Matrix</a></li>
<li class="has-line-data" data-line-start="119" data-line-end="137"><a href="#63-number-theory">6.3 Number Theory</a>
<ul>
<li class="has-line-data" data-line-start="120" data-line-end="121"><a href="#631-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0-"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.1 Euler function?</font></font></a></li>
<li class="has-line-data" data-line-start="121" data-line-end="122"><a href="#632-%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95--gcd"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.2 Euclid's algorithm/gcd</font></font></a></li>
<li class="has-line-data" data-line-start="122" data-line-end="123"><a href="#633-%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.3 Extended Euclidean Algorithm</font></font></a></li>
<li class="has-line-data" data-line-start="123" data-line-end="124"><a href="#634-%E6%B1%82%E8%A7%A3%E4%B8%8D%E5%AE%9A%E6%96%B9%E7%A8%8B"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.4 Solving indeterminate equations</font></font></a></li>
<li class="has-line-data" data-line-start="124" data-line-end="125"><a href="#635-%E6%B1%82%E8%A7%A3%E6%A8%A1%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%EF%BC%88%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%EF%BC%89"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.5 Solve modular linear equations (linear congruence equations)</font></font></a></li>
<li class="has-line-data" data-line-start="125" data-line-end="126"><a href="#636-%E6%B1%82%E8%A7%A3%E6%A8%A1%E7%9A%84%E9%80%86%E5%85%83"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.6 Solve the inverse element of the module</font></font></a></li>
<li class="has-line-data" data-line-start="126" data-line-end="127"><a href="#637-%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.7 The Chinese Remainder Theorem</font></font></a></li>
<li class="has-line-data" data-line-start="127" data-line-end="128"><a href="#638-%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.8 Least common multiple</font></font></a></li>
<li class="has-line-data" data-line-start="128" data-line-end="129"><a href="#639-%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.9 Decompose prime factors</font></font></a></li>
<li class="has-line-data" data-line-start="129" data-line-end="130"><a href="#6310-%E5%9B%A0%E6%95%B0%E4%B8%AA%E6%95%B0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.10 Number of factors</font></font></a></li>
<li class="has-line-data" data-line-start="130" data-line-end="132"><a href="#6311-%E7%B4%A0%E6%95%B0%E5%88%A4%E5%AE%9A"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.11 Primality test</font></font></a>
<ul>
<li class="has-line-data" data-line-start="131" data-line-end="132"><a href="#63111-miller-rabin-primality-test">6.3.11.1 Miller Rabin Primality Test</a></li>
</ul>
</li>
<li class="has-line-data" data-line-start="132" data-line-end="133"><a href="#6312-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.12 Base conversion</font></font></a></li>
<li class="has-line-data" data-line-start="133" data-line-end="134"><a href="#6313-a--c">6.3.13 A / C</a></li>
<li class="has-line-data" data-line-start="134" data-line-end="135"><a href="#6314-%E8%B4%A8%E6%95%B0%E8%A1%A8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.14 Prime Number Table</font></font></a></li>
<li class="has-line-data" data-line-start="135" data-line-end="136"><a href="#6315-fast-exponention">6.3.15 Fast Exponention</a></li>
<li class="has-line-data" data-line-start="136" data-line-end="137"><a href="#6316-fast-fourier-transform-fft">6.3.16 Fast Fourier Transform FFT</a></li>
</ul>
</li>
<li class="has-line-data" data-line-start="137" data-line-end="141"><a href="#64-game-theory-%E5%8D%9A%E5%BC%88%E8%AE%BA"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.4 Game Theory</font></font></a>
<ul>
<li class="has-line-data" data-line-start="138" data-line-end="141"><a href="#641-impartial-combinatorial-game">6.4.1 Impartial Combinatorial Game</a>
<ul>
<li class="has-line-data" data-line-start="139" data-line-end="140"><a href="#6411-nim-game">6.4.1.1 Nim Game</a></li>
<li class="has-line-data" data-line-start="140" data-line-end="141"><a href="#6411-composite-games-%E2%80%93-sprague-grundy-theorem-and-nim-value">6.4.1.1 Composite Games – Sprague-Grundy Theorem and Nim Value</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="has-line-data" data-line-start="141" data-line-end="152"><a href="#7-geometry">7. Geometry</a>
<ul>
<li class="has-line-data" data-line-start="142" data-line-end="152"><a href="#71-2-dimension-space">7.1 2-Dimension Space</a>
<ul>
<li class="has-line-data" data-line-start="143" data-line-end="144"><a href="#711-template-of-point">7.1.1 Template of Point</a></li>
<li class="has-line-data" data-line-start="144" data-line-end="145"><a href="#712-%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98-%E5%8F%89%E4%B9%98"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1.2 Vector dot product and cross product</font></font></a></li>
<li class="has-line-data" data-line-start="145" data-line-end="146"><a href="#713-dot-product">7.1.3 dot product</a></li>
<li class="has-line-data" data-line-start="146" data-line-end="147"><a href="#714-cross-product">7.1.4 cross product</a></li>
<li class="has-line-data" data-line-start="147" data-line-end="148"><a href="#715-%E7%9B%B4%E7%BA%BF%E5%85%AC%E5%BC%8F"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1.5 Straight line formula</font></font></a></li>
<li class="has-line-data" data-line-start="148" data-line-end="152"><a href="#716-convex-hull">7.1.6 Convex Hull</a>
<ul>
<li class="has-line-data" data-line-start="149" data-line-end="150"><a href="#gift-wrapping">Gift Wrapping</a></li>
<li class="has-line-data" data-line-start="150" data-line-end="151"><a href="#quickhull">QuickHull</a></li>
<li class="has-line-data" data-line-start="151" data-line-end="152"><a href="#graham-scan">Graham scan</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="has-line-data" data-line-start="152" data-line-end="160"><a href="#8-tricks--miscellaneous">8. Tricks + Miscellaneous</a>
<ul>
<li class="has-line-data" data-line-start="153" data-line-end="154"><a href="#81-bit-manipulation">8.1 Bit Manipulation</a></li>
<li class="has-line-data" data-line-start="154" data-line-end="155"><a href="#81-cantor-expansion--reverse-cantor-expansion">8.1 Cantor Expansion / Reverse Cantor Expansion</a></li>
<li class="has-line-data" data-line-start="155" data-line-end="156"><a href="#82-pass-2-d-array">8.2 pass 2-D array</a></li>
<li class="has-line-data" data-line-start="156" data-line-end="157"><a href="#83-binary-display">8.3 Binary Display</a></li>
<li class="has-line-data" data-line-start="157" data-line-end="158"><a href="#84-fast-log">8.4 Fast Log</a></li>
<li class="has-line-data" data-line-start="158" data-line-end="160"><a href="#85-squre-root">8.5 Squre Root</a></li>
</ul>
</li>
</ul>
<p class="has-line-data" data-line-start="160" data-line-end="161">&lt;!-- END doctoc generated TOC please keep comment here to allow auto update --&gt;</p>
<h2 class="code-line" data-line-start="162" data-line-end="163"><a id="1_Basic_162"></a>1. Basic</h2>
<h3 class="code-line" data-line-start="164" data-line-end="165"><a id="11_C_Solution_Template_164"></a>1.1 C++ Solution Template</h3>
<pre><code class="has-line-data" data-line-start="167" data-line-end="185"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> DEBUG false</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> OJ_DEBUG</span><font></font>
<font></font>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> $(x) {<span class="hljs-keyword">if</span> (DEBUG) {cout &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">": "</span>; {x} cout &lt;&lt; endl;}}</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> _(x) {cout &lt;&lt; #x &lt;&lt; <span class="hljs-string">" = "</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">" "</span>;}</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> E = <span class="hljs-number">1e-8</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> PI = <span class="hljs-built_in">acos</span>(-<span class="hljs-number">1</span>);<font></font>
<font></font>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<font></font>
    ios::sync_with_stdio(<span class="hljs-literal">false</span>);<font></font>
    <font></font>
}<font></font>
</code></pre>
<h4 class="code-line" data-line-start="186" data-line-end="187"><a id="111_Optional_include_list_186"></a>1.1.1 Optional include list</h4>
<blockquote>
<p class="has-line-data" data-line-start="188" data-line-end="189">Use it when there is no <code>bits/stdc++.h</code></p>
</blockquote>
<pre><code class="has-line-data" data-line-start="191" data-line-end="205"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span>
</code></pre>
<h3 class="code-line" data-line-start="206" data-line-end="207"><a id="12_Strings_206"></a>1.2 Strings</h3>
<h4 class="code-line" data-line-start="208" data-line-end="209"><a id="121_C_String_208"></a>1.2.1 C++ String</h4>
<h5 class="code-line" data-line-start="209" data-line-end="210"><a id="Read_a_String_Till_First_Space_209"></a>Read a String Till First Space</h5>
<p class="has-line-data" data-line-start="211" data-line-end="212"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gin</font></font></p>
<pre><code class="has-line-data" data-line-start="214" data-line-end="218"><span class="hljs-built_in">string</span> a;
<span class="hljs-built_in">cin</span>&gt;&gt;a
<span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; endl;
</code></pre>
<p class="has-line-data" data-line-start="219" data-line-end="220">Input</p>
<pre><code class="has-line-data" data-line-start="222" data-line-end="224">Hello World!!!
</code></pre>
<p class="has-line-data" data-line-start="225" data-line-end="226">Output</p>
<pre><code class="has-line-data" data-line-start="228" data-line-end="230">Hello
</code></pre>
<h5 class="code-line" data-line-start="230" data-line-end="231"><a id="Read_One_Line_With_Spaces_till_n_or_EOF_230"></a>Read One Line With Spaces till \n or EOF</h5>
<p class="has-line-data" data-line-start="232" data-line-end="233">getline()</p>
<pre><code class="has-line-data" data-line-start="235" data-line-end="239"><span class="hljs-built_in">string</span> a;<font></font>
getline(<span class="hljs-built_in">cin</span>, a);
<span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; endl;
</code></pre>
<p class="has-line-data" data-line-start="240" data-line-end="241"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Input</font></font></p>
<pre><code class="has-line-data" data-line-start="243" data-line-end="245">Hello World!!!
</code></pre>
<p class="has-line-data" data-line-start="246" data-line-end="247"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Output</font></font></p>
<pre><code class="has-line-data" data-line-start="249" data-line-end="251">Hello World!!!
</code></pre>
<h5 class="code-line" data-line-start="252" data-line-end="253"><a id="Convert_to_char_array_252"></a>Convert to char array</h5>
<pre><code class="has-line-data" data-line-start="255" data-line-end="259"><span class="hljs-built_in">string</span> cppstr = <span class="hljs-string">"this is a string"</span>;
<span class="hljs-keyword">char</span> target[<span class="hljs-number">1024</span>];
<span class="hljs-built_in">strcpy</span>(target, cppstr.c_str());
</code></pre>
<h4 class="code-line" data-line-start="260" data-line-end="261"><a id="122_C_String_Character_Array_260"></a>1.2.2 C String (Character Array)</h4>
<h5 class="code-line" data-line-start="262" data-line-end="263"><a id="Input_C_String_262"></a>Input C String</h5>
<p class="has-line-data" data-line-start="264" data-line-end="265">gets()</p>
<blockquote>
<p class="has-line-data" data-line-start="266" data-line-end="267">Reads characters from the standard input (stdin) and stores them as a C string into str until a newline character or the end-of-file is reached.</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="269" data-line-end="273"><span class="hljs-keyword">char</span> s[<span class="hljs-number">12</span>];<font></font>
gets(s);<font></font>
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\""</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">"\""</span> &lt;&lt; <span class="hljs-string">", length: "</span> &lt;&lt; <span class="hljs-built_in">strlen</span>(s) &lt;&lt; endl;
</code></pre>
<p class="has-line-data" data-line-start="274" data-line-end="275"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Input</font></font></p>
<pre><code class="has-line-data" data-line-start="277" data-line-end="280">hello world<font></font>
new line<font></font>
</code></pre>
<p class="has-line-data" data-line-start="281" data-line-end="282"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Output</font></font></p>
<pre><code class="has-line-data" data-line-start="284" data-line-end="286">"hello world", length: 11
</code></pre>
<h5 class="code-line" data-line-start="287" data-line-end="288"><a id="Convert_to_C_string_287"></a>Convert to C++ string</h5>
<pre><code class="has-line-data" data-line-start="290" data-line-end="293"><span class="hljs-keyword">char</span> arrstr[] = <span class="hljs-string">"this is a string"</span>;
<span class="hljs-built_in">string</span> target = <span class="hljs-built_in">string</span>(arr);
</code></pre>
<h3 class="code-line" data-line-start="294" data-line-end="295"><a id="13_STL_Algorithm_294"></a>1.3 STL Algorithm</h3>
<blockquote>
<p class="has-line-data" data-line-start="296" data-line-end="297">Include the algorithm library if you do not use the solution template.</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="299" data-line-end="301"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
</code></pre>
<h4 class="code-line" data-line-start="302" data-line-end="303"><a id="131_Permutation_302"></a>1.3.1 Permutation</h4>
<p class="has-line-data" data-line-start="304" data-line-end="305">Usage</p>
<pre><code class="has-line-data" data-line-start="306" data-line-end="309"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">next_permutation</span> <span class="hljs-params">(BidirectionalIterator first, BidirectionalIterator last)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">next_permutation</span> <span class="hljs-params">(BidirectionalIterator first, BidirectionalIterator last, Compare comp)</span></span>;
</code></pre>
<p class="has-line-data" data-line-start="310" data-line-end="311">Example</p>
<pre><code class="has-line-data" data-line-start="313" data-line-end="332"><span class="hljs-comment">// next_permutation example</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>     // std::cout</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>    // std::next_permutation, std::sort</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">int</span> myints[] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};<font></font>
<font></font>
  <span class="hljs-built_in">std</span>::sort (myints,myints+<span class="hljs-number">3</span>);<font></font>
<font></font>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The 3! possible permutations with 3 elements:\n"</span>;
  <span class="hljs-keyword">do</span> {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; myints[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; myints[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; myints[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">'\n'</span>;<font></font>
  } <span class="hljs-keyword">while</span> ( <span class="hljs-built_in">std</span>::next_permutation(myints,myints+<span class="hljs-number">3</span>) );<font></font>
<font></font>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"After loop: "</span> &lt;&lt; myints[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; myints[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; myints[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">'\n'</span>;<font></font>
<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre>
<p class="has-line-data" data-line-start="333" data-line-end="334"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Output</font></font></p>
<pre><code class="has-line-data" data-line-start="336" data-line-end="345">The 3! possible permutations with 3 elements:<font></font>
1 2 3<font></font>
1 3 2<font></font>
2 1 3<font></font>
2 3 1<font></font>
3 1 2<font></font>
3 2 1<font></font>
After loop: 1 2 3<font></font>
</code></pre>
<h4 class="code-line" data-line-start="346" data-line-end="347"><a id="132_Binary_Search_346"></a>1.3.2 Binary Search</h4>
<p class="has-line-data" data-line-start="348" data-line-end="349"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usage</font></font></p>
<pre><code class="has-line-data" data-line-start="351" data-line-end="354"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">binary_search</span> <span class="hljs-params">(ForwardIterator first, ForwardIterator last, <span class="hljs-keyword">const</span> T&amp; val, Compare comp)</span></span>;
<span class="hljs-comment">// return true if found, false if not</span>
</code></pre>
<h4 class="code-line" data-line-start="355" data-line-end="356"><a id="133_Lower_Bound_355"></a>1.3.3 Lower Bound</h4>
<blockquote>
<p class="has-line-data" data-line-start="357" data-line-end="358">Returns an iterator pointing to the first element in the range [first,last) which does not compare less than val.</p>
</blockquote>
<p class="has-line-data" data-line-start="359" data-line-end="360">Usage</p>
<pre><code class="has-line-data" data-line-start="362" data-line-end="364"><span class="hljs-function">ForwardIterator <span class="hljs-title">lower_bound</span> <span class="hljs-params">(ForwardIterator first, ForwardIterator last, <span class="hljs-keyword">const</span> T&amp; val, Compare comp)</span></span>;
</code></pre>
<h4 class="code-line" data-line-start="365" data-line-end="366"><a id="134_Swap_365"></a>1.3.4 Swap</h4>
<p class="has-line-data" data-line-start="367" data-line-end="368"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usage</font></font></p>
<pre><code class="has-line-data" data-line-start="370" data-line-end="373"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span> <span class="hljs-params">(T&amp; a, T&amp; b)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">iter_swap</span> <span class="hljs-params">(ForwardIterator1 a, ForwardIterator2 b)</span></span>;
</code></pre>
<p class="has-line-data" data-line-start="374" data-line-end="375"><code>iter_swap</code> example</p>
<pre><code class="has-line-data" data-line-start="377" data-line-end="383"><span class="hljs-keyword">int</span> myints[]={<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span> };              <span class="hljs-comment">//   myints:  10  20  30  40  50</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; myvector (<span class="hljs-number">4</span>,<span class="hljs-number">99</span>);            <span class="hljs-comment">// myvector:  99  99  99  99</span><font></font>
<font></font>
<span class="hljs-built_in">std</span>::iter_swap(myints + <span class="hljs-number">3</span>,myvector.begin() + <span class="hljs-number">2</span>); <span class="hljs-comment">//   myints:  99  20  30 [99] 50</span>
                                             <span class="hljs-comment">// myvector:  10  99 [40] 99</span>
</code></pre>
<h4 class="code-line" data-line-start="384" data-line-end="385"><a id="135_Heap_384"></a>1.3.5 Heap</h4>
<ul>
<li class="has-line-data" data-line-start="386" data-line-end="387">make_heap: Rearranges the elements in the range [first,last) in such a way that they form a heap. The element with the highest value is always pointed by first.</li>
<li class="has-line-data" data-line-start="387" data-line-end="388">pop_heap: Rearranges the elements in the heap range [first,last) in such a way that the part considered a heap is shortened by one: The element with the highest value is moved to (last-1).</li>
<li class="has-line-data" data-line-start="388" data-line-end="389">push_heap: Given a heap in the range [first,last-1), this function extends the range considered a heap to [first,last) by placing the value in (last-1) into its corresponding location within it.</li>
<li class="has-line-data" data-line-start="389" data-line-end="391">sort_heap: Sorts the elements in the heap range [first,last) into ascending order.</li>
</ul>
<p class="has-line-data" data-line-start="391" data-line-end="392"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usage</font></font></p>
<pre><code class="has-line-data" data-line-start="394" data-line-end="399"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">make_heap</span> <span class="hljs-params">(RandomAccessIterator first, RandomAccessIterator last, Compare comp)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop_heap</span> <span class="hljs-params">(RandomAccessIterator first, RandomAccessIterator last, Compare comp)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_heap</span> <span class="hljs-params">(RandomAccessIterator first, RandomAccessIterator last, Compare comp)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort_heap</span> <span class="hljs-params">(RandomAccessIterator first, RandomAccessIterator last)</span></span>; Compare comp);
</code></pre>
<h4 class="code-line" data-line-start="400" data-line-end="401"><a id="136_Sort_400"></a>1.3.6 Sort</h4>
<blockquote>
<p class="has-line-data" data-line-start="402" data-line-end="404">Sorts the elements in the range [first,last) into ascending order.<br>
<code>stable_sort</code> preserves the relative order of the elements with equivalent values.</p>
</blockquote>
<p class="has-line-data" data-line-start="405" data-line-end="406">Usage</p>
<pre><code class="has-line-data" data-line-start="408" data-line-end="411"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span> <span class="hljs-params">(RandomAccessIterator first, RandomAccessIterator last, Compare comp)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stable_sort</span> <span class="hljs-params">( RandomAccessIterator first, RandomAccessIterator last, Compare comp )</span></span>;
</code></pre>
<h4 class="code-line" data-line-start="412" data-line-end="413"><a id="137_Compare_412"></a>1.3.7 Compare</h4>
<h5 class="code-line" data-line-start="414" data-line-end="415"><a id="Using_lambda_expression_414"></a>Using lambda expression</h5>
<pre><code class="has-line-data" data-line-start="417" data-line-end="420"><span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-keyword">const</span> T&amp; a, <span class="hljs-keyword">const</span> T&amp; b) { <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; };
<span class="hljs-built_in">set</span>&lt;T, <span class="hljs-keyword">decltype</span>(cmp)&gt; a_set_with_customized_comparator(cmp);
</code></pre>
<h5 class="code-line" data-line-start="421" data-line-end="422"><a id="Compare_function_421"></a>Compare function</h5>
<blockquote>
<p class="has-line-data" data-line-start="423" data-line-end="424">Binary function that accepts two elements in the range as arguments, and returns a value convertible to bool. It should returns true if the first element is considered to be “smaller” than the second one.</p>
</blockquote>
<p class="has-line-data" data-line-start="425" data-line-end="426">Using by <code>sort</code>, <code>make_heap</code> and etc.</p>
<pre><code class="has-line-data" data-line-start="428" data-line-end="430"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">myfunction</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span> </span>{ <span class="hljs-keyword">return</span> (i&lt;j); }
</code></pre>
<h5 class="code-line" data-line-start="431" data-line-end="432"><a id="Define_operator__431"></a>Define operator &lt;()</h5>
<p class="has-line-data" data-line-start="433" data-line-end="434">Member function</p>
<blockquote>
<p class="has-line-data" data-line-start="434" data-line-end="435">recommended // can use for priority_queue, sort, &lt;ADD MORE HERE&gt;</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="437" data-line-end="444"><span class="hljs-keyword">struct</span> Edge {
   <span class="hljs-keyword">int</span> from, to, weight;
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(Edge that) <span class="hljs-keyword">const</span> {
        <span class="hljs-keyword">return</span> weight &gt; that.weight;<font></font>
    }<font></font>
};<font></font>
</code></pre>
<p class="has-line-data" data-line-start="445" data-line-end="446">verbal version</p>
<pre><code class="has-line-data" data-line-start="448" data-line-end="455"><span class="hljs-keyword">struct</span> Edge {
   <span class="hljs-keyword">int</span> from, to, weight;
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> Edge&amp; that) <span class="hljs-keyword">const</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;weight &gt; that.weight;<font></font>
    }<font></font>
};<font></font>
</code></pre>
<p class="has-line-data" data-line-start="456" data-line-end="457">Non-member function</p>
<pre><code class="has-line-data" data-line-start="459" data-line-end="466"><span class="hljs-keyword">struct</span> Edge {
    <span class="hljs-keyword">int</span> from, to, weight;
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(Edge a, Edge b) {
        <span class="hljs-keyword">return</span> a.weight &gt; b.weight;<font></font>
    }<font></font>
};<font></font>
</code></pre>
<h5 class="code-line" data-line-start="467" data-line-end="468"><a id="Define_operator_467"></a>Define operator()()</h5>
<blockquote>
<p class="has-line-data" data-line-start="469" data-line-end="470">You can use comparison function for STL containers by passing them as the first argument of the constructor, and specifying the function type as the additional template argument. For example:</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="472" data-line-end="474"><span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">bool</span> (*)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; s(cmp);
</code></pre>
<blockquote>
<p class="has-line-data" data-line-start="475" data-line-end="476">A functor, or a function object, is an object that can behave like a function. This is done by defining operator()() of the class. In this case, implement operator()() as a comparison function:</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="478" data-line-end="487"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; occurrences;
<span class="hljs-keyword">struct</span> cmp {
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
        <span class="hljs-keyword">return</span> occurrences[a] &lt; occurrences[b];<font></font>
    }<font></font>
};<font></font>
<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>, cmp&gt; s;<font></font>
priority_queue&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, cmp&gt; pq;
</code></pre>
<p class="has-line-data" data-line-start="488" data-line-end="489">Used by <code>priority_queue</code>.</p>
<h3 class="code-line" data-line-start="490" data-line-end="491"><a id="14_STL_Containers_490"></a>1.4 STL Containers</h3>
<p class="has-line-data" data-line-start="492" data-line-end="493">A container is a holder object that stores a collection of other objects (its elements). They are implemented as class templates, which allows a great flexibility in the types supported as elements.</p>
<h4 class="code-line" data-line-start="494" data-line-end="495"><a id="141_Map_494"></a>1.4.1 Map</h4>
<blockquote>
<p class="has-line-data" data-line-start="496" data-line-end="497">Maps are associative containers that store elements formed by a combination of a key value and a mapped value, following a specific order.</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="499" data-line-end="501"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span>
</code></pre>
<h5 class="code-line" data-line-start="502" data-line-end="503"><a id="Define_a_Map_502"></a>Define a Map</h5>
<pre><code class="has-line-data" data-line-start="505" data-line-end="511"><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> Key,                                     <span class="hljs-comment">// map::key_type</span>
           <span class="hljs-keyword">class</span> T,                                       <span class="hljs-comment">// map::mapped_type</span>
           <span class="hljs-keyword">class</span> Compare = less&lt;Key&gt;,                     <span class="hljs-comment">// map::key_compare</span>
           <span class="hljs-keyword">class</span> Alloc = allocator&lt;pair&lt;<span class="hljs-keyword">const</span> Key,T&gt; &gt;    <span class="hljs-comment">// map::allocator_type</span>
           &gt; <span class="hljs-keyword">class</span> <span class="hljs-built_in">map</span>;
</code></pre>
<h5 class="code-line" data-line-start="512" data-line-end="513"><a id="Commonly_used_method_512"></a>Commonly used method</h5>
<pre><code class="has-line-data" data-line-start="515" data-line-end="530">begin()<font></font>
end()<font></font>
<font></font>
empty()<font></font>
size()<font></font>
<font></font>
operator[] // if not found, insert one<font></font>
<font></font>
insert(pair&lt;first type, second type)<font></font>
erase()<font></font>
clear()<font></font>
<font></font>
find() // if not found, return end()<font></font>
count() // return 1 or 0<font></font>
</code></pre>
<blockquote>
<p class="has-line-data" data-line-start="531" data-line-end="532">TODO add more interface</p>
</blockquote>
<h5 class="code-line" data-line-start="534" data-line-end="535"><a id="Redblack_Tree_534"></a>Red-black Tree</h5>
<p class="has-line-data" data-line-start="536" data-line-end="537">C++ map is implemented as a red-black tree.</p>
<p class="has-line-data" data-line-start="538" data-line-end="539">A red–black tree is a data structure which is a type of self-balancing binary search tree.</p>
<p class="has-line-data" data-line-start="540" data-line-end="541">In addition to the requirements imposed on a binary search tree the following must be satisfied by a red–black tree:</p>
<ol>
<li class="has-line-data" data-line-start="542" data-line-end="543">A node is either red or black.</li>
<li class="has-line-data" data-line-start="543" data-line-end="544">The root is black. (This rule is sometimes omitted. Since the root can always be changed from red to black, but not necessarily vice-versa, this rule has little effect on analysis.)</li>
<li class="has-line-data" data-line-start="544" data-line-end="545">All leaves (NIL) are black. (All leaves are same color as the root.)</li>
<li class="has-line-data" data-line-start="545" data-line-end="546">Every red node must have two black child nodes.</li>
<li class="has-line-data" data-line-start="546" data-line-end="547">Every path from a given node to any of its descendant leaves contains the same number of black nodes.</li>
</ol>
<h5 class="code-line" data-line-start="549" data-line-end="550"><a id="Hash_Map_Unordered_Map_549"></a>Hash Map (Unordered Map)</h5>
<blockquote>
<p class="has-line-data" data-line-start="551" data-line-end="552">Unordered map is implemented as a hash table.</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="554" data-line-end="556"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span>
</code></pre>
<blockquote>
<p class="has-line-data" data-line-start="557" data-line-end="558">Unordered maps are associative containers that store elements formed by the combination of a key value and a mapped value, and which allows for fast retrieval of individual elements based on their keys.</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="560" data-line-end="568"><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> Key,                                    <span class="hljs-comment">// unordered_map::key_type</span>
           <span class="hljs-keyword">class</span> T,                                      <span class="hljs-comment">// unordered_map::mapped_type</span>
           <span class="hljs-keyword">class</span> Hash = hash&lt;Key&gt;,                       <span class="hljs-comment">// unordered_map::hasher</span>
           <span class="hljs-keyword">class</span> Pred = equal_to&lt;Key&gt;,                   <span class="hljs-comment">// unordered_map::key_equal</span>
           <span class="hljs-keyword">class</span> Alloc = allocator&lt; pair&lt;<span class="hljs-keyword">const</span> Key,T&gt; &gt;  <span class="hljs-comment">// unordered_map::allocator_type</span>
           &gt; <span class="hljs-keyword">class</span> <span class="hljs-built_in">unordered_map</span>;<font></font>
<font></font>
</code></pre>
<h5 class="code-line" data-line-start="569" data-line-end="570"><a id="Commonly_used_method_569"></a>Commonly used method</h5>
<pre><code class="has-line-data" data-line-start="572" data-line-end="574"><span class="hljs-comment">// most are similar to map</span>
</code></pre>
<p class="has-line-data" data-line-start="575" data-line-end="576">// TODO add more interface</p>
<h4 class="code-line" data-line-start="577" data-line-end="578"><a id="142_Pair_577"></a>1.4.2 Pair</h4>
<h4 class="code-line" data-line-start="579" data-line-end="580"><a id="143_Vector_579"></a>1.4.3 Vector</h4>
<h5 class="code-line" data-line-start="581" data-line-end="582"><a id="Constructor_581"></a>Constructor</h5>
<pre><code class="has-line-data" data-line-start="584" data-line-end="586"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; second (<span class="hljs-number">4</span>,<span class="hljs-number">100</span>);  <span class="hljs-comment">// four ints with value 100</span>
</code></pre>
<h5 class="code-line" data-line-start="587" data-line-end="588"><a id="Methods_587"></a>Methods</h5>
<ul>
<li class="has-line-data" data-line-start="589" data-line-end="590">begin(), end()</li>
<li class="has-line-data" data-line-start="590" data-line-end="591">front(), back()</li>
<li class="has-line-data" data-line-start="591" data-line-end="592">clear()</li>
<li class="has-line-data" data-line-start="592" data-line-end="593">size()</li>
<li class="has-line-data" data-line-start="593" data-line-end="594">push_back(const value_type&amp; val)</li>
<li class="has-line-data" data-line-start="594" data-line-end="596">pop_back()</li>
</ul>
<h4 class="code-line" data-line-start="596" data-line-end="597"><a id="144_List_596"></a>1.4.4 List</h4>
<blockquote>
<p class="has-line-data" data-line-start="598" data-line-end="599">List containers are implemented as doubly-linked lists.</p>
</blockquote>
<h5 class="code-line" data-line-start="600" data-line-end="601"><a id="Methods_600"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methods</font></font></h5>
<ul>
<li class="has-line-data" data-line-start="602" data-line-end="603"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">begin(), end()</font></font></li>
<li class="has-line-data" data-line-start="603" data-line-end="604"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">front(), back()</font></font></li>
<li class="has-line-data" data-line-start="604" data-line-end="605"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clear()</font></font></li>
<li class="has-line-data" data-line-start="605" data-line-end="606">push_front(const value_type&amp; val)</li>
<li class="has-line-data" data-line-start="606" data-line-end="607"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">push_back(const value_type&amp; val)</font></font></li>
<li class="has-line-data" data-line-start="607" data-line-end="608">pop_front(): remove the first element.</li>
<li class="has-line-data" data-line-start="608" data-line-end="609">pop_back(): remove the last element.</li>
<li class="has-line-data" data-line-start="609" data-line-end="610">remove(const value_type&amp; val): remove all elements of value val.</li>
<li class="has-line-data" data-line-start="610" data-line-end="611">insert(iterator position, const value_type&amp; val)</li>
<li class="has-line-data" data-line-start="611" data-line-end="612"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">size()</font></font></li>
<li class="has-line-data" data-line-start="612" data-line-end="613">reverse()</li>
<li class="has-line-data" data-line-start="613" data-line-end="614">sort(), sort (Compare comp)</li>
<li class="has-line-data" data-line-start="614" data-line-end="615"></li>
<li class="has-line-data" data-line-start="615" data-line-end="616">resize()</li>
<li class="has-line-data" data-line-start="616" data-line-end="618">reserve()</li>
</ul>
<h4 class="code-line" data-line-start="618" data-line-end="619"><a id="145_Queue_618"></a>1.4.5 Queue</h4>
<pre><code class="has-line-data" data-line-start="621" data-line-end="623"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span>
</code></pre>
<p class="has-line-data" data-line-start="623" data-line-end="624"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Constructor</font></font></p>
<pre><code class="has-line-data" data-line-start="625" data-line-end="629"><span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; my_queue;
<span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; my_queue (my_list);
<span class="hljs-comment">// use list&lt;int&gt; as container, copy my_list into my_queue</span>
</code></pre>
<p class="has-line-data" data-line-start="629" data-line-end="630"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methods</font></font></p>
<pre><code class="has-line-data" data-line-start="631" data-line-end="637"><span class="hljs-keyword">void</span> <span class="hljs-built_in">queue</span>::push(<span class="hljs-keyword">const</span> value_type&amp; val);
<span class="hljs-keyword">void</span> <span class="hljs-built_in">queue</span>::pop();
<span class="hljs-keyword">bool</span> <span class="hljs-built_in">queue</span>::empty() <span class="hljs-keyword">const</span>;<font></font>
size_type <span class="hljs-built_in">queue</span>::size() <span class="hljs-keyword">const</span>;<font></font>
const_reference&amp; <span class="hljs-built_in">queue</span>::front() <span class="hljs-keyword">const</span>;
</code></pre>
<h4 class="code-line" data-line-start="638" data-line-end="639"><a id="146_Doubleended_Queue_638"></a>1.4.6 Double-ended Queue</h4>
<pre><code class="has-line-data" data-line-start="641" data-line-end="643"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dequeue&gt;</span></span>
</code></pre>
<h4 class="code-line" data-line-start="644" data-line-end="645"><a id="147_Stack_644"></a>1.4.7 Stack</h4>
<pre><code class="has-line-data" data-line-start="647" data-line-end="649"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span>
</code></pre>
<p class="has-line-data" data-line-start="650" data-line-end="651"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Constructor</font></font></p>
<pre><code class="has-line-data" data-line-start="652" data-line-end="661"><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; my_stack (my_data);
<span class="hljs-comment">// use vector&lt;int&gt; as container, copy my_data into my_stack</span><font></font>
<font></font>
<span class="hljs-keyword">bool</span> <span class="hljs-built_in">stack</span>::empty() <span class="hljs-keyword">const</span>;<font></font>
size_type <span class="hljs-built_in">stack</span>::size() <span class="hljs-keyword">const</span>;<font></font>
const_reference&amp; <span class="hljs-built_in">stack</span>::top() <span class="hljs-keyword">const</span>;
<span class="hljs-keyword">void</span> <span class="hljs-built_in">stack</span>::push (<span class="hljs-keyword">const</span> value_type&amp; val);
<span class="hljs-keyword">void</span> <span class="hljs-built_in">stack</span>::pop();
</code></pre>
<h4 class="code-line" data-line-start="662" data-line-end="663"><a id="148_Priority_Queue_662"></a>1.4.8 Priority Queue</h4>
<pre><code class="has-line-data" data-line-start="665" data-line-end="667"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span>
</code></pre>
<pre><code class="has-line-data" data-line-start="669" data-line-end="680"><span class="hljs-comment">// constructor</span>
priority_queue&lt;<span class="hljs-keyword">int</span>&gt; my_priority_queue;<font></font>
priority_queue&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; two_priority_queue; <span class="hljs-comment">// if use greater&lt;int&gt;, must have vector&lt;int&gt;</span>
priority_queue&lt;My_type, <span class="hljs-built_in">vector</span>&lt;My_type&gt;, Comparator_class&gt; my_priority_queue (my_data.begin(), my_data.end()); <span class="hljs-comment">// use Comparator_class as comparator, use vector&lt;My_type&gt; as container, copy my_data into my_priority_queue</span><font></font>
<font></font>
<span class="hljs-keyword">bool</span> priority_queue::empty() <span class="hljs-keyword">const</span>; <span class="hljs-comment">// return true if empty, false if not</span>
size_type priority_queue::size() <span class="hljs-keyword">const</span>; <span class="hljs-comment">// return size of queue</span>
const_reference priority_queue::top() <span class="hljs-keyword">const</span>; <span class="hljs-comment">// returns a constant reference to the top element</span>
<span class="hljs-keyword">void</span> priority_queue::push(<span class="hljs-keyword">const</span> value_type&amp; val); <span class="hljs-comment">// inserts a new element, initialize to val</span>
<span class="hljs-keyword">void</span> priority_queue::pop(); <span class="hljs-comment">// removes the element on top</span>
</code></pre>
<pre><code class="has-line-data" data-line-start="681" data-line-end="730"><span class="hljs-keyword">struct</span> My_type {
    <span class="hljs-keyword">int</span> weight;
    <span class="hljs-keyword">int</span> other;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> My_class_for_compare {
    <span class="hljs-keyword">public</span>:
        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(My_type a, My_type b)</span> </span>{
            <span class="hljs-keyword">return</span> a.weight &lt; b.weight;<font></font>
        }<font></font>
};<font></font>
<font></font>
<span class="hljs-built_in">vector</span>&lt;My_type&gt; my_vector = {(My_type){<span class="hljs-number">2</span>, <span class="hljs-number">789</span>}, (My_type){<span class="hljs-number">1</span>, <span class="hljs-number">127</span>}, (My_type){<span class="hljs-number">3</span>, <span class="hljs-number">456</span>}};<font></font>
<font></font>
priority_queue&lt;My_type, <span class="hljs-built_in">vector</span>&lt;My_type&gt;, My_class_for_compare&gt; one_priority_queue (my_vector.begin(), my_vector.end());<font></font>
one_priority_queue.push((My_type){<span class="hljs-number">4</span>, <span class="hljs-number">483</span>});
<span class="hljs-keyword">while</span> (one_priority_queue.size() != <span class="hljs-number">0</span>) {<font></font>
    My_type temp = one_priority_queue.top();<font></font>
    one_priority_queue.pop();<font></font>
    SHOW_B(temp.weight, temp.other);<font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; my_int = {<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>};<font></font>
<font></font>
priority_queue&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; two_priority_queue (my_int.begin(), my_int.end());
<span class="hljs-keyword">while</span> (two_priority_queue.size() != <span class="hljs-number">0</span>) {<font></font>
    SHOW_A(two_priority_queue.top());<font></font>
    two_priority_queue.pop();<font></font>
}<font></font>
<font></font>
priority_queue&lt;<span class="hljs-keyword">int</span>&gt; three_priority_queue (my_int.begin(), my_int.end());
<span class="hljs-keyword">while</span> (three_priority_queue.size() != <span class="hljs-number">0</span>) {<font></font>
    SHOW_A(three_priority_queue.top());<font></font>
    three_priority_queue.pop();<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-comment">// output</span>
<span class="hljs-comment">// temp.weight = 4, temp.other = 483</span>
<span class="hljs-comment">// temp.weight = 3, temp.other = 456</span>
<span class="hljs-comment">// temp.weight = 2, temp.other = 789</span>
<span class="hljs-comment">// temp.weight = 1, temp.other = 127</span>
<span class="hljs-comment">// two_priority_queue.top() = 1</span>
<span class="hljs-comment">// two_priority_queue.top() = 2</span>
<span class="hljs-comment">// two_priority_queue.top() = 3</span>
<span class="hljs-comment">// three_priority_queue.top() = 3</span>
<span class="hljs-comment">// three_priority_queue.top() = 2</span>
<span class="hljs-comment">// three_priority_queue.top() = 1</span>
</code></pre>
<h2 class="code-line" data-line-start="731" data-line-end="732"><a id="2_Advanced_Data_Structures_731"></a>2. Advanced Data Structures</h2>
<h3 class="code-line" data-line-start="733" data-line-end="734"><a id="21_Heap_733"></a>2.1 Heap</h3>
<h3 class="code-line" data-line-start="735" data-line-end="736"><a id="22_Tree_735"></a>2.2 Tree</h3>
<h4 class="code-line" data-line-start="737" data-line-end="738"><a id="220_Tree_Traversal_737"></a>2.2.0 Tree Traversal</h4>
<h4 class="code-line" data-line-start="739" data-line-end="740"><a id="221_Pointer_Jumping_739"></a>2.2.1 Pointer Jumping</h4>
<blockquote>
<p class="has-line-data" data-line-start="741" data-line-end="742"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialize: O (Nlog (N))</font></font></p>
<p class="has-line-data" data-line-start="743" data-line-end="744"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Query: O (Nlog (N))</font></font></p>
</blockquote>
<pre><code class="has-line-data" data-line-start="746" data-line-end="786"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MAX_NODE <span class="hljs-number">100030</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MAX_NODE_LOG <span class="hljs-number">20</span></span><font></font>
<font></font>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> TREE_ROOT <span class="hljs-number">0</span></span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; g[MAX_NODE];
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parent_jump[MAX_NODE];
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; path;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_jump</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur = TREE_ROOT)</span> </span>{
    <span class="hljs-keyword">int</span> d = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">int</span> index = path.size() - d;
        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>)
            <span class="hljs-keyword">break</span>;<font></font>
        parent_jump[cur].push_back(path[index]);<font></font>
        d &lt;&lt;= <span class="hljs-number">1</span>;<font></font>
    }<font></font>
    path.push_back(cur);<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g[cur].size(); i++) {
        <span class="hljs-keyword">int</span> nx = g[cur][i];
        <span class="hljs-keyword">if</span> (cur == TREE_ROOT || nx != parent_jump[cur][<span class="hljs-number">0</span>]) {<font></font>
            init_jump(nx);<font></font>
        }<font></font>
    }<font></font>
    path.pop_back();<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">go_up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> dis)</span> </span>{
    <span class="hljs-keyword">int</span> mask = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (mask &lt;= dis) {
        <span class="hljs-keyword">if</span> (dis &amp; mask)<font></font>
            cur = parent_jump[cur][index];<font></font>
        mask &lt;&lt;= <span class="hljs-number">1</span>;<font></font>
        index++;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> cur;<font></font>
}<font></font>
</code></pre>
<h4 class="code-line" data-line-start="787" data-line-end="788"><a id="222_HeavyLight_Decomposition_787"></a>2.2.2 Heavy-Light Decomposition</h4>
<blockquote>
<p class="has-line-data" data-line-start="789" data-line-end="790">Build: O(N)</p>
<p class="has-line-data" data-line-start="791" data-line-end="792">Overhead: O(log(N))</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="794" data-line-end="1200"><span class="hljs-comment">// </span>
<span class="hljs-comment">// CodeForces 593D</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// sol 1 - path must &lt; 64 - not straightforward</span>
<span class="hljs-comment">// sol 2 - Heavy-Light Decomposition + Segment Tree + Math - not straightforward</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// floor( floor(A / B) / C) = floor(A / (B * C))</span>
<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span>
<span class="hljs-comment">// #include &lt;unordered_set&gt;</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span>
<span class="hljs-comment">// #include &lt;unordered_map&gt;</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><font></font>
<font></font>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> SHOW(...) {;}</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> REACH_HERE {;}</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LOG(s, ...) {;}</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LOGLN(s, ...) {;}</span><font></font>
<font></font>
<span class="hljs-comment">// #undef HHHDEBUG</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">ifdef</span> HHHDEBUG</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">"template.h"</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">len</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x)</span> </span>{
    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<font></font>
<font></font>
    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>) {<font></font>
        ret++;<font></font>
        x /= <span class="hljs-number">10</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> ret;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">will_boom</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b)</span> </span>{
    <span class="hljs-keyword">if</span> (a == ULLONG_MAX || b == ULLONG_MAX)
        <span class="hljs-keyword">return</span> ULLONG_MAX;<font></font>
    <font></font>
    <span class="hljs-keyword">int</span> la = len(a);
    <span class="hljs-keyword">int</span> lb = len(b);
    <span class="hljs-keyword">if</span> (la - <span class="hljs-number">1</span> + lb - <span class="hljs-number">1</span> + <span class="hljs-number">1</span> &gt; <span class="hljs-number">20</span>)
        <span class="hljs-keyword">return</span> ULLONG_MAX;
    <span class="hljs-keyword">return</span> a * b;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">struct</span> SegmentTree {
    <span class="hljs-keyword">struct</span> Node {
        <span class="hljs-keyword">int</span> l;
        <span class="hljs-keyword">int</span> r;
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> accu;<font></font>
    };<font></font>
<font></font>
    <span class="hljs-keyword">int</span> r_most;
    <span class="hljs-built_in">vector</span>&lt;Node&gt; node;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rm)</span> </span>{<font></font>
        r_most = rm;<font></font>
<font></font>
        <span class="hljs-keyword">int</span> tree_range = r_most + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (tree_range &lt;= <span class="hljs-number">0</span>)
            <span class="hljs-keyword">return</span> ;<font></font>
<font></font>
        <span class="hljs-keyword">int</span> tree_size = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (tree_size &lt;= tree_range)<font></font>
            tree_size &lt;&lt;= <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (__builtin_popcount(tree_range) != <span class="hljs-number">1</span>) <span class="hljs-comment">// count number of '1' bits</span>
            tree_size &lt;&lt;= <span class="hljs-number">1</span>;<font></font>
<font></font>
        node.resize(tree_size);<font></font>
<font></font>
        Node&amp; root = node[<span class="hljs-number">1</span>];<font></font>
        root.l = <span class="hljs-number">0</span>;<font></font>
        root.r = r_most;<font></font>
        root.accu = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; node.size(); i++) {<font></font>
            Node&amp; cur = node[i];<font></font>
            cur.accu = <span class="hljs-number">1</span>;<font></font>
<font></font>
            <span class="hljs-keyword">const</span> Node&amp; par = node[i / <span class="hljs-number">2</span>];
            <span class="hljs-keyword">if</span> (par.l == par.r)
                <span class="hljs-keyword">continue</span>;
            <span class="hljs-keyword">int</span> m = (par.l + par.r) / <span class="hljs-number">2</span>;
            <span class="hljs-keyword">if</span> (i &amp; <span class="hljs-number">1</span>) {<font></font>
                cur.l = m + <span class="hljs-number">1</span>;<font></font>
                cur.r = par.r;<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span> {<font></font>
                cur.l = par.l;<font></font>
                cur.r = m;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">// SHOW("init")</span>
        <span class="hljs-comment">// show();</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{<font></font>
        SHOW(<span class="hljs-string">"SegmentTree"</span>, r_most)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; node.size(); i++) {<font></font>
            Node&amp; cur = node[i];<font></font>
            SHOW(i, cur.l, cur.r, cur.accu)<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> new_y, <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>)</span> </span>{<font></font>
        Node&amp; cur = node[i];<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (cur.l == cur.r) {<font></font>
            cur.accu = new_y;<font></font>
            <span class="hljs-keyword">return</span> ;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">int</span> m = (cur.l + cur.r) / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">int</span> il = i * <span class="hljs-number">2</span>;
        <span class="hljs-keyword">int</span> ir = il + <span class="hljs-number">1</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (l &lt;= m)<font></font>
            update(l, r, new_y, il);<font></font>
        <span class="hljs-keyword">else</span><font></font>
            update(l, r, new_y, ir);<font></font>
<font></font>
        cur.accu = will_boom(node[il].accu, node[ir].accu);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>)</span> </span>{
        <span class="hljs-keyword">if</span> (l &gt; r)
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<font></font>
<font></font>
        Node&amp; cur = node[i];<font></font>
        <span class="hljs-keyword">if</span> (l &lt;= cur.l &amp;&amp; cur.r &lt;= r)
            <span class="hljs-keyword">return</span> cur.accu;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (r &lt; cur.l || cur.r &lt; l) {<font></font>
            REACH_HERE<font></font>
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">int</span> m = (cur.l + cur.r) / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">int</span> il = i * <span class="hljs-number">2</span>;
        <span class="hljs-keyword">int</span> ir = il + <span class="hljs-number">1</span>;<font></font>
<font></font>
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (l &lt;= m) {
            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> temp_l = query(l, r, il);<font></font>
            ans = will_boom(ans, temp_l);<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-keyword">if</span> (m &lt; r) {
            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> temp_r = query(l, r, ir);<font></font>
            ans = will_boom(ans, temp_r);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> ans;<font></font>
    }<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> Graph {
    <span class="hljs-built_in">map</span>&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;, <span class="hljs-keyword">int</span>&gt; node_edge;<font></font>
<font></font>
    <span class="hljs-keyword">struct</span> Edge {
        <span class="hljs-keyword">int</span> from;
        <span class="hljs-keyword">int</span> to;
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> y;<font></font>
    };<font></font>
<font></font>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAXNODE = <span class="hljs-number">200005</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; g[MAXNODE];
    <span class="hljs-built_in">vector</span>&lt;Edge&gt; edge;
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nn)</span> </span>{<font></font>
        n = nn;<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<font></font>
            g[i].clear();<font></font>
        edge.clear();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_e</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> val_y)</span> </span>{<font></font>
        Edge e1 = {x, y, val_y};<font></font>
        g[x].push_back(edge.size());<font></font>
        node_edge[make_pair(x, y)] = edge.size();<font></font>
        edge.push_back(e1);<font></font>
<font></font>
        Edge e2 = {y, x, val_y};<font></font>
        g[y].push_back(edge.size());<font></font>
        node_edge[make_pair(y, x)] = edge.size();<font></font>
        edge.push_back(e2);<font></font>
<font></font>
        <span class="hljs-comment">// LOGLN("add edge %d - %d = %llu", x, y, val_y);</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">int</span> parent[MAXNODE];
    <span class="hljs-keyword">int</span> size[MAXNODE];
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size_parent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur)</span> </span>{
        <span class="hljs-keyword">int</span>&amp; s = size[cur] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g[cur].size(); i++) {
            <span class="hljs-keyword">int</span> ie = g[cur][i];
            <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie];
            <span class="hljs-keyword">int</span> nx = e.to;
            <span class="hljs-keyword">if</span> (nx != parent[cur]) {<font></font>
                parent[nx] = cur;<font></font>
                s += size_parent(nx);    <font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> s;<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_size_parent</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"node %d: size %d, parent %d\n"</span>, i, size[i], parent[i]);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">struct</span> Chain {
        <span class="hljs-keyword">int</span> head;
        <span class="hljs-keyword">int</span> head_depth;
        <span class="hljs-keyword">int</span> len;<font></font>
    };<font></font>
    <span class="hljs-built_in">vector</span>&lt;Chain&gt; chain;
    <span class="hljs-keyword">int</span> chain_total;
    <span class="hljs-keyword">int</span> chain_no[MAXNODE]; <span class="hljs-comment">// chain_no[node] == chain_index</span>
    <span class="hljs-keyword">int</span> chain_pos[MAXNODE]; <span class="hljs-comment">// chain_pos[node] == x'th node in the chain // 0 based</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hld</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> depth)</span> </span>{
        <span class="hljs-keyword">if</span> (chain_total == chain.size()) {<font></font>
            Chain c = {cur, depth, <span class="hljs-number">0</span>};<font></font>
            chain.push_back(c);<font></font>
        }<font></font>
<font></font>
        chain_no[cur] = chain_total;<font></font>
        chain_pos[cur] = chain[chain_total].len;<font></font>
        chain[chain_total].len++; <span class="hljs-comment">// 0 based, add later</span><font></font>
<font></font>
        <span class="hljs-keyword">if</span> (depth != <span class="hljs-number">0</span> &amp;&amp; g[cur].size() - <span class="hljs-number">1</span> == <span class="hljs-number">0</span>) 
            <span class="hljs-keyword">return</span> ;<font></font>
<font></font>
        <span class="hljs-keyword">int</span> heavy = edge[g[cur][<span class="hljs-number">0</span>]].to;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g[cur].size(); i++) {
            <span class="hljs-keyword">int</span> ie = g[cur][i];
            <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie];
            <span class="hljs-keyword">int</span> nx = e.to;
            <span class="hljs-keyword">if</span> (heavy == parent[cur] || (nx != parent[cur] &amp;&amp; size[nx] &gt; size[heavy]))<font></font>
                heavy = nx;<font></font>
        }<font></font>
<font></font>
        hld(heavy, depth + <span class="hljs-number">1</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g[cur].size(); i++) {
            <span class="hljs-keyword">int</span> ie = g[cur][i];
            <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie];
            <span class="hljs-keyword">int</span> nx = e.to;
            <span class="hljs-keyword">if</span> (nx != parent[cur] &amp;&amp; nx != heavy) {<font></font>
                chain_total++;<font></font>
                hld(nx, depth + <span class="hljs-number">1</span>);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heavy_light_decomposition</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">int</span> root = <span class="hljs-number">1</span>;<font></font>
        parent[root] = -<span class="hljs-number">1</span>;<font></font>
        assert(n == size_parent(root));<font></font>
        <font></font>
        chain_total = <span class="hljs-number">0</span>;<font></font>
        chain.clear();<font></font>
<font></font>
        hld(root, <span class="hljs-number">0</span>);<font></font>
        chain_total++;<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_hld</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"chain_total = %d\n"</span>, chain_total);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= chain_total; i++)
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"chain %d: len %d, head %d, head depth %d\n"</span>, i, chain[i].len, chain[i].head, chain[i].head_depth);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"node %d: chain %d, pos %d\n"</span>, i, chain_no[i], chain_pos[i]);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-built_in">vector</span>&lt;SegmentTree&gt; st;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_sol</span><span class="hljs-params">()</span> </span>{<font></font>
        st.resize(chain_total);<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; st.size(); i++)<font></font>
            st[i].init(chain[i].len - <span class="hljs-number">2</span>);<font></font>
        <font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; edge.size(); i += <span class="hljs-number">2</span>) {
            <span class="hljs-keyword">const</span> Edge&amp; e = edge[i];
            <span class="hljs-keyword">int</span> cn1 = chain_no[e.from];
            <span class="hljs-keyword">int</span> cn2 = chain_no[e.to];<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (cn1 == cn2) {
                <span class="hljs-keyword">int</span> cp1 = chain_pos[e.from];
                <span class="hljs-keyword">int</span> cp2 = chain_pos[e.to];
                <span class="hljs-keyword">if</span> (cp1 &gt; cp2)<font></font>
                    swap(cp1, cp2);<font></font>
                st[cn1].update(cp1, cp2 - <span class="hljs-number">1</span>, e.y);<font></font>
            }<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-comment">// for (int i = 0; i &lt; chain_total; i++)</span>
        <span class="hljs-comment">//  st[i].show();</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c)</span> </span>{<font></font>
        p *= <span class="hljs-number">2</span>;<font></font>
        Edge&amp; e = edge[p];<font></font>
        e.y = edge[p + <span class="hljs-number">1</span>].y = c;<font></font>
<font></font>
        <span class="hljs-keyword">int</span> cn1 = chain_no[e.from];
        <span class="hljs-keyword">int</span> cn2 = chain_no[e.to];
        <span class="hljs-keyword">if</span> (cn1 == cn2) {
            <span class="hljs-keyword">int</span> cp1 = chain_pos[e.from];
            <span class="hljs-keyword">int</span> cp2 = chain_pos[e.to];
            <span class="hljs-keyword">if</span> (cp1 &gt; cp2)<font></font>
                swap(cp1, cp2);<font></font>
            st[cn1].update(cp1, cp2 - <span class="hljs-number">1</span>, c);    <font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> y)</span> </span>{
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> accu = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
            <span class="hljs-keyword">int</span> cn1 = chain_no[a];
            <span class="hljs-keyword">int</span> cn2 = chain_no[b];<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (chain[cn1].head_depth &lt; chain[cn2].head_depth)<font></font>
                swap(a, b), swap(cn1, cn2);<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (cn1 == cn2) {
                <span class="hljs-keyword">int</span> cp1 = chain_pos[a];
                <span class="hljs-keyword">int</span> cp2 = chain_pos[b];
                <span class="hljs-keyword">if</span> (cp1 &gt; cp2)<font></font>
                    swap(cp1, cp2);<font></font>
                <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> temp = st[cn1].query(cp1, cp2 - <span class="hljs-number">1</span>);<font></font>
                accu = will_boom(accu, temp);<font></font>
                <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (a != chain[cn1].head) {
                <span class="hljs-keyword">int</span> ha = chain[cn1].head;
                <span class="hljs-keyword">int</span> cp1 = chain_pos[ha];
                <span class="hljs-keyword">int</span> cp2 = chain_pos[a];
                <span class="hljs-keyword">if</span> (cp1 &gt; cp2)<font></font>
                    swap(cp1, cp2);<font></font>
                <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> temp = st[cn1].query(cp1, cp2 - <span class="hljs-number">1</span>);<font></font>
                accu = will_boom(accu, temp);<font></font>
                a = ha;<font></font>
            }<font></font>
            <font></font>
            <span class="hljs-keyword">int</span> pa = parent[a];
            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> temp = edge[node_edge[make_pair(a, pa)]].y;<font></font>
            accu = will_boom(temp, accu);<font></font>
            a = parent[a];<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (accu == <span class="hljs-number">0</span>) <span class="hljs-comment">// no idea why would be 0</span>
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> y / accu;<font></font>
    }<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">int</span> n;
<span class="hljs-keyword">int</span> m;<font></font>
Graph g;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;n, &amp;m);<font></font>
    g.init(n);<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) {
        <span class="hljs-keyword">int</span> x, y;
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> val_y;
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %llu"</span>, &amp;x, &amp;y, &amp;val_y);<font></font>
        g.add_e(x, y, val_y);<font></font>
    }<font></font>
<font></font>
    g.heavy_light_decomposition();<font></font>
    <span class="hljs-comment">// g.show_hld();</span><font></font>
    g.init_sol(); <font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {
        <span class="hljs-keyword">int</span> op;
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;op);
        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">int</span> a, b;
            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> y;
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %llu"</span>, &amp;a, &amp;b, &amp;y);
            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = g.query(a, b, y);
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%llu\n"</span>, ans);<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">int</span> p;
            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c;
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %llu"</span>, &amp;p, &amp;c);<font></font>
            g.update(p - <span class="hljs-number">1</span>, c);<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre>
<h4 class="code-line" data-line-start="1201" data-line-end="1202"><a id="223_Lowest_Common_Ancestor_1201"></a>2.2.3 Lowest Common Ancestor</h4>
<blockquote>
<p class="has-line-data" data-line-start="1203" data-line-end="1204">Reduction from LCA to RMQ</p>
<p class="has-line-data" data-line-start="1205" data-line-end="1206">let n = number of nodes in the tree</p>
<p class="has-line-data" data-line-start="1207" data-line-end="1208"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">preprocess: euler tour O (n) + RMQ init O (nlog (n))</font></font></p>
<p class="has-line-data" data-line-start="1209" data-line-end="1210"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">query: RMQ O(1)</font></font></p>
<p class="has-line-data" data-line-start="1211" data-line-end="1212"><a href="https://www.topcoder.com/community/data-science/data-science-tutorials/range-minimum-query-and-lowest-common-ancestor/">tutorial</a></p>
</blockquote>
<pre><code class="has-line-data" data-line-start="1214" data-line-end="1402"><span class="hljs-comment">// lowest common ancestor LCA</span>
<span class="hljs-comment">// --&gt; range minimun range_minimum_query</span>
<span class="hljs-comment">// preprocess: O(3 * nlog(n))</span>
<span class="hljs-comment">// range_minimum_query: O(1)</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// 1471. Tree</span>
<span class="hljs-comment">// http://acm.timus.ru/problem.aspx?space=1&amp;num=1471</span>
<span class="hljs-comment">// Time limit: 2.0 second</span>
<span class="hljs-comment">// Memory limit: 64 MB</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// A weighted tree is given. You must find the distance between two given nodes.</span>
<span class="hljs-comment">// Input</span>
<span class="hljs-comment">// The first line contains the number of nodes of the tree n (1 ≤ n ≤ 50000).</span>
<span class="hljs-comment">// The nodes are numbered from 0 to n – 1.</span>
<span class="hljs-comment">// Each of the next n – 1 lines contains three integers u, v, w,</span>
<span class="hljs-comment">// which correspond to an edge with weight w (0 ≤ w ≤ 1000) connecting nodes u and v.</span>
<span class="hljs-comment">// The next line contains the number of queries m (1 ≤ m ≤ 75000).</span>
<span class="hljs-comment">// In each of the next m lines there are two integers.</span>
<span class="hljs-comment">// Output</span>
<span class="hljs-comment">// For each range_minimum_query, output the distance between the nodes with the given numbers.</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// Sample</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// input</span>
<span class="hljs-comment">// 3</span>
<span class="hljs-comment">// 1 0 1</span>
<span class="hljs-comment">// 2 0 1</span>
<span class="hljs-comment">// 3</span>
<span class="hljs-comment">// 0 1</span>
<span class="hljs-comment">// 0 2</span>
<span class="hljs-comment">// 1 2</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// output</span>
<span class="hljs-comment">// 1</span>
<span class="hljs-comment">// 1</span>
<span class="hljs-comment">// 2</span><font></font>
<font></font>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><font></font>
<font></font>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<font></font>
<font></font>
<span class="hljs-keyword">struct</span> Graph {
    <span class="hljs-keyword">struct</span> Edge {
        <span class="hljs-keyword">int</span> to;
        <span class="hljs-keyword">int</span> len;<font></font>
    };<font></font>
<font></font>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAXNODE = <span class="hljs-number">1</span> * <span class="hljs-number">1e5</span> + <span class="hljs-number">2</span>;<font></font>
<font></font>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; g[MAXNODE];
    <span class="hljs-built_in">vector</span>&lt;Edge&gt; edge;
    <span class="hljs-keyword">int</span> n;<font></font>
<font></font>
    <span class="hljs-keyword">int</span> root = <span class="hljs-number">0</span>;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nn, <span class="hljs-keyword">int</span> m=<span class="hljs-number">0</span>)</span> </span>{<font></font>
        n = nn;<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<font></font>
            g[i].clear();<font></font>
        edge.clear();<font></font>
        m *= <span class="hljs-number">2</span>;<font></font>
        edge.reserve(m); <span class="hljs-comment">// may speedup // add_e too slow</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_e</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
        g[x].push_back(edge.size());<font></font>
        edge.push_back((Edge){y, len});<font></font>
<font></font>
        g[y].push_back(edge.size());<font></font>
        edge.push_back((Edge){x, len});<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d:"</span>, i);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie : g[i])
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>, edge[ie].to);
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
        }<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// --- start of LCA ---</span>
    <span class="hljs-comment">// </span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; dis_to_root;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; first_visit_time; <span class="hljs-comment">// max possible number of visits to all nodes == 2 * number of nodes - 1</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; visit;
    <span class="hljs-keyword">int</span> visit_counter;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; rmq;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">range_minimum_query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>{ <span class="hljs-comment">// query [l, r]</span>
        <span class="hljs-keyword">if</span> (l &gt; r)<font></font>
            swap(l, r);<font></font>
<font></font>
        <span class="hljs-keyword">int</span> interval_len = r - l; <span class="hljs-comment">// (r - l + 1) - 1</span><font></font>
<font></font>
        <span class="hljs-keyword">int</span> first_half = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> ((<span class="hljs-number">1</span> &lt;&lt; first_half) &lt;= interval_len)<font></font>
            first_half++;<font></font>
        first_half--;<font></font>
<font></font>
        <span class="hljs-keyword">int</span> second_half = r - (<span class="hljs-number">1</span> &lt;&lt; first_half) + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (first_visit_time[rmq[l][first_half]] &lt; first_visit_time[rmq[second_half][first_half]])
            <span class="hljs-keyword">return</span> rmq[l][first_half];
        <span class="hljs-keyword">return</span> rmq[second_half][first_half];<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
        <span class="hljs-keyword">return</span> range_minimum_query(first_visit_time[x], first_visit_time[y]);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dist</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
        <span class="hljs-keyword">int</span> lca = get_lca(x, y);
        <span class="hljs-keyword">return</span> dis_to_root[x] + dis_to_root[y] - <span class="hljs-number">2</span> * dis_to_root[lca];<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">euler_tour</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur)</span> </span>{<font></font>
        visit[++visit_counter] = cur; <span class="hljs-comment">// v_t[node] = time // needed in case don't have two child</span>
        <span class="hljs-keyword">if</span> (first_visit_time[cur] == <span class="hljs-number">0</span>) <span class="hljs-comment">// if first time</span>
            first_visit_time[cur] = visit_counter; <span class="hljs-comment">// record time f_v_t[node] = time</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie : g[cur]) {
            <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie];
            <span class="hljs-keyword">int</span> nx = e.to;
            <span class="hljs-keyword">int</span> len = e.len;
            <span class="hljs-keyword">if</span> (first_visit_time[nx] == <span class="hljs-number">0</span>) {<font></font>
                dis_to_root[nx] = dis_to_root[cur] + len;<font></font>
                euler_tour(nx);<font></font>
                visit[++visit_counter] = cur; <span class="hljs-comment">// every two child_visit_time have one parent_visit_time inserted between</span><font></font>
            }<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build_lca</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// O(Nlog(N)) </span>
        <span class="hljs-keyword">int</span> one_n = n + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> two_n = <span class="hljs-number">2</span> * one_n;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(one_n, <span class="hljs-number">0</span>).swap(dis_to_root);
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(one_n, <span class="hljs-number">0</span>).swap(first_visit_time);
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(two_n, <span class="hljs-number">0</span>).swap(visit);<font></font>
<font></font>
        <span class="hljs-keyword">int</span> LOG_MAXLENGTH = log2(two_n) + <span class="hljs-number">2</span>;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;(two_n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(LOG_MAXLENGTH)).swap(rmq);<font></font>
<font></font>
        visit_counter = <span class="hljs-number">0</span>;<font></font>
        euler_tour(root);<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; visit_counter; i++)<font></font>
            rmq[i][<span class="hljs-number">0</span>] = visit[i];<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; LOG_MAXLENGTH; j++)
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; visit_counter; i++) {
                <span class="hljs-keyword">if</span> (i + (<span class="hljs-number">1</span> &lt;&lt; j) &gt; visit_counter)
                    <span class="hljs-keyword">break</span>;<font></font>
                rmq[i][j] = rmq[i][j - <span class="hljs-number">1</span>];
                <span class="hljs-keyword">if</span> (first_visit_time[rmq[i][j - <span class="hljs-number">1</span>]] &gt; first_visit_time[rmq[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]])<font></font>
                    rmq[i][j] = rmq[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j-<span class="hljs-number">1</span>];<font></font>
            }<font></font>
    }<font></font>
    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// --- end of LCA ---</span>
    <span class="hljs-comment">// </span><font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">int</span> n, m;<font></font>
Graph g;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])</span> </span>{
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<font></font>
    g.init(n, n);<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) {
        <span class="hljs-keyword">int</span> x, y, d;
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d"</span>, &amp;x, &amp;y, &amp;d);<font></font>
        g.add_e(x, y, d);<font></font>
    }<font></font>
<font></font>
    g.build_lca();<font></font>
<font></font>
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;m);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {
        <span class="hljs-keyword">int</span> x, y;
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;x, &amp;y);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, g.dist(x, y));<font></font>
    }<font></font>
}<font></font>
</code></pre>
<p class="has-line-data" data-line-start="1403" data-line-end="1404">Another implementation, only used by ZXZ.</p>
<pre><code class="has-line-data" data-line-start="1406" data-line-end="1460"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_LOG_N = <span class="hljs-number">21</span>;<font></font>
<font></font>
<span class="hljs-keyword">struct</span> node {
    <span class="hljs-keyword">int</span> baba;
    <span class="hljs-keyword">int</span> k, v;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; children;<font></font>
};<font></font>
<font></font>
node tree[MAX_N];  <span class="hljs-comment">// tree[0] is not used.</span><font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">range_minimun_query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>{
    <span class="hljs-comment">// calculate log(right)</span>
    <span class="hljs-keyword">if</span> (left &gt; right) swap(left, right);
    <span class="hljs-keyword">int</span> log_right = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> ((<span class="hljs-number">1</span> &lt;&lt; log_right) &lt;= right - left) log_right ++;<font></font>
    log_right --;<font></font>
    <span class="hljs-comment">// return the minimum from the lower level RMQ.</span>
    <span class="hljs-keyword">bool</span> is_lower = (first_visit[rmq[left][log_right]] &lt;<font></font>
                     first_visit[rmq[right - (<span class="hljs-number">1</span>&lt;&lt;log_right) + <span class="hljs-number">1</span>][log_right]]);
    <span class="hljs-keyword">return</span> is_lower ? rmq[left][log_right] : rmq[right - (<span class="hljs-number">1</span>&lt;&lt;log_right) + <span class="hljs-number">1</span>][log_right];<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs_rmq</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur)</span> </span>{<font></font>
    visit_count ++;<font></font>
    visit[visit_count] = cur;<font></font>
    <span class="hljs-keyword">if</span> (!first_visit[cur]) first_visit[cur] = visit_count;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tree[cur].children.size(); i++) {
        <span class="hljs-keyword">int</span> child = tree[cur].children[i];
        <span class="hljs-keyword">if</span> (first_visit[child]) <span class="hljs-keyword">continue</span>;<font></font>
        level[child] = level[cur] + <span class="hljs-number">1</span>;<font></font>
        dfs_rmq(child);<font></font>
        visit_count ++;<font></font>
        visit[visit_count] = cur;<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_rmq</span><span class="hljs-params">()</span> </span>{<font></font>
    dfs_rmq(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= visit_count; i++) rmq[i][<span class="hljs-number">0</span>] = visit[i];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> log_level = <span class="hljs-number">1</span>; log_level &lt; MAX_LOG_N; log_level++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= visit_count; i++) {
            <span class="hljs-keyword">if</span> (i + (<span class="hljs-number">1</span>&lt;&lt;log_level) &gt; visit_count) <span class="hljs-keyword">continue</span>;
            <span class="hljs-keyword">if</span> (first_visit[rmq[i][log_level - <span class="hljs-number">1</span>]] &lt;<font></font>
                first_visit[rmq[i + (<span class="hljs-number">1</span>&lt;&lt;(log_level-<span class="hljs-number">1</span>))][log_level-<span class="hljs-number">1</span>]]) {<font></font>
                rmq[i][log_level] = rmq[i][log_level - <span class="hljs-number">1</span>];<font></font>
            } <span class="hljs-keyword">else</span> {<font></font>
                rmq[i][log_level] = rmq[i + (<span class="hljs-number">1</span>&lt;&lt;(log_level-<span class="hljs-number">1</span>))][log_level-<span class="hljs-number">1</span>];<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre>
<h5 class="code-line" data-line-start="1461" data-line-end="1462"><a id="2231_Tarjans_Offline_Algorithm_1461"></a>2.2.3.1 Tarjan’s Off-line Algorithm</h5>
<blockquote>
<p class="has-line-data" data-line-start="1463" data-line-end="1464">let n = number of ndoes of the tree, m = number of query</p>
<p class="has-line-data" data-line-start="1465" data-line-end="1466">O(n + m)</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="1468" data-line-end="1481">function TarjanOLCA(u)<font></font>
     MakeSet(u);<font></font>
     u.ancestor := u;<font></font>
     for each v in u.children do<font></font>
         TarjanOLCA(v);<font></font>
         Union(u,v);<font></font>
         Find(u).ancestor := u;<font></font>
     u.colour := black;<font></font>
     for each v such that {u,v} in P do<font></font>
         if v.colour == black<font></font>
             print "Tarjan's Lowest Common Ancestor of " + u +<font></font>
                   " and " + v + " is " + Find(v).ancestor + ".";<font></font>
</code></pre>
<blockquote>
<p class="has-line-data" data-line-start="1482" data-line-end="1483">TODO refactor add comments</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="1485" data-line-end="1624"><span class="hljs-comment">// </span>
<span class="hljs-comment">// 1471. Tree</span>
<span class="hljs-comment">// http://acm.timus.ru/problem.aspx?space=1&amp;num=1471</span>
<span class="hljs-comment">// Time limit: 2.0 second</span>
<span class="hljs-comment">// Memory limit: 64 MB</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// A weighted tree is given. You must find the distance between two given nodes.</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// Input</span>
<span class="hljs-comment">// The first line contains the number of nodes of the tree n (1 ≤ n ≤ 50000).</span>
<span class="hljs-comment">// The nodes are numbered from 0 to n – 1.</span>
<span class="hljs-comment">// Each of the next n – 1 lines contains three integers u, v, w,</span>
<span class="hljs-comment">// which correspond to an edge with weight w (0 ≤ w ≤ 1000) connecting nodes u and v.</span>
<span class="hljs-comment">// The next line contains the number of queries m (1 ≤ m ≤ 75000).</span>
<span class="hljs-comment">// In each of the next m lines there are two integers.</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// Output</span>
<span class="hljs-comment">// For each range_minimum_query, output the distance between the nodes with the given numbers.</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// Sample</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// input</span>
<span class="hljs-comment">// 3</span>
<span class="hljs-comment">// 1 0 1</span>
<span class="hljs-comment">// 2 0 1</span>
<span class="hljs-comment">// 3</span>
<span class="hljs-comment">// 0 1</span>
<span class="hljs-comment">// 0 2</span>
<span class="hljs-comment">// 1 2</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// output</span>
<span class="hljs-comment">// 1</span>
<span class="hljs-comment">// 1</span>
<span class="hljs-comment">// 2</span><font></font>
 <font></font>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><font></font>
 <font></font>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<font></font>
 <font></font>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MAXHHH <span class="hljs-number">50003</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MAXJJJ <span class="hljs-number">75005</span></span><font></font>
 <font></font>
<span class="hljs-keyword">struct</span> Node {
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; next; <span class="hljs-comment">// edge list</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; dist; <span class="hljs-comment">// edge length</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; query; <span class="hljs-comment">// that node of a query</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; lca; <span class="hljs-comment">// lca of this and that node</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; q_i; <span class="hljs-comment">// index of query in offline query array</span><font></font>
};<font></font>
 <font></font>
Node g[MAXHHH];<font></font>
<span class="hljs-keyword">int</span> n, m;<font></font>
 <font></font>
<span class="hljs-keyword">int</span> father[MAXHHH];
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{ <span class="hljs-comment">// find-union set </span>
    <span class="hljs-keyword">if</span> (father[x] == x)
        <span class="hljs-keyword">return</span> x;
    <span class="hljs-keyword">return</span> father[x] = find(father[x]);<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeFirstInToSecond</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{ <span class="hljs-comment">// find-union set</span><font></font>
    father[find(x)] = find(y);<font></font>
}<font></font>
<font></font>
pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; q[MAXJJJ]; <span class="hljs-comment">// query: node a, b</span>
pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; q_ans[MAXJJJ]; <span class="hljs-comment">// record answer's location, first = node index, second = answer index</span>
<span class="hljs-keyword">int</span> came[MAXHHH];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tarjan_lca_dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur)</span> </span>{
    <span class="hljs-comment">// process cur node and all its sub-tree</span>
    <span class="hljs-comment">// process all query related to this node and nodes in sub-tree</span>
    came[cur] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g[cur].next.size(); i++) {
        <span class="hljs-keyword">int</span> next = g[cur].next[i];
        <span class="hljs-keyword">if</span> (came[next] == <span class="hljs-number">1</span>) <span class="hljs-comment">// don't go back, it is dfs</span>
            <span class="hljs-keyword">continue</span>;<font></font>
 <font></font>
        tarjan_lca_dfs(next); <span class="hljs-comment">// process sub-tree</span>
        mergeFirstInToSecond(cur, next); <span class="hljs-comment">// order matters</span><font></font>
    }<font></font>
 <font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g[cur].query.size(); i++) {
        <span class="hljs-keyword">int</span> that = g[cur].query[i];
        <span class="hljs-keyword">if</span> (came[that] == <span class="hljs-number">0</span>)
            <span class="hljs-keyword">continue</span>;<font></font>
 <font></font>
        <span class="hljs-comment">// lca must be father[that] because this comes from father[that]</span>
        <span class="hljs-comment">// and father[that] haven't merge with father[father[that]]</span><font></font>
        g[cur].lca[i] = find(that);<font></font>
        q_ans[g[cur].q_i[i]] = make_pair(cur, i); <span class="hljs-comment">// record position for later usage</span><font></font>
    }<font></font>
}<font></font>
 <font></font>
<span class="hljs-keyword">int</span> root_dis[MAXHHH];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g[cur].next.size(); i++) {
        <span class="hljs-keyword">int</span> next = g[cur].next[i];
        <span class="hljs-keyword">if</span> (root_dis[next] != -<span class="hljs-number">1</span>)
            <span class="hljs-keyword">continue</span>;<font></font>
 <font></font>
        root_dis[next] = g[cur].dist[i] + root_dis[cur];<font></font>
        dfs(next);<font></font>
    }<font></font>
}<font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])</span> </span>{
    <span class="hljs-built_in">cin</span> &gt;&gt; n;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) {
        <span class="hljs-keyword">int</span> a, b, c;
        <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;<font></font>
        g[a].next.push_back(b);<font></font>
        g[a].dist.push_back(c);<font></font>
        g[b].next.push_back(a);<font></font>
        g[b].dist.push_back(c);<font></font>
        father[i] = i;<font></font>
    }<font></font>
    <span class="hljs-built_in">cin</span> &gt;&gt; m;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) { <span class="hljs-comment">// offline</span>
        <span class="hljs-built_in">cin</span> &gt;&gt; q[i].first &gt;&gt; q[i].second;<font></font>
        g[q[i].first].query.push_back(q[i].second);<font></font>
        g[q[i].first].lca.push_back(-<span class="hljs-number">1</span>);<font></font>
        g[q[i].first].q_i.push_back(i);<font></font>
        g[q[i].second].query.push_back(q[i].first);<font></font>
        g[q[i].second].lca.push_back(-<span class="hljs-number">1</span>);<font></font>
        g[q[i].second].q_i.push_back(i);<font></font>
        q_ans[i] = make_pair(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-built_in">memset</span>(root_dis, -<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(root_dis)); root_dis[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<font></font>
    dfs(<span class="hljs-number">0</span>);<font></font>
    tarjan_lca_dfs(<span class="hljs-number">0</span>);<font></font>
 <font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {
        <span class="hljs-keyword">int</span> lca = g[q_ans[i].first].lca[q_ans[i].second];
        <span class="hljs-keyword">int</span> ans = root_dis[q[i].first] + root_dis[q[i].second] - <span class="hljs-number">2</span> * root_dis[lca];
        <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; endl;<font></font>
    }<font></font>
}<font></font>
</code></pre>
<h4 class="code-line" data-line-start="1625" data-line-end="1626"><a id="224_Centroid_Decomposition_1625"></a>2.2.4 Centroid Decomposition</h4>
<blockquote>
<p class="has-line-data" data-line-start="1627" data-line-end="1628"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O(NlogN)</font></font></p>
</blockquote>
<pre><code class="has-line-data" data-line-start="1630" data-line-end="1799"><span class="hljs-comment">// </span>
<span class="hljs-comment">// https://threads-iiith.quora.com/Centroid-Decomposition-of-a-Tree</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// centroid decomposition O(NlogN)</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// codeforces 342E</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// E. Xenia and Tree</span>
<span class="hljs-comment">// time limit per test5 seconds</span>
<span class="hljs-comment">// memory limit per test256 megabytes</span>
<span class="hljs-comment">// inputstandard input</span>
<span class="hljs-comment">// outputstandard output</span>
<span class="hljs-comment">// Xenia the programmer has a tree consisting of n nodes. </span>
<span class="hljs-comment">// We will consider the tree nodes indexed from 1 to n. </span>
<span class="hljs-comment">// We will also consider the first node to be initially painted red, </span>
<span class="hljs-comment">// and the other nodes — to be painted blue.</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// The distance between two tree nodes v and u is the number of edges in the shortest path between v and u.</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// Xenia needs to learn how to quickly execute queries of two types:</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// paint a specified blue node in red;</span>
<span class="hljs-comment">// calculate which red node is the closest to the given one and print the shortest distance to the closest red node.</span>
<span class="hljs-comment">// Your task is to write a program which will execute the described queries.</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// Input</span>
<span class="hljs-comment">// The first line contains two integers n and m (2&thinsp;≤&thinsp;n&thinsp;≤&thinsp;105,&thinsp;1&thinsp;≤&thinsp;m&thinsp;≤&thinsp;105) — the number of nodes in the tree and the number of queries. </span>
<span class="hljs-comment">// Next n&thinsp;-&thinsp;1 lines contain the tree edges, the i-th line contains a pair of integers ai,&thinsp;bi (1&thinsp;≤&thinsp;ai,&thinsp;bi&thinsp;≤&thinsp;n,&thinsp;ai&thinsp;≠&thinsp;bi) — an edge of the tree.</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// Next m lines contain queries. Each query is specified as a pair of integers ti,&thinsp;vi (1&thinsp;≤&thinsp;ti&thinsp;≤&thinsp;2,&thinsp;1&thinsp;≤&thinsp;vi&thinsp;≤&thinsp;n). </span>
<span class="hljs-comment">// If ti&thinsp;=&thinsp;1, then as a reply to the query we need to paint a blue node vi in red. </span>
<span class="hljs-comment">// If ti&thinsp;=&thinsp;2, then we should reply to the query by printing the shortest distance from some red node to node vi.</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// It is guaranteed that the given graph is a tree and that all queries are correct.</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// Output</span>
<span class="hljs-comment">// For each second type query print the reply in a single line.</span>
<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-keyword">struct</span> Graph {
    <span class="hljs-keyword">struct</span> Edge {
        <span class="hljs-keyword">int</span> to;<font></font>
    };<font></font>
<font></font>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAXNODE = <span class="hljs-number">1</span> * <span class="hljs-number">1e5</span> + <span class="hljs-number">2</span>;<font></font>
<font></font>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; g[MAXNODE];
    <span class="hljs-built_in">vector</span>&lt;Edge&gt; edge;
    <span class="hljs-keyword">int</span> n;<font></font>
<font></font>
    <span class="hljs-keyword">int</span> root = <span class="hljs-number">1</span>;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nn, <span class="hljs-keyword">int</span> m=<span class="hljs-number">0</span>)</span> </span>{<font></font>
        n = nn;<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<font></font>
            g[i].clear();<font></font>
        edge.clear();<font></font>
        m *= <span class="hljs-number">2</span>;<font></font>
        edge.reserve(m); <span class="hljs-comment">// may speedup // add_e too slow</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_e</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{<font></font>
        g[x].push_back(edge.size());<font></font>
        edge.push_back((Edge){y});<font></font>
<font></font>
        g[y].push_back(edge.size());<font></font>
        edge.push_back((Edge){x});<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d:"</span>, i);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie : g[i])
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>, edge[ie].to);
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
        }<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// --- start of centroid decomposition --- </span>
    <span class="hljs-comment">// </span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; centroid; <span class="hljs-comment">// index of upper level centroid node</span><font></font>
<font></font>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; subtree_size;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parent;<font></font>
    <font></font>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; deleted;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compute_subtree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur)</span> </span>{
        <span class="hljs-keyword">int</span>&amp; size = subtree_size[cur];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie : g[cur]) {
            <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie];
            <span class="hljs-keyword">int</span> nx = e.to;
            <span class="hljs-keyword">if</span> (parent[nx] == -<span class="hljs-number">1</span>) {<font></font>
                parent[nx] = cur;<font></font>
                size += compute_subtree(nx);<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> size;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">centroid_decomposite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> from, <span class="hljs-keyword">int</span> tree_size)</span> </span>{ <span class="hljs-comment">// O(Nlog(N)) </span>
        <span class="hljs-keyword">int</span> half_size = tree_size / <span class="hljs-number">2</span>;<font></font>
<font></font>
        <span class="hljs-keyword">while</span> (subtree_size[cur] &lt;= half_size) <span class="hljs-comment">// go up until centroid is in subtree</span><font></font>
            cur = parent[cur];<font></font>
<font></font>
        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
            <span class="hljs-keyword">int</span> candidate = cur;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie : g[cur]) { <span class="hljs-comment">// go down if centroid is in subtree</span>
                <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie];
                <span class="hljs-keyword">int</span> nx = e.to;
                <span class="hljs-keyword">if</span> (!deleted[nx] &amp;&amp; nx != parent[cur]) {
                    <span class="hljs-keyword">if</span> (subtree_size[nx] &gt; half_size) {<font></font>
                        SHOW(cur, nx, subtree_size[nx], candidate)<font></font>
                        candidate = nx;<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span> (candidate == cur)
                <span class="hljs-keyword">break</span>;<font></font>
            cur = candidate;<font></font>
        }<font></font>
<font></font>
        deleted[cur] = <span class="hljs-literal">true</span>;<font></font>
        centroid[cur] = from;<font></font>
<font></font>
        <span class="hljs-keyword">int</span> temp = parent[cur];
        <span class="hljs-keyword">int</span> cur_size = subtree_size[cur];
        <span class="hljs-keyword">while</span> (!deleted[temp] &amp;&amp; temp != parent[temp]) { <span class="hljs-comment">// update all the subtree_size of parent</span><font></font>
            subtree_size[temp] -= cur_size;<font></font>
            temp = parent[temp];<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie : g[cur]) { <span class="hljs-comment">// decomposite parent and children</span>
            <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie];
            <span class="hljs-keyword">int</span> nx = e.to;
            <span class="hljs-keyword">if</span> (!deleted[nx]) {
                <span class="hljs-keyword">int</span> nx_tree_size; <span class="hljs-comment">// size of next level centroid tree</span>
                <span class="hljs-keyword">if</span> (nx == parent[cur])<font></font>
                    nx_tree_size = tree_size - cur_size;<font></font>
                <span class="hljs-keyword">else</span><font></font>
                    nx_tree_size = subtree_size[nx];<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (nx_tree_size == <span class="hljs-number">1</span>)<font></font>
                    centroid[nx] = cur; <span class="hljs-comment">// don't need to go into it</span>
                <span class="hljs-keyword">else</span><font></font>
                    centroid_decomposite(nx, cur, nx_tree_size);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">centroid_decomposite</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>).swap(centroid);
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>).swap(subtree_size); <span class="hljs-comment">// initialized each to be 1 (itself)</span>
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>).swap(parent);
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>).swap(deleted);<font></font>
        <font></font>
        parent[root] = root;<font></font>
        compute_subtree(root);<font></font>
<font></font>
        centroid_decomposite(root, -<span class="hljs-number">1</span>, n);<font></font>
    }<font></font>
    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// --- end of centroid decomposition --- </span>
    <span class="hljs-comment">// </span><font></font>
};<font></font>
</code></pre>
<p class="has-line-data" data-line-start="1800" data-line-end="1801">Key functions</p>
<pre><code class="has-line-data" data-line-start="1803" data-line-end="1867"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs_size</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> from)</span> </span>{
    <span class="hljs-keyword">int</span> total = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> child : tree[cur].children) {
        <span class="hljs-keyword">if</span> (child == from) <span class="hljs-keyword">continue</span>;<font></font>
        total += dfs_size(child, cur);<font></font>
    }<font></font>
    tree[cur].size = total;<font></font>
    <span class="hljs-keyword">return</span> total;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">find_centroid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> from)</span> </span>{
    <span class="hljs-preprocessor">#<span class="hljs-keyword">ifdef</span> DEBUG</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"find centroid for "</span> &lt;&lt; cur &lt;&lt; <span class="hljs-string">" from "</span> &lt;&lt; from &lt;&lt; endl;
    <span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span>
    <span class="hljs-comment">// SHOW(cur)</span>
    <span class="hljs-comment">// finish condition</span>
    <span class="hljs-keyword">if</span> (tree[cur].size == <span class="hljs-number">1</span>) {<font></font>
        tree[cur].c_parent = from;<font></font>
    }<font></font>
    <span class="hljs-comment">// check if current node is centroid.</span>
    <span class="hljs-keyword">int</span> max_child_size = <span class="hljs-number">0</span>, max_child;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> child : tree[cur].children) {
        <span class="hljs-comment">// if (child == from) continue;</span>
        <span class="hljs-keyword">if</span> (tree[child].c_parent != -<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">if</span> (tree[child].size &gt; max_child_size) {<font></font>
            max_child_size = tree[child].size;<font></font>
            max_child = child;<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (max_child_size &gt; tree[cur].size / <span class="hljs-number">2</span>) {
        <span class="hljs-comment">// move root</span><font></font>
        tree[max_child].size = tree[cur].size;<font></font>
        tree[cur].size -= max_child_size;<font></font>
        find_centroid(max_child, from);<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// cur is centroid</span><font></font>
        tree[cur].c_parent = from;<font></font>
        <span class="hljs-keyword">if</span> (from == <span class="hljs-number">0</span>) ctree_root = cur;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> child : tree[cur].children) {
            <span class="hljs-comment">// if (child == from) continue;</span>
            <span class="hljs-keyword">if</span> (tree[child].c_parent != -<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<font></font>
            find_centroid(child, cur);<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">color</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur)</span> </span>{
    <span class="hljs-keyword">int</span> parent = cur;
    <span class="hljs-keyword">while</span> (parent) {<font></font>
        tree[parent].closest = min(tree[parent].closest, distance(cur, parent));<font></font>
        parent = tree[parent].c_parent;<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur)</span> </span>{
    <span class="hljs-keyword">int</span> ans = MAX_N;
    <span class="hljs-keyword">int</span> parent = cur;
    <span class="hljs-keyword">while</span> (parent) {<font></font>
        ans = min(ans, tree[parent].closest + distance(cur, parent));<font></font>
        parent = tree[parent].c_parent;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> ans;<font></font>
}<font></font>
</code></pre>
<h3 class="code-line" data-line-start="1868" data-line-end="1869"><a id="23_Trie__Trie_Graph__AC_Automaton_1868"></a>2.3 Trie / Trie Graph / AC Automaton</h3>
<blockquote>
<p class="has-line-data" data-line-start="1870" data-line-end="1871">O(NL+M) - NL: total len of words in dict, M: len of article</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="1873" data-line-end="2086"><span class="hljs-comment">// </span>
<span class="hljs-comment">// input: n, q, string x n, string x q</span>
<span class="hljs-comment">// output: for each query, print number of string whose prefix is the query</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// Sample Input</span>
<span class="hljs-comment">// 5</span>
<span class="hljs-comment">// babaab</span>
<span class="hljs-comment">// babbbaaaa</span>
<span class="hljs-comment">// abba</span>
<span class="hljs-comment">// aaaaabaa</span>
<span class="hljs-comment">// babaababb</span>
<span class="hljs-comment">// 5</span>
<span class="hljs-comment">// babb</span>
<span class="hljs-comment">// baabaaa</span>
<span class="hljs-comment">// bab</span>
<span class="hljs-comment">// bb</span>
<span class="hljs-comment">// bbabbaab</span>
<span class="hljs-comment">// Sample Output</span>
<span class="hljs-comment">// 1</span>
<span class="hljs-comment">// 0</span>
<span class="hljs-comment">// 3</span>
<span class="hljs-comment">// 0</span>
<span class="hljs-comment">// 0</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// check if any word in dict appear in article</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// Sample Input</span>
<span class="hljs-comment">// 6</span>
<span class="hljs-comment">// aaabc</span>
<span class="hljs-comment">// aaac</span>
<span class="hljs-comment">// abcc</span>
<span class="hljs-comment">// ac</span>
<span class="hljs-comment">// bcd</span>
<span class="hljs-comment">// cd</span>
<span class="hljs-comment">// aaaaaaaaaaabaaadaaac</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// Sample Output</span>
<span class="hljs-comment">// YES</span>
<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<font></font>
<font></font>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> HHH <span class="hljs-number">1000002</span></span>
<span class="hljs-keyword">struct</span> TrieNode<font></font>
{<font></font>
    <span class="hljs-keyword">char</span> val; <span class="hljs-comment">// 'a' ~ 'z'</span>
    <span class="hljs-keyword">bool</span> ended; <span class="hljs-comment">// is a word ended here</span>
    <span class="hljs-keyword">int</span> count; <span class="hljs-comment">// number of word ended here</span>
    <span class="hljs-keyword">int</span> childCount; <span class="hljs-comment">// number of word contianing this prefix</span><font></font>
<font></font>
    <span class="hljs-keyword">int</span> next[<span class="hljs-number">26</span>]; <span class="hljs-comment">// index of child node, 'a' ~ 'z'</span><font></font>
<font></font>
    <span class="hljs-keyword">int</span> prev; <span class="hljs-comment">// parent node // for trie-graph</span>
    <span class="hljs-keyword">bool</span> suffixEnded;<span class="hljs-comment">// suffix node is an end // for trie-graph</span>
    <span class="hljs-keyword">int</span> suffix[<span class="hljs-number">26</span>]; <span class="hljs-comment">// suffix node // for trie-graph</span><font></font>
<font></font>
    TrieNode() {<font></font>
        val = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">memset</span>(next, -<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(next));<font></font>
        ended = <span class="hljs-literal">false</span>;<font></font>
        count = <span class="hljs-number">0</span>;<font></font>
        childCount = <span class="hljs-number">0</span>;<font></font>
<font></font>
        prev = -<span class="hljs-number">1</span>;<font></font>
        suffixEnded = <span class="hljs-literal">false</span>;
        <span class="hljs-built_in">memset</span>(suffix, -<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(suffix));<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">cerr</span> &lt;&lt;
        <span class="hljs-string">"Val: "</span> &lt;&lt; val &lt;&lt;
        <span class="hljs-string">", prev = "</span> &lt;&lt; prev &lt;&lt;
        <span class="hljs-string">", ended = "</span> &lt;&lt; ended &lt;&lt;
        <span class="hljs-string">", count = "</span> &lt;&lt; count &lt;&lt;
        <span class="hljs-string">", childCount = "</span> &lt;&lt; childCount<font></font>
        &lt;&lt; <span class="hljs-string">"\n\t "</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)
            <span class="hljs-built_in">cerr</span> &lt;&lt; (<span class="hljs-keyword">char</span>)(<span class="hljs-string">'a'</span> + i) &lt;&lt; <span class="hljs-string">":"</span> &lt;&lt; next[i] &lt;&lt; <span class="hljs-string">" "</span>;
        <span class="hljs-built_in">cerr</span>
        &lt;&lt; <span class="hljs-string">"\n\tsuffix suffixEnded = "</span> &lt;&lt; suffixEnded &lt;&lt; <span class="hljs-string">"\n"</span>
        &lt;&lt; <span class="hljs-string">"\t "</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)
            <span class="hljs-built_in">cerr</span> &lt;&lt; (<span class="hljs-keyword">char</span>)(<span class="hljs-string">'a'</span> + i) &lt;&lt; <span class="hljs-string">":"</span> &lt;&lt; suffix[i] &lt;&lt; <span class="hljs-string">" "</span>;
        <span class="hljs-built_in">cerr</span> &lt;&lt; endl;<font></font>
    }<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> Trie<font></font>
{<font></font>
    TrieNode node[HHH];<font></font>
    <span class="hljs-keyword">int</span> size; <span class="hljs-comment">// the index of last node</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; s)</span> </span>{ <span class="hljs-comment">// return index of new node</span>
        <span class="hljs-keyword">int</span> preIndex = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) {<font></font>
            TrieNode&amp; pre = node[preIndex];<font></font>
            <span class="hljs-keyword">int</span>&amp; curIndex = pre.next[s[i] - <span class="hljs-string">'a'</span>];
            <span class="hljs-keyword">if</span> (curIndex == -<span class="hljs-number">1</span>) {<font></font>
                size++;<font></font>
                curIndex = size;<font></font>
            }<font></font>
            TrieNode&amp; cur = node[curIndex];<font></font>
            cur.val = s[i];<font></font>
            cur.childCount++;<font></font>
<font></font>
            preIndex = curIndex;<font></font>
        }<font></font>
        node[preIndex].ended = <span class="hljs-literal">true</span>;<font></font>
        node[preIndex].count++;<font></font>
        node[<span class="hljs-number">0</span>].childCount++;
        <span class="hljs-keyword">return</span> preIndex;<font></font>
    };<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildSuffix</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) {
            <span class="hljs-keyword">int</span>&amp; next = node[<span class="hljs-number">0</span>].next[i];
            <span class="hljs-keyword">int</span>&amp; suffix = node[<span class="hljs-number">0</span>].suffix[i];<font></font>
<font></font>
            suffix = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">if</span> (next == -<span class="hljs-number">1</span>)<font></font>
                next = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">else</span> {<font></font>
                q.push(next);<font></font>
                node[next].prev = <span class="hljs-number">0</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">while</span> (q.size()) {
            <span class="hljs-keyword">int</span> cur = q.front(); q.pop();
            <span class="hljs-keyword">int</span> prev = node[cur].prev;
            <span class="hljs-keyword">int</span> prevSuffix = node[prev].suffix[node[cur].val - <span class="hljs-string">'a'</span>];
            <span class="hljs-keyword">if</span> (node[prevSuffix].ended)<font></font>
                node[cur].suffixEnded = <span class="hljs-literal">true</span>;<font></font>
<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) {
                <span class="hljs-keyword">int</span>&amp; next = node[cur].next[i];
                <span class="hljs-keyword">int</span>&amp; suffix = node[cur].suffix[i];<font></font>
<font></font>
                suffix = node[prevSuffix].next[i];<font></font>
                <span class="hljs-keyword">if</span> (next == -<span class="hljs-number">1</span>)<font></font>
                    next = suffix;<font></font>
                <span class="hljs-keyword">else</span> {<font></font>
                    q.push(next);<font></font>
                    node[next].prev = cur;<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; s)</span> </span>{ <span class="hljs-comment">// get index of node</span>
        <span class="hljs-keyword">int</span> preIndex = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length() &amp;&amp; preIndex != -<span class="hljs-number">1</span>; i++)<font></font>
            preIndex = node[preIndex].next[s[i] - <span class="hljs-string">'a'</span>];
        <span class="hljs-keyword">return</span> preIndex;<font></font>
    };<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; s)</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, cur = <span class="hljs-number">0</span>; i &lt; s.length(); i++) {<font></font>
            cur = node[cur].next[s[i] - <span class="hljs-string">'a'</span>];
            <span class="hljs-keyword">if</span> (node[cur].ended || node[cur].suffixEnded)
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    Trie() {<font></font>
        size = <span class="hljs-number">0</span>;<font></font>
    };<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= size; i++) {<font></font>
            show_A(i);<font></font>
            node[i].show();<font></font>
        }<font></font>
    }<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">int</span> n, q;<font></font>
Trie t;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">cin</span> &gt;&gt; n;<font></font>
<font></font>
    <span class="hljs-built_in">string</span> temp;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        <span class="hljs-built_in">cin</span> &gt;&gt; temp;<font></font>
        t.add(temp);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-built_in">cin</span> &gt;&gt; q;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) {
        <span class="hljs-built_in">cin</span> &gt;&gt; temp;
        <span class="hljs-keyword">int</span> index = t.get(temp);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (index == -<span class="hljs-number">1</span>)
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl; <span class="hljs-comment">// not found </span>
        <span class="hljs-keyword">else</span>
            <span class="hljs-built_in">cout</span> &lt;&lt; t.node[index].childCount &lt;&lt; endl; <span class="hljs-comment">// found</span><font></font>
    }<font></font>
    <font></font>
    <font></font>
    <span class="hljs-comment">// check if any word in dict appear in article</span><font></font>
    t.buildSuffix();<font></font>
    <font></font>
    <span class="hljs-built_in">string</span> article; <span class="hljs-built_in">cin</span> &gt;&gt; article;
    <span class="hljs-keyword">if</span> (t.match(article))
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"YES"</span> &lt;&lt; endl;
    <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"NO"</span> &lt;&lt; endl;<font></font>
}<font></font>
</code></pre>
<pre><code class="has-line-data" data-line-start="2088" data-line-end="2184"><span class="hljs-comment">// http://blog.csdn.net/u010700335/article/details/38930175</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">26</span>;<span class="hljs-comment">//26个小写字母或者大写字母，再加上0~9就是72</span>
<span class="hljs-comment">//定义字典树结构体</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> Trie<font></font>
{<font></font>
    <span class="hljs-keyword">bool</span> flag;<span class="hljs-comment">//从根到此是否为一个单词</span>
    Trie *next[maxn];<span class="hljs-comment">//有多少个分支</span><font></font>
}Trie;<font></font>
<span class="hljs-comment">// 声明一个根，不含任何信息</span><font></font>
Trie *root;<font></font>
<span class="hljs-comment">//初始化该根</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trie_init</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> i;<font></font>
    root = <span class="hljs-keyword">new</span> Trie;<font></font>
    root-&gt;flag = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;maxn;i++)<font></font>
        root-&gt;next[i] = <span class="hljs-literal">NULL</span>;<font></font>
}<font></font>
<span class="hljs-comment">// 插入一个字符串</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trie_insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *word)</span>
</span>{
    <span class="hljs-comment">//int i = 0;</span>
    <span class="hljs-comment">//while(word[i] != '\0')</span><font></font>
    Trie *tem = root;<font></font>
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">while</span>(*word != <span class="hljs-string">'\0'</span>)<font></font>
    {<font></font>
       <span class="hljs-comment">// cout &lt;&lt; "root**" &lt;&lt; tem-&gt;next[0];</span>
        <span class="hljs-keyword">if</span>(tem-&gt;next[*word-<span class="hljs-string">'a'</span>] == <span class="hljs-literal">NULL</span>)<span class="hljs-comment">// 为空才建立</span><font></font>
        {<font></font>
            Trie *cur = <span class="hljs-keyword">new</span> Trie;<font></font>
            cur-&gt;flag = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;maxn;i++)<font></font>
                cur-&gt;next[i] = <span class="hljs-literal">NULL</span>;<font></font>
            tem-&gt;next[*word-<span class="hljs-string">'a'</span>] = cur;<font></font>
        }<font></font>
        tem = tem-&gt;next[*word-<span class="hljs-string">'a'</span>];
        <span class="hljs-comment">//cout &lt;&lt; *word &lt;&lt; "**";</span><font></font>
        word++;<font></font>
    }<font></font>
    tem-&gt;flag = <span class="hljs-literal">true</span>;<span class="hljs-comment">//插入一个完整的单词</span><font></font>
}<font></font>
<span class="hljs-comment">// 查找一个字符串</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">trie_search</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *word)</span>
</span>{<font></font>
    Trie *tem = root;<font></font>
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; word[i]!=<span class="hljs-string">'\0'</span>; i++)<font></font>
    {<font></font>
        <span class="hljs-keyword">if</span>(tem==<span class="hljs-literal">NULL</span> || tem-&gt;next[word[i]-<span class="hljs-string">'a'</span>]==<span class="hljs-literal">NULL</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        tem = tem-&gt;next[word[i]-<span class="hljs-string">'a'</span>];<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> tem-&gt;flag;<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trie_del</span><span class="hljs-params">(Trie *cur)</span>
</span>{
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;maxn;i++)<font></font>
    {<font></font>
        <span class="hljs-keyword">if</span>(cur-&gt;next[i] != <span class="hljs-literal">NULL</span>)<font></font>
            trie_del(cur-&gt;next[i]);<font></font>
    }<font></font>
    <span class="hljs-keyword">delete</span> cur;<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> i,n;
    <span class="hljs-keyword">char</span> tmp[<span class="hljs-number">50</span>];<font></font>
    trie_init();<font></font>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"请输入初始化字典树的字符串(字符0结束）："</span> &lt;&lt; endl;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; tmp)<font></font>
    {<font></font>
        <span class="hljs-comment">//cout &lt;&lt; tmp &lt;&lt; endl;</span>
        <span class="hljs-keyword">if</span>(tmp[<span class="hljs-number">0</span>] == <span class="hljs-string">'0'</span> &amp;&amp; tmp[<span class="hljs-number">1</span>] ==<span class="hljs-string">'\0'</span>) <span class="hljs-keyword">break</span>;<font></font>
        trie_insert(tmp);<font></font>
    }<font></font>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"请输入要查找的字符串："</span> &lt;&lt; endl;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; tmp)<font></font>
    {<font></font>
        <span class="hljs-comment">//cout &lt;&lt; tmp &lt;&lt; endl;</span>
        <span class="hljs-keyword">if</span>(tmp[<span class="hljs-number">0</span>] == <span class="hljs-string">'0'</span> &amp;&amp; tmp[<span class="hljs-number">1</span>] ==<span class="hljs-string">'\0'</span>) <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">if</span>(trie_search(tmp))
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"查找成功！再次输入查找，字符0结束查找："</span> &lt;&lt; endl;
        <span class="hljs-keyword">else</span>
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"查找失败！再次输入查找，字符0结束查找："</span> &lt;&lt; endl;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre>
<h3 class="code-line" data-line-start="2185" data-line-end="2186"><a id="24_Suffix_Tree_2185"></a>2.4 Suffix Tree</h3>
<h3 class="code-line" data-line-start="2187" data-line-end="2188"><a id="25_Suffix_Array_2187"></a>2.5 Suffix Array</h3>
<pre><code class="has-line-data" data-line-start="2190" data-line-end="2199"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">cin</span> &gt;&gt; s;<font></font>
    build_suffix_array();<font></font>
    compute_lcp();<font></font>
    longest_repeated_substring();<font></font>
<font></font>
    longest_common_substring(<span class="hljs-string">"GATAGACA"</span>, <span class="hljs-string">"CATA"</span>);<font></font>
}<font></font>
</code></pre>
<h4 class="code-line" data-line-start="2200" data-line-end="2201"><a id="251_Build_Suffix_Array_2200"></a>2.5.1 Build Suffix Array</h4>
<blockquote>
<p class="has-line-data" data-line-start="2202" data-line-end="2203"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (nlog (n))</font></font></p>
<p class="has-line-data" data-line-start="2204" data-line-end="2205">reference: Competitve Programming</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="2207" data-line-end="2317"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><font></font>
<font></font>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<font></font>
<font></font>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> HH <span class="hljs-number">100002</span></span><font></font>
<font></font>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> base_char = <span class="hljs-string">'.'</span>;
<span class="hljs-built_in">string</span> s;
<span class="hljs-keyword">int</span> rank_array[HH];
<span class="hljs-keyword">int</span> rank_array_temp[HH];
<span class="hljs-keyword">int</span> suffix_array[HH];
<span class="hljs-keyword">int</span> suffix_array_temp[HH];
<span class="hljs-keyword">int</span> counter[HH];<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">counting_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>{
    <span class="hljs-built_in">memset</span>(counter, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(counter));<font></font>
<font></font>
    <span class="hljs-keyword">int</span> len = s.length();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
        <span class="hljs-comment">// i will cover all suffix_array[i]</span>
        <span class="hljs-comment">// so i + k will cover all suffix_array[i] + k</span>
        <span class="hljs-comment">// so just use i + k instead of suffix_array[i] for counting</span>
        <span class="hljs-comment">// the order is not important anyway</span>
        <span class="hljs-keyword">int</span> old_rank = i + k &lt; len ? rank_array[i + k] : <span class="hljs-number">0</span>;<font></font>
        counter[old_rank]++;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">int</span> accu = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> largest_possible_value = max(<span class="hljs-number">256</span>, len); <span class="hljs-comment">// initial rank is based on ascii value</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; largest_possible_value; i++) {
        <span class="hljs-comment">// counter[x]: 2, 1, 0, 0, 2, 0</span>
        <span class="hljs-comment">// become    : 0, 2, 3, 3, 3, 5</span>
        <span class="hljs-comment">// which stands for the new rank with that old rank x</span>
        <span class="hljs-comment">// the meaning changes here !!</span>
        <span class="hljs-keyword">int</span> count_temp = counter[i];<font></font>
        counter[i] = accu;<font></font>
        accu += count_temp;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
        <span class="hljs-comment">// for each suffix_array[i]</span>
        <span class="hljs-comment">// get its new rank using its old rank suffix_array[i] + k</span>
        <span class="hljs-comment">// above if i + k &gt;= n, we change it to 0</span>
        <span class="hljs-comment">// the same here</span>
        <span class="hljs-keyword">int</span> old_rank = suffix_array[i] + k &lt; len ? rank_array[suffix_array[i] + k] : <span class="hljs-number">0</span>;
        <span class="hljs-comment">// value of counter[old_rank] is the new rank</span>
        <span class="hljs-comment">// put suffix_array[i] to its new position == new rank</span>
        <span class="hljs-comment">// why ++ ? suppose</span>
        <span class="hljs-comment">// counter[x]: 0, 2, 3, 3, 3, 5</span>
        <span class="hljs-comment">// gradually it become</span>
        <span class="hljs-comment">// counter[x]: 1, 2, 3, 3, 3, 5</span>
        <span class="hljs-comment">// counter[x]: 2, 2, 3, 3, 3, 5</span>
        <span class="hljs-comment">// counter[x]: 2, 3, 3, 3, 3, 5</span>
        <span class="hljs-comment">// ... thus assign each suffix_array[x] distinguished value</span>
        <span class="hljs-comment">// even if there keys are the same</span>
        <span class="hljs-comment">// but relation between different key keeps</span>
        <span class="hljs-comment">// why assign distinguished rank ?</span>
        <span class="hljs-comment">// of course... otherwise multiple suffix_array[i] (different suffix) go to same suffix_array[x]</span>
        <span class="hljs-comment">// the rank of them are still kept in the rank_array[x]</span>
        <span class="hljs-comment">// later will compress the rank </span>
        <span class="hljs-comment">// keeping the order between those with same key</span>
        <span class="hljs-comment">// eventually all the rank will be different</span><font></font>
        suffix_array_temp[counter[old_rank]++] = suffix_array[i];<font></font>
    }<font></font>
    <span class="hljs-built_in">memcpy</span>(suffix_array, suffix_array_temp, <span class="hljs-keyword">sizeof</span>(suffix_array));<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build_suffix_array</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> len = s.length();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<font></font>
        rank_array[i] = s[i] - base_char; <span class="hljs-comment">// initial rank // based on 1st char</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<font></font>
        suffix_array[i] = i; <span class="hljs-comment">// initialize</span><font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; len; k &lt;&lt;= <span class="hljs-number">1</span>) {
        <span class="hljs-comment">// sort based on 2^i portion</span>
        <span class="hljs-comment">// finally all will be sorted</span><font></font>
<font></font>
        <span class="hljs-comment">// [0, i + k) is first part</span>
        <span class="hljs-comment">// [i + k, i + k + k) is second part</span>
        <span class="hljs-comment">// sort second part then first part</span>
        <span class="hljs-comment">// leading to a stable_sort (?)</span>
        <span class="hljs-comment">// use [i + k, i + k + k) as key first</span>
        <span class="hljs-comment">// then use [0, i + k) as key</span><font></font>
        counting_sort(k);<font></font>
        counting_sort(<span class="hljs-number">0</span>);<font></font>
<font></font>
        <span class="hljs-comment">// after spread suffix with same rank into differnt suffix_array[x] slot (consecutive)</span>
        <span class="hljs-comment">// compress the rank_array</span>
        <span class="hljs-comment">// so that suffix with same second part [i + k, i + k + k) (which is the rank...)</span>
        <span class="hljs-comment">// have same rank...</span>
        <span class="hljs-keyword">int</span> rank = <span class="hljs-number">0</span>;<font></font>
        rank_array_temp[suffix_array[<span class="hljs-number">0</span>]] = rank;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) {
            <span class="hljs-keyword">if</span> (rank_array[suffix_array[i - <span class="hljs-number">1</span>]] != rank_array[suffix_array[i]]<font></font>
                ||<font></font>
                rank_array[suffix_array[i] + k] != rank_array[suffix_array[i - <span class="hljs-number">1</span>] + k])<font></font>
                rank++;<font></font>
            rank_array_temp[suffix_array[i]] = rank;<font></font>
        }<font></font>
        <span class="hljs-built_in">memcpy</span>(rank_array, rank_array_temp, <span class="hljs-keyword">sizeof</span>(rank_array));<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"i: "</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">", suffix "</span> &lt;&lt; suffix_array[i] &lt;&lt; <span class="hljs-string">" : "</span> &lt;&lt; s.substr(suffix_array[i], s.length() - suffix_array[i]) &lt;&lt; endl;<font></font>
<font></font>
    <span class="hljs-built_in">cout</span> &lt;&lt; endl;<font></font>
}<font></font>
</code></pre>
<h4 class="code-line" data-line-start="2318" data-line-end="2319"><a id="252_Pattern_Matching_2318"></a>2.5.2 Pattern Matching</h4>
<blockquote>
<p class="has-line-data" data-line-start="2320" data-line-end="2321"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (mlog (n))</font></font></p>
</blockquote>
<pre><code class="has-line-data" data-line-start="2323" data-line-end="2331"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">find_pattern</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; pattern)</span> </span>{
    <span class="hljs-comment">// binary search upper bound &amp; lower bound (?) in the suffix array</span>
    <span class="hljs-comment">// to get a matched range</span>
    <span class="hljs-comment">// let m = pattern.length()</span>
    <span class="hljs-comment">// let n = s.length()</span>
    <span class="hljs-comment">// time complexity: O(mlog(n))</span><font></font>
}<font></font>
</code></pre>
<h4 class="code-line" data-line-start="2332" data-line-end="2333"><a id="253_Longest_Common_Prefix_2332"></a>2.5.3 Longest Common Prefix</h4>
<blockquote>
<p class="has-line-data" data-line-start="2334" data-line-end="2335">length of common prefix between suffix_array[i-1] and suffix_array[i]</p>
<p class="has-line-data" data-line-start="2336" data-line-end="2337">let n = s.length()</p>
<p class="has-line-data" data-line-start="2338" data-line-end="2339"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O(n)</font></font></p>
</blockquote>
<pre><code class="has-line-data" data-line-start="2341" data-line-end="2375">
<span class="hljs-comment">//</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-comment">//</span><font></font>
<font></font>
<span class="hljs-keyword">int</span> longest_common_prefix[HH]; <span class="hljs-comment">// lcp[i] = length of common prefix between sa[i-1] and sa[i]</span>
<span class="hljs-keyword">int</span> phi[HH]; <span class="hljs-comment">// phi[sa[i]] = sa[i-1] // naming ? // useless when built</span>
<span class="hljs-keyword">int</span> permuted_lcp[HH]; <span class="hljs-comment">// useless when built temp for lcp</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">compute_lcp</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// theorem: number of increase/decrese on cur_lcp is O(len)</span>
    <span class="hljs-comment">// so time complexity: O(len) for computing lcp</span>
    <span class="hljs-keyword">int</span> len = s.length();<font></font>
    phi[suffix_array[<span class="hljs-number">0</span>]] = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++)<font></font>
        phi[suffix_array[i]] = suffix_array[i - <span class="hljs-number">1</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, cur_lcp = <span class="hljs-number">0</span>; i &lt; len; i++) {
        <span class="hljs-keyword">if</span> (phi[i] == <span class="hljs-number">0</span>)<font></font>
            permuted_lcp[i] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">while</span> (s[i + cur_lcp] == s[phi[i] + cur_lcp])<font></font>
                cur_lcp++;<font></font>
            permuted_lcp[i] = cur_lcp;<font></font>
            cur_lcp = max(cur_lcp - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<font></font>
        longest_common_prefix[i] = permuted_lcp[suffix_array[i]];<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"i: "</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">", suffix "</span> &lt;&lt; suffix_array[i] &lt;&lt; <span class="hljs-string">" (lcp: "</span> &lt;&lt; longest_common_prefix[i] &lt;&lt; <span class="hljs-string">") : "</span> &lt;&lt; s.substr(suffix_array[i], s.length() - suffix_array[i]) &lt;&lt; endl;
    <span class="hljs-built_in">cout</span> &lt;&lt; endl;<font></font>
}<font></font>
</code></pre>
<h4 class="code-line" data-line-start="2376" data-line-end="2377"><a id="254_Longest_Repeated_Substring_2376"></a>2.5.4 Longest Repeated Substring</h4>
<blockquote>
<p class="has-line-data" data-line-start="2378" data-line-end="2379"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">let n = s.length()</font></font></p>
<p class="has-line-data" data-line-start="2380" data-line-end="2381"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O(n)</font></font></p>
</blockquote>
<pre><code class="has-line-data" data-line-start="2383" data-line-end="2396"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">longest_repeated_substring</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> len = s.length();
    <span class="hljs-keyword">int</span> max_repeated = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> i_max = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
        <span class="hljs-keyword">if</span> (longest_common_prefix[i] &gt; max_repeated) {<font></font>
            max_repeated = longest_common_prefix[i];<font></font>
            i_max = i;<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"longest repeated substring: "</span> &lt;&lt; s.substr(suffix_array[i_max], max_repeated) &lt;&lt; endl;<font></font>
}<font></font>
</code></pre>
<h4 class="code-line" data-line-start="2397" data-line-end="2398"><a id="255_Longest_Common_Substring_2397"></a>2.5.5 Longest Common Substring</h4>
<blockquote>
<p class="has-line-data" data-line-start="2399" data-line-end="2400">string a, b (also applies to multiple strings)</p>
<p class="has-line-data" data-line-start="2401" data-line-end="2402">construct Suffix Array of a.b &amp; find Longest Common Prefix</p>
<p class="has-line-data" data-line-start="2403" data-line-end="2404">let n = max(a.length(), b.length())</p>
<p class="has-line-data" data-line-start="2405" data-line-end="2406"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (nlog (n) + n)</font></font></p>
</blockquote>
<pre><code class="has-line-data" data-line-start="2408" data-line-end="2430"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">longest_common_substring</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; b)</span> </span>{<font></font>
    s = a + base_char + b;<font></font>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"concatenated string: "</span> &lt;&lt; s &lt;&lt; endl;<font></font>
    <font></font>
    build_suffix_array();<font></font>
    compute_lcp();<font></font>
<font></font>
    <span class="hljs-keyword">int</span> len = s.length();
    <span class="hljs-keyword">int</span> max_common = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> i_max = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) {
        <span class="hljs-keyword">int</span> cur_lcp = longest_common_prefix[i];
        <span class="hljs-keyword">if</span> (cur_lcp &gt; max_common) {
            <span class="hljs-keyword">if</span> ((suffix_array[i] &lt; a.length()) ^ (suffix_array[i - <span class="hljs-number">1</span>] &lt; a.length())) {<font></font>
                max_common = cur_lcp;<font></font>
                i_max = i;<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"longest common prefix: "</span> &lt;&lt; s.substr(suffix_array[i_max], max_common) &lt;&lt; endl;<font></font>
}<font></font>
</code></pre>
<h3 class="code-line" data-line-start="2431" data-line-end="2432"><a id="26_Binary_Indexed_Tree_2431"></a>2.6 Binary Indexed Tree</h3>
<blockquote>
<p class="has-line-data" data-line-start="2433" data-line-end="2434">Binary Indexed Tree</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="2435" data-line-end="2436">O(logN) to query and update SUM(a[1]~a[i])</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="2438" data-line-end="2458"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MAX_INDEX nnn</span><font></font>
<font></font>
<span class="hljs-keyword">int</span> tree[MAX_INDEX + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 1 &lt;= I &lt;= MAX_INDEX</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">low_bit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{
    <span class="hljs-keyword">return</span> i &amp; -i;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{
    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (; i &gt; <span class="hljs-number">0</span>; i -= low_bit(i))<font></font>
        ans += tree[i];<font></font>
    <span class="hljs-keyword">return</span> ans;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> value)</span> </span>{
    <span class="hljs-keyword">for</span> (; i &lt;= MAX_INDEX; i += low_bit(i))<font></font>
        tree[i] += value;<font></font>
}<font></font>
</code></pre>
<blockquote>
<p class="has-line-data" data-line-start="2459" data-line-end="2460"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modify interval + query point,</font></font></p>
<p class="has-line-data" data-line-start="2461" data-line-end="2462"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1] Modification operation: add c to all the element values &ZeroWidthSpace;&ZeroWidthSpace;between A[l...r];</font></font></p>
<p class="has-line-data" data-line-start="2463" data-line-end="2464"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2] Sum operation: Find the value of A[x] at this time.</font></font></p>
<p class="has-line-data" data-line-start="2465" data-line-end="2466"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This model needs to set up an auxiliary array B: B[i] represents how much A[1…i] has been added so far</font></font></p>
</blockquote>
<pre><code class="has-line-data" data-line-start="2468" data-line-end="2499"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> INTERVAL_LIMIT <span class="hljs-number">100005</span></span><font></font>
<font></font>
<span class="hljs-keyword">int</span> tree_add_i_n[INTERVAL_LIMIT];<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">low_bit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{
    <span class="hljs-keyword">return</span> i &amp; -i;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span>* tree, <span class="hljs-keyword">int</span> UP_LIMIT)</span> </span>{
    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (; i &gt; <span class="hljs-number">0</span>; i -= low_bit(i))<font></font>
        ans += tree[i];<font></font>
    <span class="hljs-keyword">return</span> ans;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> value, <span class="hljs-keyword">int</span>* tree, <span class="hljs-keyword">int</span> UP_LIMIT)</span> </span>{
    <span class="hljs-keyword">for</span> (; i &lt;= UP_LIMIT; i += low_bit(i))<font></font>
        tree[i] += value;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">memset</span>(tree_add_in, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(tree_add_in));<font></font>
    insert(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, tree_add_in, INTERVAL_LIMIT);<font></font>
    insert(<span class="hljs-number">5</span>, -<span class="hljs-number">1</span>, tree_add_in, INTERVAL_LIMIT);<font></font>
    insert(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, tree_add_in, INTERVAL_LIMIT);<font></font>
    insert(<span class="hljs-number">6</span>, -<span class="hljs-number">2</span>, tree_add_in, INTERVAL_LIMIT);<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">7</span>; i++)<font></font>
        SHOW_B(i, query(i, tree_add_in, INTERVAL_LIMIT));<font></font>
}<font></font>
</code></pre>
<blockquote>
<p class="has-line-data" data-line-start="2500" data-line-end="2501"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modify interval + query interval</font></font></p>
<p class="has-line-data" data-line-start="2502" data-line-end="2503">b[i]: add b[i] to a[i], a[i+1], …, a[n]</p>
<p class="has-line-data" data-line-start="2504" data-line-end="2505">so</p>
<p class="has-line-data" data-line-start="2506" data-line-end="2507">sigma(i): a[1] + a[2] + … + a[i]</p>
<p class="has-line-data" data-line-start="2508" data-line-end="2509">sigma(i) = ib[1] + (i-1)b[2] + … + 2b[i-1] + b[i]</p>
<p class="has-line-data" data-line-start="2510" data-line-end="2511">sigma(i) = (i+1){b[1] + b[2] + … + b[i]} - {b[1] + 2b[2] + … + ib[i]}</p>
<p class="has-line-data" data-line-start="2512" data-line-end="2513">so use one more tree c[i]</p>
<p class="has-line-data" data-line-start="2514" data-line-end="2515"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c [i]: 1b [1] + 2b [2] +… + ib [i]</font></font></p>
</blockquote>
<h3 class="code-line" data-line-start="2516" data-line-end="2517"><a id="27_Segment_Tree_2516"></a>2.7 Segment Tree</h3>
<h4 class="code-line" data-line-start="2518" data-line-end="2519"><a id="270_Range_Update__Range_Query_2518"></a>2.7.0 Range Update + Range Query</h4>
<blockquote>
<p class="has-line-data" data-line-start="2520" data-line-end="2521">with lazy propagation</p>
<p class="has-line-data" data-line-start="2522" data-line-end="2523">build O(N)</p>
<p class="has-line-data" data-line-start="2524" data-line-end="2525"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">query O(log(N))</font></font></p>
<p class="has-line-data" data-line-start="2526" data-line-end="2527">update O(log(N))</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="2529" data-line-end="2814"><span class="hljs-comment">// </span>
<span class="hljs-comment">// CodeForces 243D  Cubes</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// dynamic programming + segment tree + math - O(N*N*log(N)) - not straightforward</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// struct SegmentTree is slow, use with caution</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span>
<span class="hljs-comment">// #include &lt;unordered_set&gt;</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span>
<span class="hljs-comment">// #include &lt;unordered_map&gt;</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><font></font>
<font></font>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> SHOW(...) {;}</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> REACH_HERE {;}</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> PRINT(s, ...) {;}</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> PRINTLN(s, ...) {;}</span><font></font>
<font></font>
<span class="hljs-comment">// #undef HHHDEBUG</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">ifdef</span> HHHDEBUG</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">"template.h"</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<font></font>
<font></font>
<span class="hljs-keyword">struct</span> SegmentTree {
    <span class="hljs-keyword">struct</span> Op { <span class="hljs-comment">// store lazy operation</span>
        <span class="hljs-keyword">int</span> h;<font></font>
    };<font></font>
    <span class="hljs-keyword">struct</span> Node {
        <span class="hljs-keyword">int</span> l; <span class="hljs-comment">// [l, ]</span>
        <span class="hljs-keyword">int</span> r; <span class="hljs-comment">// [, r]</span><font></font>
        <font></font>
        <span class="hljs-keyword">int</span> h; <span class="hljs-comment">// value</span><font></font>
<font></font>
        <span class="hljs-keyword">bool</span> lazy;<font></font>
        Op op;<font></font>
    };<font></font>
    <font></font>
    <span class="hljs-built_in">vector</span>&lt;Node&gt; node;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>{ <span class="hljs-comment">// [l, r]</span>
        <span class="hljs-keyword">int</span> tree_range = r - l + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (tree_range &lt;= <span class="hljs-number">0</span>)
            <span class="hljs-keyword">return</span> ;<font></font>
<font></font>
        <span class="hljs-keyword">int</span> tree_size = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (tree_size &lt;= tree_range)<font></font>
            tree_size &lt;&lt;= <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (__builtin_popcount(tree_range) != <span class="hljs-number">1</span>) <span class="hljs-comment">// count number of '1' bits</span>
            tree_size &lt;&lt;= <span class="hljs-number">1</span>;<font></font>
<font></font>
        node.resize(tree_size); <span class="hljs-comment">// (tree_range, tree_size): (001001, 100000) (001000, 010000)</span><font></font>
<font></font>
        Node&amp; root = node[<span class="hljs-number">1</span>];<font></font>
        root.l = l, root.r = r;<font></font>
        root.h = root.op.h = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; node.size(); i++) {<font></font>
            Node&amp; cur = node[i];<font></font>
            cur.h = <span class="hljs-number">0</span>;<font></font>
<font></font>
            <span class="hljs-keyword">const</span> Node&amp; par = node[i / <span class="hljs-number">2</span>]; <span class="hljs-comment">// parent node</span>
            <span class="hljs-keyword">if</span> (par.l == par.r) <span class="hljs-comment">// if parent is end node, skip</span>
                cur.l = cur.r = -<span class="hljs-number">1</span>;
            <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">int</span> m = (par.l + par.r) / <span class="hljs-number">2</span>;
                <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>)<font></font>
                    cur.l = m + <span class="hljs-number">1</span>, cur.r = par.r;
                <span class="hljs-keyword">else</span><font></font>
                    cur.l = par.l, cur.r = m;<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{<font></font>
        SHOW(<span class="hljs-string">"SegmentTree NAME"</span>)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; node.size(); i++) {<font></font>
            Node&amp; cur = node[i];<font></font>
            <span class="hljs-keyword">if</span> (cur.l == -<span class="hljs-number">1</span> &amp;&amp; cur.r == -<span class="hljs-number">1</span>)
                <span class="hljs-keyword">continue</span>;<font></font>
            PRINTLN(<span class="hljs-string">"(%2d) [%2d,%2d] val: %d"</span>, i, cur.l, cur.r, cur.internal)<font></font>
        }<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> xl, <span class="hljs-keyword">int</span> xr, <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>)</span> </span>{ <span class="hljs-comment">// query [xl, xr]</span><font></font>
        Node&amp; cur = node[i];<font></font>
        <span class="hljs-keyword">if</span> (cur.l == cur.r) <span class="hljs-comment">// if end node</span>
            <span class="hljs-keyword">return</span> cur.h;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (xl &lt;= cur.l &amp;&amp; cur.r &lt;= xr) <span class="hljs-comment">// if query cover the node</span>
            <span class="hljs-keyword">return</span> cur.h;<font></font>
<font></font>
        <span class="hljs-keyword">int</span> lci = i * <span class="hljs-number">2</span>;
        <span class="hljs-keyword">const</span> Node&amp; lc = node[lci];
        <span class="hljs-keyword">int</span> rci = lci + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">const</span> Node&amp; rc = node[rci];
        <span class="hljs-keyword">if</span> (cur.lazy) { <span class="hljs-comment">// if have lazy operation, push down</span><font></font>
            update(lc.l, lc.r, cur.op.h, lci);<font></font>
            update(rc.l, rc.r, cur.op.h, rci);<font></font>
            cur.lazy = <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">int</span> ret = INT_MAX;
        <span class="hljs-keyword">if</span> (xl &lt;= lc.r) { <span class="hljs-comment">// if query cover left child</span>
            <span class="hljs-keyword">int</span> temp = query(xl, xr, lci);
            <span class="hljs-keyword">if</span> (ret &gt; temp)<font></font>
                ret = temp;<font></font>
        }<font></font>
        <span class="hljs-keyword">if</span> (rc.l &lt;= xr) { <span class="hljs-comment">// if query cover right child</span>
            <span class="hljs-keyword">int</span> temp = query(xl, xr, rci);
            <span class="hljs-keyword">if</span> (ret &gt; temp)<font></font>
                ret = temp;<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> ret;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> xl, <span class="hljs-keyword">int</span> xr, <span class="hljs-keyword">int</span> xh, <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>)</span> </span>{ <span class="hljs-comment">// update [xl, xr] value xh</span><font></font>
        Node&amp; cur = node[i];<font></font>
        <span class="hljs-keyword">if</span> (cur.l == cur.r) { <span class="hljs-comment">// if end node</span>
            <span class="hljs-keyword">if</span> (cur.h &lt; xh)<font></font>
                cur.h = xh;<font></font>
            <span class="hljs-keyword">return</span> ;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (xl &lt;= cur.l &amp;&amp; cur.r &lt;= xr) { <span class="hljs-comment">// if query cover the node</span>
            <span class="hljs-keyword">if</span> (cur.h &lt; xh) { <span class="hljs-comment">// update node value </span><font></font>
                cur.h = xh;<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span> (cur.lazy) { <span class="hljs-comment">// update the lazy operation // slow if push down now</span>
                <span class="hljs-keyword">if</span> (cur.op.h &lt; xh)<font></font>
                    cur.op.h = xh;<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span> { <span class="hljs-comment">// store lazy operation</span><font></font>
                cur.op.h = xh;<font></font>
                cur.lazy = <span class="hljs-literal">true</span>;<font></font>
            }<font></font>
            <span class="hljs-keyword">return</span> ;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">int</span> lci = i * <span class="hljs-number">2</span>;
        <span class="hljs-keyword">const</span> Node&amp; lc = node[lci];
        <span class="hljs-keyword">int</span> rci = lci + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">const</span> Node&amp; rc = node[rci];
        <span class="hljs-keyword">if</span> (cur.lazy) { <span class="hljs-comment">// if have lazy operation, push down</span><font></font>
            update(lc.l, lc.r, cur.op.h, lci);<font></font>
            update(rc.l, rc.r, cur.op.h, rci);<font></font>
            cur.lazy = <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (xl &lt;= lc.r) <span class="hljs-comment">// if update cover left node</span><font></font>
            update(xl, xr, xh, lci);<font></font>
        <span class="hljs-keyword">if</span> (rc.l &lt;= xr) <span class="hljs-comment">// if update cover right node</span><font></font>
            update(xl, xr, xh, rci);<font></font>
<font></font>
        cur.h = min(lc.h, rc.h); <span class="hljs-comment">// reduce two children </span><font></font>
    }<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> Hall {
    <span class="hljs-keyword">int</span> h;
    <span class="hljs-keyword">int</span> proj_index[<span class="hljs-number">2</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> HH = <span class="hljs-number">1002</span>;<font></font>
<font></font>
<span class="hljs-keyword">int</span> n;
<span class="hljs-keyword">int</span> vx;
<span class="hljs-keyword">int</span> vy;<font></font>
Hall hall[HH][HH];<font></font>
<font></font>
<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">init_project</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> xx[] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>};
    <span class="hljs-keyword">int</span> yy[] = {<span class="hljs-number">1</span>, <span class="hljs-number">0</span>};
    <span class="hljs-keyword">double</span> EPS = <span class="hljs-number">1e-7</span>;<font></font>
<font></font>
    <span class="hljs-keyword">struct</span> Proj {
        <span class="hljs-keyword">int</span> i;
        <span class="hljs-keyword">int</span> j;
        <span class="hljs-keyword">double</span> x;
        <span class="hljs-keyword">int</span> k;<font></font>
    };<font></font>
    <span class="hljs-built_in">vector</span>&lt;Proj&gt; projection;<font></font>
    projection.reserve(n * n * <span class="hljs-number">2</span>);<font></font>
<font></font>
    <span class="hljs-keyword">auto</span> get_x = [](<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y) -&gt; <span class="hljs-keyword">double</span> {
        <span class="hljs-keyword">return</span> vx == <span class="hljs-number">0</span> ? x : x - y / vy * vx;<font></font>
    };<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">2</span>; k++)<font></font>
                projection.push_back((Proj){i, j, get_x(i + xx[k], j + yy[k]), k});<font></font>
<font></font>
    sort(begin(projection), end(projection), [](<span class="hljs-keyword">const</span> Proj&amp; a, <span class="hljs-keyword">const</span> Proj&amp; b) {
        <span class="hljs-keyword">return</span> a.x &lt; b.x;<font></font>
    });<font></font>
<font></font>
    <span class="hljs-keyword">int</span> n_seg = <span class="hljs-number">0</span>;<font></font>
    hall[projection[<span class="hljs-number">0</span>].i][projection[<span class="hljs-number">0</span>].j].proj_index[projection[<span class="hljs-number">0</span>].k] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; projection.size(); i++) {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(projection[i].x - projection[i - <span class="hljs-number">1</span>].x) &gt; EPS)<font></font>
            n_seg++;<font></font>
        hall[projection[i].i][projection[i].j].proj_index[projection[i].k] = n_seg;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> n_seg;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// if vy &lt; 0</span>
    <span class="hljs-comment">// flip left right</span>
    <span class="hljs-keyword">if</span> (vy &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
            <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">int</span> r = n - <span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span> (l &lt; r) {<font></font>
                swap(hall[i][l].h, hall[i][r].h);<font></font>
                l++;<font></font>
                r--;<font></font>
            }<font></font>
        }<font></font>
        vy = -vy;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// if vx &lt;= 0</span>
    <span class="hljs-comment">// flip diagonal</span>
    <span class="hljs-keyword">if</span> (vx &lt; <span class="hljs-number">0</span> || vy == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)<font></font>
                swap(hall[i][j].h, hall[j][i].h);<font></font>
        swap(vx, vy);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// if vy &lt; 0</span>
    <span class="hljs-comment">// flip left right</span>
    <span class="hljs-keyword">if</span> (vy &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
            <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">int</span> r = n - <span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span> (l &lt; r) {<font></font>
                swap(hall[i][l].h, hall[i][r].h);<font></font>
                l++;<font></font>
                r--;<font></font>
            }<font></font>
        }<font></font>
        vy = -vy;<font></font>
    }<font></font>
}<font></font>
<font></font>
SegmentTree st;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d"</span>, &amp;n, &amp;vx, &amp;vy);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;hall[i][j].h);<font></font>
<font></font>
    rotate();<font></font>
    <span class="hljs-keyword">int</span> len = init_project();<font></font>
<font></font>
    st.init(<span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
            <span class="hljs-keyword">const</span> Hall&amp; h = hall[i][j];
            <span class="hljs-keyword">int</span> min_height = st.query(h.proj_index[<span class="hljs-number">0</span>], h.proj_index[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>);<font></font>
            ans += max(<span class="hljs-number">0</span>, h.h - min_height);<font></font>
            st.update(h.proj_index[<span class="hljs-number">0</span>], h.proj_index[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>, h.h);<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>, ans);<font></font>
}<font></font>
</code></pre>
<h4 class="code-line" data-line-start="2815" data-line-end="2816"><a id="271_Color_2815"></a>2.7.1 Color</h4>
<pre><code class="has-line-data" data-line-start="2818" data-line-end="2921"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">100000</span>;<font></font>
<font></font>
<span class="hljs-keyword">struct</span> node {
    <span class="hljs-keyword">int</span> left, right;
    <span class="hljs-keyword">int</span> color;
    <span class="hljs-keyword">bool</span> cover;<font></font>
};<font></font>
<font></font>
node nodes[<span class="hljs-number">3</span>*MAX];<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build_tree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> u)</span> </span>{<font></font>
    nodes[u].left = left;<font></font>
    nodes[u].right = right;<font></font>
    nodes[u].color = <span class="hljs-number">1</span>;<font></font>
    nodes[u].cover = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> (left == right) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">int</span> mid = (left + right)/<span class="hljs-number">2</span>;<font></font>
    build_tree(left, mid, <span class="hljs-number">2</span>*u);<font></font>
    build_tree(mid+<span class="hljs-number">1</span>, right, <span class="hljs-number">2</span>*u + <span class="hljs-number">1</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>{
    <span class="hljs-keyword">int</span> value = nodes[u].color;<font></font>
    nodes[u].cover = <span class="hljs-literal">false</span>;<font></font>
    nodes[<span class="hljs-number">2</span>*u].color = value;<font></font>
    nodes[<span class="hljs-number">2</span>*u].cover = <span class="hljs-literal">true</span>;<font></font>
    nodes[<span class="hljs-number">2</span>*u + <span class="hljs-number">1</span>].color = value;<font></font>
    nodes[<span class="hljs-number">2</span>*u + <span class="hljs-number">1</span>].cover = <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> value, <span class="hljs-keyword">int</span> u)</span> </span>{
    <span class="hljs-keyword">if</span> (left &lt;= nodes[u].left &amp;&amp; nodes[u].right &lt;= right) {<font></font>
        nodes[u].color = value;<font></font>
        nodes[u].cover = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (nodes[u].color == value) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// optimize purpose</span>
    <span class="hljs-comment">//SHOW(u);</span>
    <span class="hljs-keyword">if</span> (nodes[u].cover) get_down(u);
    <span class="hljs-keyword">if</span> (left &lt;= nodes[<span class="hljs-number">2</span>*u].right) {<font></font>
        update(left, right, value, <span class="hljs-number">2</span>*u);<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (right &gt;= nodes[<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>].left) {<font></font>
        update(left, right, value, <span class="hljs-number">2</span>*u + <span class="hljs-number">1</span>);<font></font>
    }<font></font>
    nodes[u].color = nodes[<span class="hljs-number">2</span>*u].color | nodes[<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>].color;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> &amp;sum, <span class="hljs-keyword">int</span> u)</span> </span>{
    <span class="hljs-keyword">if</span> (nodes[u].cover) {<font></font>
        sum |= nodes[u].color;<font></font>
        <span class="hljs-keyword">return</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (left &lt;= nodes[u].left &amp;&amp; nodes[u].right &lt;= right) {<font></font>
        sum |= nodes[u].color;<font></font>
        <span class="hljs-keyword">return</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (left &lt;= nodes[<span class="hljs-number">2</span>*u].right) {<font></font>
        query(left, right, sum, <span class="hljs-number">2</span>*u);<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (right &gt;= nodes[<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>].left) {<font></font>
        query(left, right, sum, <span class="hljs-number">2</span>*u + <span class="hljs-number">1</span>);<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Usage</span>
<span class="hljs-comment">// build_tree(1, L, 1);</span>
<span class="hljs-comment">// update(a, b, new_color, 1);</span>
<span class="hljs-comment">// query(a, b, sum_as_reference, 1);</span><font></font>
<font></font>
<span class="hljs-comment">// only for this question</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bit_count</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sum)</span> </span>{
    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (sum) {
        <span class="hljs-keyword">if</span> (sum%<span class="hljs-number">2</span>) ans++;<font></font>
        sum = sum &gt;&gt; <span class="hljs-number">1</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> ans;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> L, T, O;
    <span class="hljs-built_in">cin</span> &gt;&gt; L &gt;&gt; T &gt;&gt; O;<font></font>
    build_tree(<span class="hljs-number">1</span>, L, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">while</span> (O--) {
        <span class="hljs-keyword">char</span> op;
        <span class="hljs-keyword">int</span> a, b, c;
        <span class="hljs-built_in">cin</span> &gt;&gt; op;
        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">'C'</span>) {
            <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;
            <span class="hljs-keyword">if</span> (a &gt; b) swap(a, b);<font></font>
            update(a, b, <span class="hljs-number">1</span>&lt;&lt;(c-<span class="hljs-number">1</span>), <span class="hljs-number">1</span>);<font></font>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b;
            <span class="hljs-keyword">if</span> (a &gt; b) swap(a, b);
            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<font></font>
            query(a, b, sum, <span class="hljs-number">1</span>);
            <span class="hljs-built_in">cout</span> &lt;&lt; bit_count(sum) &lt;&lt; endl;<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre>
<h4 class="code-line" data-line-start="2922" data-line-end="2923"><a id="272_Range_Sum__Range_Replace_2922"></a>2.7.2 Range Sum + Range Replace</h4>
<pre><code class="has-line-data" data-line-start="2925" data-line-end="2997"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">30005</span>;<font></font>
<font></font>
<span class="hljs-keyword">struct</span> node {
    <span class="hljs-keyword">int</span> left, right;
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum;
    <span class="hljs-keyword">int</span> lazy;
    <span class="hljs-keyword">bool</span> dirty;<font></font>
};<font></font>
<font></font>
node nodes[<span class="hljs-number">4</span>*MAX];<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build_tree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> u)</span> </span>{<font></font>
    nodes[u].left = left;<font></font>
    nodes[u].right = right;<font></font>
    nodes[u].sum = <span class="hljs-number">0</span>;<font></font>
    nodes[u].lazy = <span class="hljs-number">0</span>;<font></font>
    nodes[u].dirty = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (left == right) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">int</span> mid = (left + right)/<span class="hljs-number">2</span>;<font></font>
    build_tree(left, mid, <span class="hljs-number">2</span>*u);<font></font>
    build_tree(mid+<span class="hljs-number">1</span>, right, <span class="hljs-number">2</span>*u + <span class="hljs-number">1</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>{
    <span class="hljs-keyword">if</span> (!nodes[u].dirty) <span class="hljs-keyword">return</span>;<font></font>
    nodes[<span class="hljs-number">2</span>*u].sum = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>) nodes[u].lazy * (nodes[<span class="hljs-number">2</span>*u].right - nodes[<span class="hljs-number">2</span>*u].left + <span class="hljs-number">1</span>);
    <span class="hljs-comment">// if update not replace use +=</span>
    nodes[<span class="hljs-number">2</span>*u].lazy = nodes[u].lazy;<font></font>
    nodes[<span class="hljs-number">2</span>*u].dirty = <span class="hljs-literal">true</span>;<font></font>
    nodes[<span class="hljs-number">2</span>*u + <span class="hljs-number">1</span>].sum = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>) nodes[u].lazy * (nodes[<span class="hljs-number">2</span>*u + <span class="hljs-number">1</span>].right - nodes[<span class="hljs-number">2</span>*u + <span class="hljs-number">1</span>].left + <span class="hljs-number">1</span>);<font></font>
    nodes[<span class="hljs-number">2</span>*u + <span class="hljs-number">1</span>].lazy = nodes[u].lazy;<font></font>
    nodes[<span class="hljs-number">2</span>*u + <span class="hljs-number">1</span>].dirty = <span class="hljs-literal">true</span>;<font></font>
    nodes[u].dirty = <span class="hljs-literal">false</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> value, <span class="hljs-keyword">int</span> u)</span> </span>{
    <span class="hljs-keyword">if</span> (left &lt;= nodes[u].left &amp;&amp; nodes[u].right &lt;= right) {<font></font>
        nodes[u].sum = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)value * (nodes[u].right - nodes[u].left + <span class="hljs-number">1</span>);
        <span class="hljs-comment">// if update not replace use +=</span><font></font>
        nodes[u].lazy = value;<font></font>
        nodes[u].dirty = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span>;<font></font>
    }<font></font>
    get_down(u);<font></font>
    <span class="hljs-keyword">if</span> (left &lt;= nodes[<span class="hljs-number">2</span>*u].right) {<font></font>
        update(left, right, value, <span class="hljs-number">2</span>*u);<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (right &gt;= nodes[<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>].left) {<font></font>
        update(left, right, value, <span class="hljs-number">2</span>*u + <span class="hljs-number">1</span>);<font></font>
    }<font></font>
    nodes[u].sum = nodes[<span class="hljs-number">2</span>*u].sum + nodes[<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>].sum;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> &amp;sum, <span class="hljs-keyword">int</span> u)</span> </span>{
    <span class="hljs-keyword">if</span> (left &lt;= nodes[u].left &amp;&amp; nodes[u].right &lt;= right) {<font></font>
        sum += nodes[u].sum;<font></font>
        <span class="hljs-keyword">return</span>;<font></font>
    }<font></font>
    get_down(u);<font></font>
    <span class="hljs-keyword">if</span> (left &lt;= nodes[<span class="hljs-number">2</span>*u].right) {<font></font>
        query(left, right, sum, <span class="hljs-number">2</span>*u);<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (right &gt;= nodes[<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>].left) {<font></font>
        query(left, right, sum, <span class="hljs-number">2</span>*u + <span class="hljs-number">1</span>);<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Usage</span>
<span class="hljs-comment">// build_tree(1, L, 1);</span>
<span class="hljs-comment">// update(a, b, new_value, 1);</span>
<span class="hljs-comment">// query(a, b, sum_as_reference, 1);</span>
</code></pre>
<h3 class="code-line" data-line-start="2998" data-line-end="2999"><a id="28_Range_Minimum_Query_RMQ_2998"></a>2.8 Range Minimum Query RMQ</h3>
<pre><code class="has-line-data" data-line-start="3001" data-line-end="3034"><span class="hljs-keyword">struct</span> RMQ { <span class="hljs-comment">// not tested</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAXLENGTH = <span class="hljs-number">2</span> * <span class="hljs-number">1e5</span> + <span class="hljs-number">3</span>;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> LOG_MAXLENGTH = <span class="hljs-number">20</span>;
    <span class="hljs-keyword">int</span> rmq[MAXLENGTH][LOG_MAXLENGTH];<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* arr, <span class="hljs-keyword">int</span> len)</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<font></font>
            rmq[i][<span class="hljs-number">0</span>] = arr[i];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; LOG_MAXLENGTH; j++)
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
                <span class="hljs-keyword">if</span> (i + (<span class="hljs-number">1</span> &lt;&lt; j) &gt; len)
                    <span class="hljs-keyword">break</span>;<font></font>
                rmq[i][j] = rmq[i][j - <span class="hljs-number">1</span>];<font></font>
                rmq[i][j] = min(rmq[i][j - <span class="hljs-number">1</span>], rmq[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j-<span class="hljs-number">1</span>]);<font></font>
            }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">range_minimum_query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>{
        <span class="hljs-keyword">if</span> (l &gt; r)<font></font>
            swap(l, r);<font></font>
<font></font>
        <span class="hljs-keyword">int</span> interval_len = r - l; <span class="hljs-comment">// less 1</span><font></font>
<font></font>
        <span class="hljs-keyword">int</span> first_half = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> ((<span class="hljs-number">1</span> &lt;&lt; first_half) &lt;= interval_len)<font></font>
            first_half++;<font></font>
        first_half--;<font></font>
<font></font>
        <span class="hljs-keyword">int</span> second_half = r - (<span class="hljs-number">1</span> &lt;&lt; first_half) + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> min(rmq[l][first_half], rmq[second_half][first_half]);<font></font>
    }<font></font>
};<font></font>
</code></pre>
<h3 class="code-line" data-line-start="3035" data-line-end="3036"><a id="29_Unionfind_Set_3035"></a>2.9 Union-find Set</h3>
<pre><code class="has-line-data" data-line-start="3038" data-line-end="3057"><span class="hljs-keyword">struct</span> UnionFindSet {
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parent;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nn)</span> </span>{<font></font>
        parent.resize(nn + <span class="hljs-number">1</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; parent.size(); i++)<font></font>
            parent[i] = i;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{<font></font>
        parent[find(x)] = find(y);<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
        <span class="hljs-keyword">return</span> x == parent[x] ? x : parent[x] = find(parent[x]);<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">together</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
        <span class="hljs-keyword">return</span> find(x) == find(y);<font></font>
    }<font></font>
};<font></font>
</code></pre>
<h4 class="code-line" data-line-start="3058" data-line-end="3059"><a id="291_Unionfind_Set__application_3058"></a>2.9.1 Union-find Set - application</h4>
<blockquote>
<p class="has-line-data" data-line-start="3060" data-line-end="3061">place holder</p>
</blockquote>
<h3 class="code-line" data-line-start="3062" data-line-end="3063"><a id="210_Bloom_Filter__Similar_3062"></a>2.10 Bloom Filter (?) (Similar)</h3>
<blockquote>
<p class="has-line-data" data-line-start="3064" data-line-end="3065">Can calculate hash of number sequence quickly.</p>
<p class="has-line-data" data-line-start="3066" data-line-end="3067">If too slow, set REPEAT smaller. Or try again:)</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="3069" data-line-end="3114">#include &lt;random&gt;<font></font>
<font></font>
struct BloomFilterSimilar {<font></font>
    static const int MAXN = 100002;<font></font>
    static const int REPEAT = 10;<font></font>
<font></font>
    unsigned long long hash_constant[REPEAT][MAXN];<font></font>
    set&lt;unsigned long long&gt; hash[REPEAT];<font></font>
<font></font>
    void init_hash(int max_n=MAXN) {<font></font>
        random_device rd;<font></font>
        mt19937 gen(rd());<font></font>
        uniform_int_distribution&lt;unsigned long long&gt; dis(1, ULLONG_MAX);<font></font>
        for (int i = 0; i &lt; REPEAT; i++) {<font></font>
            for (int j = 0; j &lt; max_n; j++)<font></font>
                hash_constant[i][j] = dis(gen);<font></font>
        }<font></font>
    }<font></font>
    <font></font>
    vector&lt;unsigned long long&gt; get_hash(int val) {<font></font>
        vector&lt;unsigned long long&gt; h(REPEAT);<font></font>
        for (int i = 0; i &lt; REPEAT; i++)<font></font>
            h[i] = hash_constant[i][val];<font></font>
        return move(h);<font></font>
    }<font></font>
<font></font>
    // bool exist(int val) {<font></font>
    //  return exist(get_hash(val));<font></font>
    // }<font></font>
    bool exist(const vector&lt;unsigned long long&gt;&amp; h) {<font></font>
        for (int i = 0; i &lt; REPEAT; i++)<font></font>
            if (hash[i].find(h[i]) == end(hash[i]))<font></font>
                return false;<font></font>
        return true; // possible False Positive<font></font>
    }<font></font>
<font></font>
    // void insert(int val) {<font></font>
    //  insert(get_hash(val));<font></font>
    // }<font></font>
    void insert(const vector&lt;unsigned long long&gt;&amp; h) {<font></font>
        for (int i = 0; i &lt; REPEAT; i++)<font></font>
            hash[i].insert(h[i]);<font></font>
    }<font></font>
};<font></font>
</code></pre>
<h2 class="code-line" data-line-start="3115" data-line-end="3116"><a id="3_Methodology_3115"></a>3. Methodology</h2>
<h3 class="code-line" data-line-start="3117" data-line-end="3118"><a id="30_Greedy_3117"></a>3.0 Greedy</h3>
<blockquote>
<p class="has-line-data" data-line-start="3119" data-line-end="3120">It’s Art.</p>
</blockquote>
<h3 class="code-line" data-line-start="3121" data-line-end="3122"><a id="31_Recursive_3121"></a>3.1 Recursive</h3>
<h4 class="code-line" data-line-start="3123" data-line-end="3124"><a id="311_Hanoi_3123"></a>3.1.1 Hanoi</h4>
<pre><code class="has-line-data" data-line-start="3126" data-line-end="3136"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hanoi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span> x, <span class="hljs-keyword">char</span> y, <span class="hljs-keyword">char</span> z)</span> </span>{ <span class="hljs-comment">// 将 x 上编号 1 至 n 的圆盘移到 z, y 作辅助塔</span>
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d from %c to %c\n"</span>, n, x, z); <span class="hljs-comment">// 将编号为 n 的圆盘从 x 移到 z</span>
    <span class="hljs-keyword">else</span> {<font></font>
        hanoi(n-<span class="hljs-number">1</span>, x, z, y); <span class="hljs-comment">// 将 x 上编号 1 至 n-1 的圆盘移到 y, z 作辅助塔</span>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d from %c to %c\n"</span>, n, x, z); <span class="hljs-comment">// 将编号为 n 的圆盘从 x 移到 z</span>
        hanoi(n-<span class="hljs-number">1</span>, y, x, z); <span class="hljs-comment">// 将 y 上编号 1 至 n-1 的圆盘移到 z, x 作辅助塔</span><font></font>
    }<font></font>
}<font></font>
</code></pre>
<h3 class="code-line" data-line-start="3137" data-line-end="3138"><a id="32_Dynamic_Programming_3137"></a>3.2 Dynamic Programming</h3>
<h4 class="code-line" data-line-start="3139" data-line-end="3140"><a id="321_Longest_Increasing_Subsequence_LIS_3139"></a>3.2.1 Longest Increasing Subsequence (LIS)</h4>
<blockquote>
<p class="has-line-data" data-line-start="3141" data-line-end="3142"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (nlog (n))</font></font></p>
</blockquote>
<pre><code class="has-line-data" data-line-start="3144" data-line-end="3152"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; sequence;
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; lis(sequence.size() + <span class="hljs-number">1</span>, INT_MAX); <span class="hljs-comment">// [i]: min value in sequence that have LIS = i</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sequence.size(); i++) {
    <span class="hljs-keyword">int</span> r = sequence[i];
    <span class="hljs-keyword">auto</span> ptr = lower_bound(begin(lis), end(lis), r);<font></font>
    *ptr = min(*ptr, r);<font></font>
}<font></font>
</code></pre>
<h3 class="code-line" data-line-start="3153" data-line-end="3154"><a id="33_Divide_and_Conquer_3153"></a>3.3 Divide and Conquer</h3>
<h4 class="code-line" data-line-start="3155" data-line-end="3156"><a id="331_binary_search_3155"></a>3.3.1 binary search</h4>
<h3 class="code-line" data-line-start="3157" data-line-end="3158"><a id="34_Search_3157"></a>3.4 Search</h3>
<h4 class="code-line" data-line-start="3159" data-line-end="3160"><a id="342__BFS_3159"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.4.2 Bidirectional BFS</font></font></h4>
<h4 class="code-line" data-line-start="3161" data-line-end="3162"><a id="343__3161"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.4.3 Search from the end</font></font></h4>
<h4 class="code-line" data-line-start="3163" data-line-end="3164"><a id="344__binary_increasedecrease_3163"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.4.4 Iterative deepening search (binary increase/decrease)</font></font></h4>
<blockquote>
<p class="has-line-data" data-line-start="3165" data-line-end="3166">placeholder</p>
</blockquote>
<h3 class="code-line" data-line-start="3167" data-line-end="3168"><a id="35_Brute_Force_3167"></a>3.5 Brute Force</h3>
<h4 class="code-line" data-line-start="3169" data-line-end="3170"><a id="351__3169"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.5.1 Subset generation</font></font></h4>
<h2 class="code-line" data-line-start="3171" data-line-end="3172"><a id="4_String_3171"></a>4. String</h2>
<h3 class="code-line" data-line-start="3173" data-line-end="3174"><a id="41_KMP_3173"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1 KMP</font></font></h3>
<blockquote>
<p class="has-line-data" data-line-start="3175" data-line-end="3176">Match pattern in a string</p>
<p class="has-line-data" data-line-start="3177" data-line-end="3178"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (n) = O (len (pattern) + len (string))</font></font></p>
</blockquote>
<pre><code class="has-line-data" data-line-start="3180" data-line-end="3216"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> HHH <span class="hljs-number">10003</span></span><font></font>
<font></font>
<span class="hljs-keyword">int</span> ne[HHH]; <span class="hljs-comment">// next[], if par[i] not matched, jump to i = ne[i]</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kmp</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; par, <span class="hljs-built_in">string</span>&amp; ori)</span> </span>{<font></font>
    ne[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> p = ne[<span class="hljs-number">0</span>], i = <span class="hljs-number">1</span>; i &lt; par.length(); i++) {
        <span class="hljs-keyword">while</span> (p &gt;= <span class="hljs-number">0</span> &amp;&amp; par[p+<span class="hljs-number">1</span>] != par[i])<font></font>
            p = ne[p];<font></font>
        <span class="hljs-keyword">if</span> (par[p+<span class="hljs-number">1</span>] == par[i])<font></font>
            p++;<font></font>
        ne[i] = p;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">int</span> match = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> p = -<span class="hljs-number">1</span>, q = <span class="hljs-number">0</span>; q &lt; ori.length(); q++) {
        <span class="hljs-keyword">while</span> (p &gt;= <span class="hljs-number">0</span> &amp;&amp; par[p+<span class="hljs-number">1</span>] != ori[q])<font></font>
            p = ne[p];<font></font>
        <span class="hljs-keyword">if</span> (par[p+<span class="hljs-number">1</span>] == ori[q])<font></font>
            p++;<font></font>
        <span class="hljs-keyword">if</span> (p + <span class="hljs-number">1</span> == par.length()) { <span class="hljs-comment">// match!</span><font></font>
            p = ne[p];<font></font>
            match++;<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> match; <span class="hljs-comment">// return number of occurance</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> n; <span class="hljs-built_in">cin</span> &gt;&gt; n;
    <span class="hljs-built_in">string</span> par, ori;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; par &gt;&gt; ori)
        <span class="hljs-built_in">cout</span> &lt;&lt; kmp(par, ori) &lt;&lt; endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre>
<h3 class="code-line" data-line-start="3217" data-line-end="3218"><a id="42_BoyerMoore_3217"></a>4.2 Boyer-Moore</h3>
<h3 class="code-line" data-line-start="3219" data-line-end="3220"><a id="43_Longest_palindromic_substring_Manachers_algorithm_3219"></a>4.3 Longest palindromic substring (Manacher’s algorithm)</h3>
<blockquote>
<p class="has-line-data" data-line-start="3221" data-line-end="3222"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O(n)</font></font></p>
</blockquote>
<pre><code class="has-line-data" data-line-start="3224" data-line-end="3260"><span class="hljs-keyword">int</span> dp[HHH];
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthLongestPalindromSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; s)</span> </span>{
    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(dp));
    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> pivot = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> len = s.length() * <span class="hljs-number">2</span>; <span class="hljs-comment">// _s0_s1_s2 = 2 * length</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) {
        <span class="hljs-keyword">int</span> pBorder = pivot + dp[pivot];
        <span class="hljs-keyword">int</span> iBorder = i;
        <span class="hljs-keyword">if</span> (iBorder &lt; pBorder &amp;&amp; <span class="hljs-number">2</span> * pivot - i &gt; <span class="hljs-number">0</span>) {<font></font>
            dp[i] = dp[<span class="hljs-number">2</span>*pivot-i];<font></font>
            iBorder = min(pBorder, i + dp[i]);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (iBorder &gt;= pBorder) {
            <span class="hljs-keyword">int</span> j = iBorder + (iBorder % <span class="hljs-number">2</span> ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>);
            <span class="hljs-keyword">for</span> (; j &lt; len &amp;&amp; <span class="hljs-number">2</span>*i-j &gt; <span class="hljs-number">0</span> &amp;&amp; s[j/<span class="hljs-number">2</span>] == s[(<span class="hljs-number">2</span>*i-j)/<span class="hljs-number">2</span>]; j += <span class="hljs-number">2</span>)<font></font>
                ;<font></font>
            iBorder = j - <span class="hljs-number">2</span>;<font></font>
            dp[i] = iBorder - i;<font></font>
            pivot = i;<font></font>
        }<font></font>
        ans = max(ans, dp[i] + <span class="hljs-number">1</span>);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> ans;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> n; <span class="hljs-built_in">cin</span> &gt;&gt; n;
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; s)
        <span class="hljs-built_in">cout</span> &lt;&lt; lengthLongestPalindromSubstring(s) &lt;&lt; endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre>
<h2 class="code-line" data-line-start="3261" data-line-end="3262"><a id="5_Graph_3261"></a>5. Graph</h2>
<h3 class="code-line" data-line-start="3263" data-line-end="3264"><a id="51_Graph_Structure_3263"></a>5.1 Graph Structure</h3>
<pre><code class="has-line-data" data-line-start="3266" data-line-end="3302"><span class="hljs-keyword">struct</span> Graph {
    <span class="hljs-keyword">struct</span> Edge {
        <span class="hljs-keyword">int</span> from;
        <span class="hljs-keyword">int</span> to;
        <span class="hljs-keyword">int</span> len;<font></font>
    };<font></font>
<font></font>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAXNODE = <span class="hljs-number">3</span> * <span class="hljs-number">1e5</span> + <span class="hljs-number">2</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; g[MAXNODE];
    <span class="hljs-built_in">vector</span>&lt;Edge&gt; edge;
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nn)</span> </span>{<font></font>
        n = nn;<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<font></font>
            g[i].clear();<font></font>
        edge.clear();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_e</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
        g[x].push_back(edge.size());<font></font>
        edge.push_back((Edge){x, y, len});<font></font>
        g[y].push_back(edge.size());<font></font>
        edge.push_back((Edge){y, x, len});<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d:"</span>, i);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie : g[i])
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>, edge[ie].to);
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
        }<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
    }<font></font>
};<font></font>
</code></pre>
<pre><code class="has-line-data" data-line-start="3304" data-line-end="3345"><span class="hljs-keyword">struct</span> Network {
    <span class="hljs-keyword">struct</span> Edge {
        <span class="hljs-keyword">int</span> to;
        <span class="hljs-keyword">int</span> pre_edge;
        <span class="hljs-keyword">int</span> cap;
        <span class="hljs-keyword">int</span> flow;<font></font>
    };<font></font>
<font></font>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; last;<font></font>
<font></font>
    <span class="hljs-keyword">int</span> nv; <span class="hljs-comment">// total number of vertex, index range: [0, nv)</span>
    <span class="hljs-built_in">vector</span>&lt;Edge&gt; edge;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _nv)</span> </span>{<font></font>
        nv = _nv;<font></font>
        <span class="hljs-built_in">vector</span>&lt;Edge&gt;().swap(edge);
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(nv + <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>).swap(last);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_e</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> cap, <span class="hljs-keyword">int</span> r_cap = <span class="hljs-number">0</span>)</span> </span>{<font></font>
        Edge e{y, last[x], cap, <span class="hljs-number">0</span>};<font></font>
        last[x] = edge.size();<font></font>
        edge.push_back(move(e));<font></font>
        <font></font>
        Edge r_e{x, last[y], r_cap, <span class="hljs-number">0</span>};<font></font>
        last[y] = edge.size();<font></font>
        edge.push_back(move(r_e));<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_edge</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nv; i++) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d:"</span>, i);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie = last[i]; ie != -<span class="hljs-number">1</span>; ) {
                <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie]; <font></font>
                ie = e.pre_edge;<font></font>
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" (%d)%d/%d"</span>, e.to, e.flow, e.cap);<font></font>
            }<font></font>
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
        }<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre>
<h3 class="code-line" data-line-start="3346" data-line-end="3347"><a id="52_Minimium_Spanning_Tree_3346"></a>5.2 Minimium Spanning Tree</h3>
<h4 class="code-line" data-line-start="3348" data-line-end="3349"><a id="521_Prims_3348"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2.1 Prim's</font></font></h4>
<blockquote>
<p class="has-line-data" data-line-start="3350" data-line-end="3351"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ((V + E) log (V))</font></font></p>
</blockquote>
<pre><code class="has-line-data" data-line-start="3353" data-line-end="3431"><span class="hljs-keyword">struct</span> Graph {
    <span class="hljs-keyword">struct</span> Edge {
        <span class="hljs-keyword">int</span> from;
        <span class="hljs-keyword">int</span> to;
        <span class="hljs-keyword">int</span> len;<font></font>
    };<font></font>
<font></font>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAXNODE = <span class="hljs-number">3</span> * <span class="hljs-number">1e5</span> + <span class="hljs-number">2</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; g[MAXNODE];
    <span class="hljs-built_in">vector</span>&lt;Edge&gt; edge;
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nn)</span> </span>{<font></font>
        n = nn;<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<font></font>
            g[i].clear();<font></font>
        edge.clear();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_e</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
        g[x].push_back(edge.size());<font></font>
        edge.push_back((Edge){x, y, len});<font></font>
        g[y].push_back(edge.size());<font></font>
        edge.push_back((Edge){y, x, len});<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d:"</span>, i);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie : g[i])
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>, edge[ie].to);
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
        }<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// ---- start of Minimum Spanning Tree ---</span>
    <span class="hljs-comment">// </span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; added;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; mindis; <span class="hljs-comment">// little optimization</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mst</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>).swap(added);
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, INT_MAX).swap(mindis);<font></font>
<font></font>
        <span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-keyword">const</span> Edge&amp; a, <span class="hljs-keyword">const</span> Edge&amp; b) {
            <span class="hljs-keyword">return</span> a.len &gt; b.len;<font></font>
        };<font></font>
        priority_queue&lt;Edge, <span class="hljs-built_in">vector</span>&lt;Edge&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; near(cmp);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g[<span class="hljs-number">1</span>].size(); i++) {
            <span class="hljs-keyword">const</span> Edge&amp; e = edge[g[<span class="hljs-number">1</span>][i]];<font></font>
            near.push(e);<font></font>
            mindis[e.to] = e.len; <span class="hljs-comment">// little optimization</span><font></font>
        }<font></font>
        added[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<font></font>
<font></font>
        <span class="hljs-keyword">while</span> (near.size()) {<font></font>
            Edge cur = near.top(); near.pop();<font></font>
            added[cur.to] = <span class="hljs-literal">true</span>;
            <span class="hljs-comment">// add Edge cur</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie : g[cur.to]) {
                <span class="hljs-keyword">const</span> Edge&amp; nxe = edge[ie];
                <span class="hljs-keyword">int</span> nx = nxe.to;
                <span class="hljs-keyword">if</span> (!added[nx]<font></font>
                 &amp;&amp; mindis[nx] &gt; nxe.len) { <span class="hljs-comment">// little optimization</span>
                    mindis[nx] = nxe.len; <span class="hljs-comment">// little optimization</span><font></font>
                    near.push(nxe);<font></font>
                }<font></font>
            }<font></font>
            <span class="hljs-keyword">while</span> (near.size() &amp;&amp; added[near.top().to])<font></font>
                near.pop();<font></font>
        }<font></font>
        <span class="hljs-comment">// </span><font></font>
    }<font></font>
    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// ---- end of Minimum Spanning Tree ---</span>
    <span class="hljs-comment">// </span><font></font>
};<font></font>
</code></pre>
<h4 class="code-line" data-line-start="3432" data-line-end="3433"><a id="522_Kruskal_3432"></a>5.2.2 Kruskal</h4>
<blockquote>
<p class="has-line-data" data-line-start="3434" data-line-end="3435">Elog(E) + Elog(V)</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="3437" data-line-end="3499"><span class="hljs-keyword">struct</span> Graph {
    <span class="hljs-keyword">struct</span> Edge {
        <span class="hljs-keyword">int</span> from;
        <span class="hljs-keyword">int</span> to;
        <span class="hljs-keyword">int</span> len;<font></font>
    };<font></font>
<font></font>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAXNODE = <span class="hljs-number">3</span> * <span class="hljs-number">1e5</span> + <span class="hljs-number">2</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; g[MAXNODE];
    <span class="hljs-built_in">vector</span>&lt;Edge&gt; edge;
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nn)</span> </span>{<font></font>
        n = nn;<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<font></font>
            g[i].clear();<font></font>
        edge.clear();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_e</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
        g[x].push_back(edge.size());<font></font>
        edge.push_back((Edge){x, y, len});<font></font>
        g[y].push_back(edge.size());<font></font>
        edge.push_back((Edge){y, x, len});<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d:"</span>, i);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie : g[i])
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>, edge[ie].to);
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
        }<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// ---- start of Minimum Spanning Tree ---</span>
    <span class="hljs-comment">// </span><font></font>
    UnionFindSet ufs;<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mst</span><span class="hljs-params">()</span> </span>{<font></font>
        ufs.init(n);<font></font>
        <span class="hljs-built_in">vector</span>&lt;Edge&gt; eee = edge;<font></font>
        sort(begin(eee), end(eee), [](<span class="hljs-keyword">const</span> Edge&amp; a, <span class="hljs-keyword">const</span> Edge&amp; b) {
            <span class="hljs-keyword">return</span> a.len &lt; b.len;<font></font>
        });<font></font>
<font></font>
        <span class="hljs-keyword">int</span> need = n - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; e : eee) {
            <span class="hljs-keyword">if</span> (!ufs.together(e.from, e.to)) {
                <span class="hljs-comment">// add Edge e</span><font></font>
                ufs.merge(e.from, e.to);<font></font>
                need--;<font></font>
                <span class="hljs-keyword">if</span> (!need)
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// ---- end of Minimum Spanning Tree ---</span>
    <span class="hljs-comment">// </span><font></font>
};<font></font>
</code></pre>
<h3 class="code-line" data-line-start="3500" data-line-end="3501"><a id="53_Shortest_Path_3500"></a>5.3 Shortest Path</h3>
<h4 class="code-line" data-line-start="3502" data-line-end="3503"><a id="531__3502"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.3.1 Any two points</font></font></h4>
<pre><code class="has-line-data" data-line-start="3505" data-line-end="3510">for (k)<font></font>
    for (i)<font></font>
        for (j)<font></font>
            d(i, j) = min(d(i, j), d(i, k) + d(j, k))<font></font>
</code></pre>
<h4 class="code-line" data-line-start="3511" data-line-end="3512"><a id="532_BellmanFord_3511"></a>5.3.2 Bellman–Ford</h4>
<blockquote>
<p class="has-line-data" data-line-start="3513" data-line-end="3515">Bellman–Ford algorithm is O(VE).<br>
Can be applied to situations when there is a maximun number of vertices in shortest path.</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="3517" data-line-end="3521">for (n times of relax)  # n = number of node<font></font>
    for (each edge)<font></font>
        relax each edge<font></font>
</code></pre>
<h4 class="code-line" data-line-start="3522" data-line-end="3523"><a id="533_SPFA_3522"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.3.3 SPFA</font></font></h4>
<h4 class="code-line" data-line-start="3524" data-line-end="3525"><a id="534_Dijkstra_3524"></a>5.3.4 Dijkstra</h4>
<blockquote>
<p class="has-line-data" data-line-start="3526" data-line-end="3527">Dijkstra is good for graphs non-negative edges.</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="3528" data-line-end="3529"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O(Vlog(E)) (?)</font></font></p>
</blockquote>
<pre><code class="has-line-data" data-line-start="3531" data-line-end="3556"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>{
    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; m;<font></font>
    dist[s] = <span class="hljs-number">0</span>;<font></font>
    m[<span class="hljs-number">0</span>].push(s);
    <span class="hljs-keyword">while</span> (m.size()) {
        <span class="hljs-keyword">if</span> (!m.begin()-&gt;second.size()) {<font></font>
            m.erase(m.begin());<font></font>
            <span class="hljs-keyword">continue</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">int</span> cur = m.begin()-&gt;second.front();<font></font>
        m.begin()-&gt;second.pop();<font></font>
        <span class="hljs-keyword">if</span> (done[cur]) <span class="hljs-keyword">continue</span>;<font></font>
        done[cur] = <span class="hljs-literal">true</span>;<font></font>
        SHOW(cur, dist[cur])<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> next : children[cur]) {
            <span class="hljs-keyword">if</span> (!done[next] &amp;&amp; dist[next] &gt; dist[cur] + edge[cur][next]) {<font></font>
                dist[next] = dist[cur] + edge[cur][next];<font></font>
                prev[next] = cur;<font></font>
                m[dist[next]].push(next);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-built_in">cout</span> &lt;&lt; endl;<font></font>
}<font></font>
</code></pre>
<p class="has-line-data" data-line-start="3557" data-line-end="3558">If you want to write compare operator().</p>
<pre><code class="has-line-data" data-line-start="3560" data-line-end="3586"><span class="hljs-keyword">struct</span> cmp {
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; a, pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; b)</span> </span>{
        <span class="hljs-keyword">return</span> a.first &gt; b.first;<font></font>
    }<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>{<font></font>
    priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;, <span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;, cmp&gt; q;<font></font>
    q.push(make_pair(<span class="hljs-number">0</span>, s));<font></font>
    dist[s] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (q.size()) {
        <span class="hljs-keyword">int</span> cur = q.top().second;<font></font>
        q.pop();<font></font>
        <span class="hljs-keyword">if</span> (done[cur]) <span class="hljs-keyword">continue</span>;<font></font>
        done[cur] = <span class="hljs-literal">true</span>;<font></font>
        SHOW(cur, dist[cur])<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> next : children[cur]) {
            <span class="hljs-keyword">if</span> (!done[next] &amp;&amp; dist[next] &gt; dist[cur] + edge[cur][next]) {<font></font>
                dist[next] = dist[cur] + edge[cur][next];<font></font>
                q.push(make_pair(dist[next], next));<font></font>
                prev[next] = cur;<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre>
<h3 class="code-line" data-line-start="3587" data-line-end="3588"><a id="54_Maximum_Matching_3587"></a>5.4 Maximum Matching</h3>
<h4 class="code-line" data-line-start="3589" data-line-end="3590"><a id="541_on_Bipartite_Graph__3589"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.4.1 on Bipartite Graph</font></font></h4>
<blockquote>
<ol>
<li class="has-line-data" data-line-start="3591" data-line-end="3592">A graph is bipartite if and only if it does not contain an odd cycle.</li>
<li class="has-line-data" data-line-start="3592" data-line-end="3593">A graph is bipartite if and only if it is 2-colorable, (i.e. its chromatic number is less than or equal to 2).</li>
<li class="has-line-data" data-line-start="3593" data-line-end="3594">The spectrum of a graph is symmetric if and only if it’s a bipartite graph.</li>
</ol>
</blockquote>
<h5 class="code-line" data-line-start="3595" data-line-end="3596"><a id="5411_Hungarian_algorithm__3595"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.4.1.1 Hungarian algorithm</font></font></h5>
<blockquote>
<p class="has-line-data" data-line-start="3597" data-line-end="3598"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (E * V)</font></font></p>
</blockquote>
<pre><code class="has-line-data" data-line-start="3600" data-line-end="3687"><span class="hljs-keyword">struct</span> Network {
    <span class="hljs-keyword">struct</span> Edge {
        <span class="hljs-keyword">int</span> to;
        <span class="hljs-keyword">int</span> pre_edge;
        <span class="hljs-keyword">int</span> cap;
        <span class="hljs-keyword">int</span> flow;<font></font>
    };<font></font>
<font></font>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MAXNODE <span class="hljs-number">405</span></span>
    <span class="hljs-keyword">int</span> last[MAXNODE];<font></font>
<font></font>
    <span class="hljs-keyword">int</span> nv; <span class="hljs-comment">// total number of vertex, index range: [0, nv)</span>
    <span class="hljs-built_in">vector</span>&lt;Edge&gt; edge;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _nv)</span> </span>{<font></font>
        nv = _nv;<font></font>
        edge.clear();<font></font>
        fill(last, last + nv, -<span class="hljs-number">1</span>);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_e</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> cap, <span class="hljs-keyword">int</span> r_cap = <span class="hljs-number">0</span>)</span> </span>{<font></font>
        Edge e = {y, last[x], cap, <span class="hljs-number">0</span>};
        <span class="hljs-comment">// Edge e{y, last[x], cap, 0};</span><font></font>
        last[x] = edge.size();<font></font>
        <span class="hljs-comment">// edge.push_back(move(e));</span><font></font>
        edge.push_back(e);<font></font>
        <font></font>
        Edge r_e = {x, last[y], r_cap, <span class="hljs-number">0</span>};
        <span class="hljs-comment">// Edge r_e{x, last[y], r_cap, 0};</span><font></font>
        last[y] = edge.size();<font></font>
        <span class="hljs-comment">// edge.push_back(move(r_e));</span><font></font>
        edge.push_back(r_e);<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_edge</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nv; i++) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"v [%d]:"</span>, i);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie = last[i]; ie != -<span class="hljs-number">1</span>; ) {
                <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie]; <font></font>
                ie = e.pre_edge;<font></font>
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" [%d]%d/%d"</span>, e.to, e.flow, e.cap);<font></font>
            }<font></font>
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
        }<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// bipartite match</span>
    <span class="hljs-comment">// O(V * E)</span>
    <span class="hljs-keyword">int</span> peer[MAXNODE];
    <span class="hljs-keyword">bool</span> went[MAXNODE];
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bipartite_match</span><span class="hljs-params">()</span> </span>{<font></font>
        fill(peer, peer + nv, -<span class="hljs-number">1</span>);
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nv; i++) {
            <span class="hljs-keyword">if</span> (last[i] == -<span class="hljs-number">1</span> || peer[i] != -<span class="hljs-number">1</span>)
                <span class="hljs-keyword">continue</span>;<font></font>
            fill(went, went + nv, <span class="hljs-literal">false</span>);
            <span class="hljs-keyword">if</span> (match(i))<font></font>
                ans++;<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> ans;<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur)</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie = last[cur]; ie != -<span class="hljs-number">1</span>; ) {
            <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie];<font></font>
            ie = e.pre_edge;<font></font>
            <span class="hljs-keyword">int</span> to = e.to;
            <span class="hljs-keyword">if</span> (went[to])
                <span class="hljs-keyword">continue</span>;<font></font>
            went[to] = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span> (peer[to] == -<span class="hljs-number">1</span> || match(peer[to])) {<font></font>
                peer[to] = cur;<font></font>
                peer[cur] = to;<font></font>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_peer</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nv; i++)
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d peer-&gt; %d\n"</span>, i, peer[i]);<font></font>
    }<font></font>
    <span class="hljs-comment">// end of </span>
    <span class="hljs-comment">// bipartite match</span>
    <span class="hljs-comment">// </span><font></font>
};<font></font>
</code></pre>
<h5 class="code-line" data-line-start="3688" data-line-end="3689"><a id="5412_HopcroftKarp_Algorithm_3688"></a>5.4.1.2 Hopcroft–Karp Algorithm</h5>
<blockquote>
<p class="has-line-data" data-line-start="3690" data-line-end="3691"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (sqrt (V) * E)</font></font></p>
</blockquote>
<pre><code class="has-line-data" data-line-start="3693" data-line-end="3765"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MAXN <span class="hljs-number">1010</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MAXINT <span class="hljs-number">0x7fffffff</span></span><font></font>
<font></font>
<span class="hljs-keyword">int</span> n, m, top, x, y;
<span class="hljs-keyword">int</span> ans;<font></font>
<font></font>
<span class="hljs-keyword">int</span> disx[MAXN], disy[MAXN], matx[MAXN], maty[MAXN];<span class="hljs-comment">//x,y,分别为二分图的两个点集,mat为每个点在对侧集合的匹配点,如果当前没有匹配点则为-1 </span><font></font>
<font></font>
<span class="hljs-keyword">struct</span> edge {
    <span class="hljs-keyword">int</span> to;<font></font>
    edge *next;<font></font>
}e[MAXN*MAXN], *prev[MAXN];<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v)</span> </span>{<font></font>
    e[++top].to = v;<font></font>
    e[top].next = prev[u];<font></font>
    prev[u] = &amp;e[top];<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// 寻找最短增广路 </span>
    <span class="hljs-keyword">bool</span> ret = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;
    <span class="hljs-built_in">memset</span>(disx, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(disx));
    <span class="hljs-built_in">memset</span>(disy, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(disy));
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)
        <span class="hljs-keyword">if</span> (matx[i] == -<span class="hljs-number">1</span>)<font></font>
            q.push(i); <span class="hljs-comment">// 找到未盖点,入队 </span>
    <span class="hljs-keyword">while</span> (!q.empty()) { <span class="hljs-comment">// 在二分图另一个点集的非盖点中寻找增广路 </span>
        <span class="hljs-keyword">int</span> x = q.front(); q.pop();
        <span class="hljs-keyword">for</span> (edge *i = prev[x]; i; i = i-&gt;next)
            <span class="hljs-keyword">if</span> (!disy[i-&gt;to]) {<font></font>
                disy[i-&gt;to] = disx[x] + <span class="hljs-number">1</span>;
                <span class="hljs-keyword">if</span> (maty[i-&gt;to]==-<span class="hljs-number">1</span>)<font></font>
                    ret = <span class="hljs-number">1</span>; <span class="hljs-comment">// 找到增广路 </span>
                <span class="hljs-keyword">else</span>
                    disx[maty[i-&gt;to]] = disy[i-&gt;to] + <span class="hljs-number">1</span>, q.push(maty[i-&gt;to]);    <font></font>
            }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> ret;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{ <span class="hljs-comment">// 沿增广路增广 </span>
    <span class="hljs-keyword">for</span> (edge *i = prev[x]; i; i = i-&gt;next) {
        <span class="hljs-keyword">if</span> (disy[i-&gt;to] == disx[x] + <span class="hljs-number">1</span>) {<font></font>
            disy[i-&gt;to] = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">if</span> (maty[i-&gt;to] == -<span class="hljs-number">1</span> || dfs(maty[i-&gt;to])) {<font></font>
                matx[x] = i-&gt;to;<font></font>
                maty[i-&gt;to] = x;<font></font>
                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);
    <span class="hljs-built_in">memset</span>(matx, -<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(matx));
    <span class="hljs-built_in">memset</span>(maty, -<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(maty));
    <span class="hljs-comment">/*for (int i=1;i&lt;=n;i++)
    {
        scanf("%d%d",&amp;x,&amp;y);x++;y++;
        insert(i,x);insert(i,y);
    }建图请自动忽略*/</span>
    <span class="hljs-keyword">while</span> (bfs()) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)
            <span class="hljs-keyword">if</span> (matx[i] == -<span class="hljs-number">1</span> &amp;&amp; dfs(i))<font></font>
                ans++;<font></font>
    }<font></font>
    <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; endl;<font></font>
}<font></font>
</code></pre>
<h4 class="code-line" data-line-start="3766" data-line-end="3767"><a id="542_on_General_Graph_3766"></a>5.4.2 on General Graph</h4>
<h5 class="code-line" data-line-start="3768" data-line-end="3769"><a id="5421_Blossom_Algorithm_3768"></a>5.4.2.1 Blossom Algorithm</h5>
<p class="has-line-data" data-line-start="3770" data-line-end="3771"><a href="http://www.conlan.cc/2013/03/08/%E4%B8%80%E8%88%AC%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">General graph maximum matching</font></font></a></p>
<pre><code class="has-line-data" data-line-start="3773" data-line-end="3898">const int NMax = 230;<font></font>
<font></font>
int Next[NMax];<font></font>
int spouse[NMax];<font></font>
int belong[NMax];<font></font>
<font></font>
int findb(int a) {<font></font>
    return belong[a] == a ? a : belong[a] = findb(belong[a]);<font></font>
}<font></font>
<font></font>
void together(int a,int b) {<font></font>
    a = findb(a), b = findb(b);<font></font>
    if (a != b)<font></font>
        belong[a] = b;<font></font>
}<font></font>
<font></font>
vector&lt;int&gt; E[NMax];<font></font>
int N;<font></font>
int Q[NMax],bot;<font></font>
int mark[NMax];<font></font>
int visited[NMax];<font></font>
<font></font>
int findLCA(int x,int y) {<font></font>
    static int t = 0;<font></font>
    t++;<font></font>
    while (1) {<font></font>
        if (x!=-1) {<font></font>
            x = findb(x);<font></font>
            if (visited[x] == t)<font></font>
                return x;<font></font>
            visited[x] = t;<font></font>
            if (spouse[x] != -1)<font></font>
                x = Next[spouse[x]];<font></font>
            else x = -1;<font></font>
        }<font></font>
        swap(x,y);<font></font>
    }<font></font>
}<font></font>
<font></font>
void goup(int a,int p) {<font></font>
    while (a != p) {<font></font>
        int b = spouse[a], c = Next[b];<font></font>
        if (findb(c) != p)<font></font>
            Next[c] = b;<font></font>
        if (mark[b] == 2) <font></font>
            mark[Q[bot++] = b] = 1;<font></font>
        if (mark[c] == 2)<font></font>
            mark[Q[bot++] = c] = 1;<font></font>
        together(a,b);<font></font>
        together(b,c);<font></font>
        a = c;<font></font>
    }<font></font>
}<font></font>
<font></font>
void findaugment(int s) {<font></font>
    for (int i = 0; i &lt; N; i++)<font></font>
        Next[i] = -1, belong[i] = i, mark[i] = 0, visited[i] = -1;<font></font>
    Q[0] = s; <font></font>
    bot = 1; <font></font>
    mark[s] = 1;<font></font>
    for (int head = 0; spouse[s] == -1 &amp;&amp; head &lt; bot; head++) {<font></font>
        int x = Q[head];<font></font>
        for (int i = 0; i &lt; (int)E[x].size(); i++) {<font></font>
            int y = E[x][i];<font></font>
            if (spouse[x] != y &amp;&amp; findb(x) != findb(y) &amp;&amp; mark[y] != 2) {<font></font>
                if (mark[y] == 1) {<font></font>
                    int p = findLCA(x,y);<font></font>
                    if (findb(x) != p) <font></font>
                        Next[x] = y;<font></font>
                    if (findb(y) != p) <font></font>
                        Next[y] = x;<font></font>
                    goup(x,p);<font></font>
                    goup(y,p);<font></font>
                }<font></font>
                else if (spouse[y] == -1) {<font></font>
                    Next[y] = x;<font></font>
                    for (int j = y; j != -1; ) {<font></font>
                        int k = Next[j];<font></font>
                        int l = spouse[k];<font></font>
                        spouse[j] = k;<font></font>
                        spouse[k] = j;<font></font>
                        j = l;<font></font>
                    }<font></font>
                    break;<font></font>
                }<font></font>
                else{<font></font>
                    Next[y] = x;<font></font>
                    mark[Q[bot++] = spouse[y]] = 1;<font></font>
                    mark[y] = 2;<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
int Map[NMax][NMax];<font></font>
<font></font>
int main() {<font></font>
    memset(Map, 0, sizeof(Map));<font></font>
<font></font>
    scanf("%d",&amp;N);<font></font>
    int x, y;<font></font>
    while (scanf("%d%d",&amp;x,&amp;y) != EOF) {<font></font>
        x--;<font></font>
        y--;<font></font>
        if (x != y &amp;&amp; !Map[x][y]) {<font></font>
            Map[x][y] = Map[y][x] = 1;<font></font>
            E[x].push_back(y);<font></font>
            E[y].push_back(x);<font></font>
        }<font></font>
    }<font></font>
    memset(spouse, -1, sizeof(spouse));<font></font>
    for (int i = 0; i &lt; N; i++)<font></font>
        if (spouse[i] == -1)<font></font>
            findaugment(i);<font></font>
    int ret = 0;<font></font>
    for (int i = 0; i &lt; N; i++)<font></font>
        if (spouse[i] != -1)<font></font>
            ret++;<font></font>
    printf("%d\n", ret);<font></font>
    for (int i = 0; i &lt; N; i++)<font></font>
        if (spouse[i] != -1 &amp;&amp; spouse[i] &gt; i)<font></font>
            printf("pair: %d %d\n", i + 1, spouse[i] + 1);<font></font>
}<font></font>
</code></pre>
<h3 class="code-line" data-line-start="3899" data-line-end="3900"><a id="55_Maximum_Flow_Problem__3899"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.5 Maximum Flow Problem</font></font></h3>
<h4 class="code-line" data-line-start="3901" data-line-end="3902"><a id="551_Dinic_3901"></a>5.5.1 Dinic</h4>
<pre><code class="has-line-data" data-line-start="3903" data-line-end="4010"><span class="hljs-comment">// a convenient class</span><font></font>
<font></font>
<span class="hljs-keyword">struct</span> Network {
    <span class="hljs-keyword">struct</span> Edge {
        <span class="hljs-keyword">int</span> to;
        <span class="hljs-keyword">int</span> pre_edge;
        <span class="hljs-keyword">int</span> cap;
        <span class="hljs-keyword">int</span> flow;<font></font>
    };<font></font>
<font></font>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MAXNODE <span class="hljs-number">405</span></span>
    <span class="hljs-keyword">int</span> last[MAXNODE];<font></font>
<font></font>
    <span class="hljs-keyword">int</span> nv; <span class="hljs-comment">// total number of vertex, index range: [0, nv)</span>
    <span class="hljs-built_in">vector</span>&lt;Edge&gt; edge;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _nv)</span> </span>{<font></font>
        nv = _nv;<font></font>
        edge.clear();<font></font>
        fill(last, last + nv, -<span class="hljs-number">1</span>);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_e</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> cap, <span class="hljs-keyword">int</span> r_cap = <span class="hljs-number">0</span>)</span> </span>{<font></font>
        Edge e = {y, last[x], cap, <span class="hljs-number">0</span>};
        <span class="hljs-comment">// Edge e{y, last[x], cap, 0};</span><font></font>
        last[x] = edge.size();<font></font>
        <span class="hljs-comment">// edge.push_back(move(e));</span><font></font>
        edge.push_back(e);<font></font>
        <font></font>
        Edge r_e = {x, last[y], r_cap, <span class="hljs-number">0</span>};
        <span class="hljs-comment">// Edge r_e{x, last[y], r_cap, 0};</span><font></font>
        last[y] = edge.size();<font></font>
        <span class="hljs-comment">// edge.push_back(move(r_e));</span><font></font>
        edge.push_back(r_e);<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_edge</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nv; i++) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"v [%d]:"</span>, i);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie = last[i]; ie != -<span class="hljs-number">1</span>; ) {
                <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie]; <font></font>
                ie = e.pre_edge;<font></font>
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" [%d]%d/%d"</span>, e.to, e.flow, e.cap);<font></font>
            }<font></font>
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
        }<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// maximum flow</span>
    <span class="hljs-comment">// dinic O(V * V * E)</span>
    <span class="hljs-keyword">int</span> lv[MAXNODE];
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">mark_level</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>{<font></font>
        fill(lv, lv + MAXNODE, -<span class="hljs-number">1</span>);
        <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<font></font>
        lv[start] = <span class="hljs-number">0</span>;<font></font>
        q.push(start);<font></font>
        <span class="hljs-keyword">while</span> (!q.empty()) {
            <span class="hljs-keyword">int</span> cur = q.front(); q.pop();
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie = last[cur]; ie != -<span class="hljs-number">1</span>; ) {
                <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie]; <font></font>
                ie = e.pre_edge;<font></font>
                <span class="hljs-keyword">if</span> (e.cap != e.flow &amp;&amp; lv[e.to] == -<span class="hljs-number">1</span>) {<font></font>
                    lv[e.to] = lv[cur] + <span class="hljs-number">1</span>;<font></font>
                    q.push(e.to);<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> lv[end] != -<span class="hljs-number">1</span>;<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_lv</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nv; i++) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"lv[%d] = %d\n"</span>, i, lv[i]);<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">augment</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span> min_flow)</span> </span>{
        <span class="hljs-keyword">if</span> (cur == end)
            <span class="hljs-keyword">return</span> min_flow;<font></font>
<font></font>
        <span class="hljs-keyword">int</span> augmented_flow = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie = last[cur]; ie != -<span class="hljs-number">1</span>; ) {<font></font>
            Edge&amp; e = edge[ie]; <font></font>
            Edge&amp; re = edge[ie ^ <span class="hljs-number">1</span>];<font></font>
            ie = e.pre_edge;<font></font>
            <span class="hljs-keyword">if</span> (lv[e.to] == lv[cur] + <span class="hljs-number">1</span> &amp;&amp;<font></font>
                e.cap &gt; e.flow &amp;&amp;<font></font>
                (augmented_flow = augment(e.to, end, min(e.cap - e.flow, min_flow)))<font></font>
            ) {<font></font>
                e.flow += augmented_flow;<font></font>
                re.flow -= augmented_flow;<font></font>
                <span class="hljs-keyword">return</span> augmented_flow;<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>{
        <span class="hljs-keyword">int</span> total_flow = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> flow = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (mark_level(start, end)) <span class="hljs-comment">// update level</span>
            <span class="hljs-keyword">while</span> (flow = augment(start, end, INT_MAX)) <span class="hljs-comment">// eat up all augmented flow</span><font></font>
                total_flow += flow;<font></font>
        <span class="hljs-keyword">return</span> total_flow;<font></font>
    }<font></font>
    <span class="hljs-comment">// end of</span>
    <span class="hljs-comment">// maximum flow - dinic</span>
    <span class="hljs-comment">// </span><font></font>
};<font></font>
</code></pre>
<h4 class="code-line" data-line-start="4012" data-line-end="4013"><a id="552_Improved_SAP__Gap_Optimization_4012"></a>5.5.2 Improved SAP + Gap Optimization</h4>
<blockquote>
<p class="has-line-data" data-line-start="4014" data-line-end="4015">TODO add more optimizations</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="4017" data-line-end="4158"><span class="hljs-keyword">struct</span> Network {
    <span class="hljs-keyword">struct</span> Edge {
        <span class="hljs-keyword">int</span> to;
        <span class="hljs-keyword">int</span> pre_edge;
        <span class="hljs-keyword">int</span> cap;
        <span class="hljs-keyword">int</span> flow;<font></font>
    };<font></font>
<font></font>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MAXNODE <span class="hljs-number">405</span></span>
    <span class="hljs-keyword">int</span> last[MAXNODE];<font></font>
<font></font>
    <span class="hljs-keyword">int</span> nv; <span class="hljs-comment">// total number of vertex, index range: [0, nv)</span>
    <span class="hljs-built_in">vector</span>&lt;Edge&gt; edge;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _nv)</span> </span>{<font></font>
        nv = _nv;<font></font>
        edge.clear();<font></font>
        fill(last, last + nv, -<span class="hljs-number">1</span>);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_e</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> cap, <span class="hljs-keyword">int</span> r_cap = <span class="hljs-number">0</span>)</span> </span>{<font></font>
        Edge e = {y, last[x], cap, <span class="hljs-number">0</span>};
        <span class="hljs-comment">// Edge e{y, last[x], cap, 0};</span><font></font>
        last[x] = edge.size();<font></font>
        <span class="hljs-comment">// edge.push_back(move(e));</span><font></font>
        edge.push_back(e);<font></font>
        <font></font>
        Edge r_e = {x, last[y], r_cap, <span class="hljs-number">0</span>};
        <span class="hljs-comment">// Edge r_e{x, last[y], r_cap, 0};</span><font></font>
        last[y] = edge.size();<font></font>
        <span class="hljs-comment">// edge.push_back(move(r_e));</span><font></font>
        edge.push_back(r_e);<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_edge</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nv; i++) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"v [%d]:"</span>, i);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie = last[i]; ie != -<span class="hljs-number">1</span>; ) {
                <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie]; <font></font>
                ie = e.pre_edge;<font></font>
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" [%d]%d/%d"</span>, e.to, e.flow, e.cap);<font></font>
            }<font></font>
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
        }<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// maximum flow</span>
    <span class="hljs-comment">// isap + gap O(V * V * E)</span>
    <span class="hljs-comment">// a bit faster than dinic</span>
    <span class="hljs-keyword">int</span> lv[MAXNODE];
    <span class="hljs-keyword">int</span> lv_count[MAXNODE];
    <span class="hljs-keyword">int</span> from_edge[MAXNODE];
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mark_r_level</span><span class="hljs-params">(<span class="hljs-keyword">int</span> end)</span> </span>{<font></font>
        fill(lv, lv + nv, nv);<font></font>
        fill(lv_count, lv_count + nv, <span class="hljs-number">0</span>);
        <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<font></font>
<font></font>
        lv[end] = <span class="hljs-number">0</span>;<font></font>
        lv_count[lv[end]]++;<font></font>
        q.push(end);<font></font>
        <span class="hljs-keyword">while</span> (!q.empty()) {
            <span class="hljs-keyword">int</span> cur = q.front(); q.pop();
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie = last[cur]; ie != -<span class="hljs-number">1</span>; ) {
                <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie]; <font></font>
                ie = e.pre_edge;<font></font>
                <span class="hljs-keyword">int</span> to = e.to;
                <span class="hljs-keyword">if</span> (lv[to] != nv)
                    <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
                lv[to] = lv[cur] + <span class="hljs-number">1</span>;<font></font>
                lv_count[lv[to]]++;<font></font>
                q.push(to);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isap_gap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>{<font></font>
        mark_r_level(end); <span class="hljs-comment">// reverse bfs to get level of node</span><font></font>
<font></font>
        <span class="hljs-keyword">int</span> total_flow = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> cur = start;<font></font>
        from_edge[start] = -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (lv[start] &lt; nv) {
            <span class="hljs-keyword">if</span> (cur == end) {
                <span class="hljs-keyword">int</span> flow = INT_MAX;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = cur; x != start; ) { <span class="hljs-comment">// backtrack to get min cap along the path</span>
                    <span class="hljs-keyword">int</span> ie = from_edge[x];
                    <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie];<font></font>
                    flow = min(flow, e.cap - e.flow);<font></font>
                    x = edge[ie ^ <span class="hljs-number">1</span>].to;<font></font>
                }<font></font>
                <font></font>
                <span class="hljs-keyword">for</span> ( ; cur != start; ) { <span class="hljs-comment">// update the cap along the path</span>
                    <span class="hljs-keyword">int</span> ie = from_edge[cur];<font></font>
                    Edge&amp; e = edge[ie];<font></font>
                    Edge&amp; re = edge[ie ^ <span class="hljs-number">1</span>];<font></font>
                    e.flow += flow;<font></font>
                    re.flow -= flow;<font></font>
                    cur = re.to;<font></font>
                }<font></font>
                total_flow += flow;<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">bool</span> found = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie = last[cur]; ie != -<span class="hljs-number">1</span>; ) { <span class="hljs-comment">// find the next vertex</span>
                <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie]; 
                <span class="hljs-keyword">if</span> (e.cap != e.flow &amp;&amp; lv[cur] == lv[e.to] + <span class="hljs-number">1</span>) {<font></font>
                    cur = e.to;<font></font>
                    from_edge[cur] = ie; <span class="hljs-comment">// record the edge from which we comes</span>
                    found = <span class="hljs-literal">true</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
                }<font></font>
                ie = e.pre_edge;<font></font>
            }<font></font>
            <font></font>
            <span class="hljs-keyword">if</span> (found)
                <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
            lv_count[lv[cur]]--;<font></font>
            <span class="hljs-keyword">if</span> (lv_count[lv[cur]] == <span class="hljs-number">0</span>)
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">int</span> min_lv = nv;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie = last[cur]; ie != -<span class="hljs-number">1</span>; ) { <span class="hljs-comment">// find the min level around cur vertex</span>
                <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie]; <font></font>
                ie = e.pre_edge;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (e.cap != e.flow)<font></font>
                    min_lv = min(min_lv, lv[e.to]);<font></font>
            }<font></font>
<font></font>
            lv[cur] = min_lv + <span class="hljs-number">1</span>; <span class="hljs-comment">// raise level of cur vertex by 1</span><font></font>
            lv_count[lv[cur]]++;<font></font>
            <span class="hljs-keyword">if</span> (cur != start)<font></font>
                cur = edge[from_edge[cur] ^ <span class="hljs-number">1</span>].to; <span class="hljs-comment">// revert one step</span><font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> total_flow;<font></font>
    }<font></font>
    <span class="hljs-comment">// end of </span>
    <span class="hljs-comment">// maximum flow - isap + gap</span>
    <span class="hljs-comment">// </span><font></font>
};<font></font>
</code></pre>
<h4 class="code-line" data-line-start="4159" data-line-end="4160"><a id="553_MinimumCost_MaximumFlow_4159"></a>5.5.3 Minimum-Cost Maximum-Flow</h4>
<pre><code class="has-line-data" data-line-start="4162" data-line-end="4212"><span class="hljs-comment">// have not tested</span>
<span class="hljs-keyword">int</span> n_node;
<span class="hljs-keyword">int</span> n_edge;<font></font>
<font></font>
<span class="hljs-keyword">int</span> cost[<span class="hljs-number">405</span>][<span class="hljs-number">405</span>]; <span class="hljs-comment">// cost[i][j] = -cost[j][i]</span>
<span class="hljs-keyword">int</span> residual[<span class="hljs-number">405</span>][<span class="hljs-number">405</span>];<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; flow_sum, <span class="hljs-keyword">int</span>&amp;cost_sum)</span> </span>{ <span class="hljs-comment">// 0: start, n_node - 1: end</span>
    <span class="hljs-keyword">int</span> min_cost[<span class="hljs-number">405</span>]; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n_node; i++) min_cost[i] = INT_MAX; min_cost[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> pre_node[<span class="hljs-number">405</span>]; pre_node[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> max_flow[<span class="hljs-number">405</span>];
    <span class="hljs-keyword">int</span> in_queue[<span class="hljs-number">405</span>]; <span class="hljs-built_in">memset</span>(in_queue, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(in_queue));<font></font>
<font></font>
    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<font></font>
    q.push(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">while</span> (q.size()) {
        <span class="hljs-keyword">int</span> cur = q.front(); q.pop();<font></font>
        in_queue[cur] = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n_node; i++) {
            <span class="hljs-keyword">if</span> (residual[cur][i] &gt; <span class="hljs-number">0</span> &amp;&amp; min_cost[i] &gt; min_cost[cur] + cost[cur][i]) {<font></font>
                min_cost[i] = min_cost[cur] + cost[cur][i];<font></font>
                pre_node[i] = cur;<font></font>
                max_flow[i] = min(max_flow[cur], residual[cur][i]);<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (in_queue[i] == <span class="hljs-number">0</span>) {<font></font>
                    in_queue[i] = <span class="hljs-number">1</span>;<font></font>
                    q.push(i);<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (min_cost[n_node - <span class="hljs-number">1</span>] == INT_MAX)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    flow_sum += max_flow[n_node - <span class="hljs-number">1</span>];<font></font>
    cost_sum += max_flow[n_node - <span class="hljs-number">1</span>] * min_cost[n_node - <span class="hljs-number">1</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> cur = n_node - <span class="hljs-number">1</span>; cur != <span class="hljs-number">0</span>; cur = pre_node[cur]) {<font></font>
        residual[pre_node[cur]][cur] -= max_flow[n_node - <span class="hljs-number">1</span>];<font></font>
        residual[cur][pre_node[cur]] += max_flow[n_node - <span class="hljs-number">1</span>];<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">min_cost_max_flow</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> flow_sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> cost_sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (bellman_ford(flow_sum, cost_sum));
    <span class="hljs-built_in">cout</span> &lt;&lt; flow_sum &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; cost_sum &lt;&lt; endl;<font></font>
}<font></font>
</code></pre>
<h4 class="code-line" data-line-start="4213" data-line-end="4214"><a id="554_More_Applications_and_Properties_4213"></a>5.5.4 More Applications and Properties</h4>
<blockquote>
<p class="has-line-data" data-line-start="4215" data-line-end="4216">placeholder</p>
</blockquote>
<h3 class="code-line" data-line-start="4217" data-line-end="4218"><a id="56______4217"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.6 Cut points, bridges, and bi-connected components of strongly connected component graphs</font></font></h3>
<p class="has-line-data" data-line-start="4219" data-line-end="4220"><code>https://www.byvoid.com/blog/biconnect</code></p>
<blockquote>
<p class="has-line-data" data-line-start="4221" data-line-end="4222"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Point Connectivity and Edge Connectivity]</font></font></p>
<p class="has-line-data" data-line-start="4223" data-line-end="4224"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In an undirected connected graph, if there is a set of vertices, after deleting this set of vertices and the edges associated with all vertices in this set, the original graph becomes multiple connected blocks, and this set of points is called a set of cut points. </font><font style="vertical-align: inherit;">The point connectivity of a graph is defined as the number of vertices in the minimum cut point set.</font></font></p>
<p class="has-line-data" data-line-start="4225" data-line-end="4226"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Similarly, if there is an edge set, after deleting this edge set, the original graph becomes multiple connected blocks, and this point set is called a cut edge set. </font><font style="vertical-align: inherit;">The edge connectivity of a graph is defined as the number of edges in the minimum cut edge set.</font></font></p>
<p class="has-line-data" data-line-start="4227" data-line-end="4228"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Double connected graph, cut point and bridge]</font></font></p>
<p class="has-line-data" data-line-start="4229" data-line-end="4230"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the point connectivity of an undirected connected graph is greater than 1, then the graph is called point biconnected, or double connected or reconnected for short. </font><font style="vertical-align: inherit;">A graph has cut points, if and only if the point connectivity of this graph is 1, then the only element of the cut point set is called a cut point, also called an articulation point.</font></font></p>
<p class="has-line-data" data-line-start="4231" data-line-end="4232"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the edge connectivity of an undirected connected graph is greater than 1, then the graph is said to be edge biconnected, referred to as double connected or reconnected. </font><font style="vertical-align: inherit;">A graph has a bridge. If and only if the edge connectivity of this graph is 1, the only element of the cut edge set is called a bridge, also called an articulation edge.</font></font></p>
<p class="has-line-data" data-line-start="4233" data-line-end="4234"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It can be seen that both point double connectivity and edge double connectivity can be referred to as double connectivity, and there is a certain connection between them. The double connectivity mentioned below can both refer to both point double connectivity and edge double connectivity.</font></font></p>
<p class="has-line-data" data-line-start="4235" data-line-end="4236"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Dual Connected Branch]</font></font></p>
<p class="has-line-data" data-line-start="4237" data-line-end="4238"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In all subgraphs G'of graph G, if G'is bi-connected, then G'is called bi-connected subgraph. </font><font style="vertical-align: inherit;">If a bi-connected sub-graph G'is not a proper subset of any bi-connected sub-graph, then G'is a maximal bi-connected sub-graph. </font><font style="vertical-align: inherit;">The biconnected component, or reconnected component, is the maximal biconnected subgraph of the graph. </font><font style="vertical-align: inherit;">In particular, the point double connected branch is also called a block.</font></font></p>
<p class="has-line-data" data-line-start="4239" data-line-end="4240"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Seeking cut point and bridge]</font></font></p>
<p class="has-line-data" data-line-start="4241" data-line-end="4242"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The algorithm was invented by R. Tarjan. </font><font style="vertical-align: inherit;">For graph depth-first search, define DFS(u) as the sequence number to which u is traversed in the search tree (hereinafter referred to as the tree). </font><font style="vertical-align: inherit;">Define Low(u) as the earliest node in the subtree of u or u that can be traced back through non-parent-child edges, that is, the node with the smallest DFS sequence number. </font><font style="vertical-align: inherit;">By definition, there are:</font></font></p>
<p class="has-line-data" data-line-start="4243" data-line-end="4244"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Low(u)=Min {DFS(u) DFS(v) (u,v) is the backward edge (returning edge) is equivalent to DFS(v)&lt;DFS(u) and v is not the parent node of u Low (v) (u,v) is the side of the branch (the side of the father and the child)}</font></font></p>
<p class="has-line-data" data-line-start="4245" data-line-end="4246"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A vertex u is the cut point, if and only if (1) or (2) (1) u is the root of the tree, and u has more than one subtree. </font><font style="vertical-align: inherit;">(2) u is not a tree root, and satisfies the existence of (u,v) as a branch edge (or parent-child edge, that is, u is the father of v in the search tree), so that DFS(u)&lt;=Low(v).</font></font></p>
<p class="has-line-data" data-line-start="4247" data-line-end="4248"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An undirected edge (u, v) is a bridge if and only if (u, v) is a branch edge and satisfies DFS(u)&lt;Low(v).</font></font></p>
<p class="has-line-data" data-line-start="4249" data-line-end="4250"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Find double connected components]</font></font></p>
<p class="has-line-data" data-line-start="4251" data-line-end="4252"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the following, we will separately discuss the solution of point double connected components and edge double connected components.</font></font></p>
<p class="has-line-data" data-line-start="4253" data-line-end="4254"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For point bi-connected components, in fact, in the process of finding the cut point, we can find out the bi-connected components of each point by the way. </font><font style="vertical-align: inherit;">Create a stack to store the current dual-connected branches. When searching the graph, every time a branch edge or backward edge (not a horizontal cross edge) is found, this edge is added to the stack. </font><font style="vertical-align: inherit;">If DFS(u)&lt;=Low(v) is met at a certain time, it means that u is a cut point, and the edges are taken out one by one from the top of the stack at the same time, until edges (u,v) are encountered, these edges are associated with it The points form a double-connected branch of points. </font><font style="vertical-align: inherit;">The cut point can belong to multiple point bi-connected branches, and the remaining points and each edge only belong to and belong to one point double-connected branch.</font></font></p>
<p class="has-line-data" data-line-start="4255" data-line-end="4256"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For edge bi-connected components, the method is simpler. </font><font style="vertical-align: inherit;">Just after finding all the bridges, delete the edges of the bridges, the original graph becomes multiple connected blocks, then each connected block is an edge dual connected branch. </font><font style="vertical-align: inherit;">The bridge does not belong to any bi-connected branch of edges. The remaining edges and each vertex belong to and belong to only one bi-connected branch of edges.</font></font></p>
<p class="has-line-data" data-line-start="4257" data-line-end="4258"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Construct a bi-connected graph]</font></font></p>
<p class="has-line-data" data-line-start="4259" data-line-end="4260"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A connected graph with a bridge, how to turn it into an edge bi-connected graph by adding edges? </font><font style="vertical-align: inherit;">The method is to first find all the bridges, then delete these bridge edges, and each remaining connected block is a bi-connected subgraph. </font><font style="vertical-align: inherit;">Shrink each bi-connected subgraph to a vertex, and then add back the bridge edges. The final graph must be a tree with edge connectivity of 1.</font></font></p>
<p class="has-line-data" data-line-start="4261" data-line-end="4262"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Count the number of nodes with degree 1 in the tree, that is, the number of leaf nodes, and record it as leaf. </font><font style="vertical-align: inherit;">Then add at least (leaf+1)/2 edges to the tree to make the tree reach the second connected edge, so at least the number of edges added is (leaf+1)/2. </font><font style="vertical-align: inherit;">The specific method is to first connect an edge between the two leaf nodes that are the farthest from the two nearest common ancestors, so that all points on the path from these two points to the ancestors can be contracted together, because a ring formed must be a double Connected. </font><font style="vertical-align: inherit;">Then find the two leaf nodes that are the farthest from the two nearest common ancestors, so that the one-by-one search is completed, which happens to be (leaf+1)/2 times, shrinking all the points together.</font></font></p>
</blockquote>
<p class="has-line-data" data-line-start="4263" data-line-end="4264">find articulation point (cut vertex) / bridge (cutedge) in directed / undirected graph</p>
<p class="has-line-data" data-line-start="4265" data-line-end="4266">find and merge biconnected component in undirected graph</p>
<p class="has-line-data" data-line-start="4267" data-line-end="4268">find and merge strongly connected component in directed graph</p>
<p class="has-line-data" data-line-start="4270" data-line-end="4271">time complexity <code>O(E+V)</code></p>
<pre><code class="has-line-data" data-line-start="4273" data-line-end="4383"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> NN <span class="hljs-number">20002</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MM <span class="hljs-number">100002</span></span><font></font>
<font></font>
<span class="hljs-keyword">int</span> n;
<span class="hljs-keyword">int</span> m;<font></font>
<font></font>
<span class="hljs-keyword">int</span> visit_order[NN];
<span class="hljs-keyword">int</span> smallest_order_can_reach[NN];
<span class="hljs-keyword">int</span> parent[NN];
<span class="hljs-keyword">int</span> in_stack[NN];
<span class="hljs-keyword">int</span> temp_component[NN];<font></font>
<font></font>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; g[NN];<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; component)</span> </span>{
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; out_vertex;
    <span class="hljs-keyword">int</span> new_vertex = component.back();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : component)<font></font>
        temp_component[v] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : component) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> o : g[v]) {
            <span class="hljs-keyword">if</span> (!temp_component[o])<font></font>
                out_vertex.push_back(o);<font></font>
        }<font></font>
        g[v].clear();<font></font>
        g[v].push_back(new_vertex);<font></font>
    }<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : component)<font></font>
        temp_component[v] = <span class="hljs-number">0</span>;<font></font>
<font></font>
    <span class="hljs-comment">// use last vertex in the component as new vertex</span><font></font>
    g[new_vertex] = out_vertex;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur)</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> order = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">static</span> <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; s;<font></font>
<font></font>
    visit_order[cur] = smallest_order_can_reach[cur] = ++order;<font></font>
    s.push(cur);<font></font>
    in_stack[cur] = <span class="hljs-number">1</span>;<font></font>
<font></font>
    <span class="hljs-keyword">int</span> subtree = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> next : g[cur]) {
        <span class="hljs-keyword">if</span> (visit_order[next] == <span class="hljs-number">0</span>) {<font></font>
            subtree++;<font></font>
            parent[next] = cur;<font></font>
            dfs(next);<font></font>
            smallest_order_can_reach[cur] = min(smallest_order_can_reach[cur], smallest_order_can_reach[next]);<font></font>
<font></font>
            <span class="hljs-comment">// if cur is root, and subtree &gt; 1</span>
            <span class="hljs-comment">// it is an articulation point</span>
            <span class="hljs-keyword">if</span> (visit_order[cur] == <span class="hljs-number">1</span> &amp;&amp; subtree &gt; <span class="hljs-number">1</span>)<font></font>
                ;<font></font>
<font></font>
            <span class="hljs-comment">// if cur is not root, and next cannot reach smaller vertex</span>
            <span class="hljs-comment">// it is an articulation point</span>
            <span class="hljs-keyword">if</span> (visit_order[cur] != <span class="hljs-number">1</span> &amp;&amp; visit_order[cur] &lt;= smallest_order_can_reach[next])<font></font>
                ;<font></font>
<font></font>
            <span class="hljs-comment">// if cannot use this edge to reach a smaller vertex</span>
            <span class="hljs-comment">// it is a bridge</span>
            <span class="hljs-keyword">if</span> (visit_order[cur] &lt; smallest_order_can_reach[next])<font></font>
                ;<font></font>
        }<font></font>
<font></font>
            <span class="hljs-comment">// for undirected graph</span>
            <span class="hljs-comment">// update the smallness of vertex that can reach</span>
<span class="hljs-comment">//        else if (next != parent[cur])</span>
<span class="hljs-comment">//            smallest_order_can_reach[cur] = min(smallest_order_can_reach[cur], visit_order[next]);</span><font></font>
<font></font>
            <span class="hljs-comment">// for directed graph</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (in_stack[next])<font></font>
            smallest_order_can_reach[cur] = min(smallest_order_can_reach[cur], visit_order[next]);<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">if</span> (visit_order[cur] == smallest_order_can_reach[cur]) {
        <span class="hljs-comment">// because visit_order[cur] == smallest_order_can_reach[cur]</span>
        <span class="hljs-comment">// and visit_order[cur] &gt; visit_order[parent[cur]]</span>
        <span class="hljs-comment">// so visit_order[parent[cur]] &lt; smallest_order_can_reach[cur]</span>
        <span class="hljs-comment">// so cur-parent[cur] is a bridge</span>
        <span class="hljs-comment">// cur is root of the biconnected component</span>
        <span class="hljs-comment">// so pop all util cur</span><font></font>
<font></font>
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; component;
        <span class="hljs-keyword">int</span> min_vertex = s.top();
        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
            <span class="hljs-keyword">int</span> vertex = s.top(); s.pop();<font></font>
            in_stack[vertex] = <span class="hljs-number">0</span>;<font></font>
            min_vertex = min(min_vertex, vertex);<font></font>
            component.push_back(vertex);<font></font>
            <span class="hljs-keyword">if</span> (vertex == cur)
                <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
        <span class="hljs-comment">// cur is the last vertex in the component</span><font></font>
        merge(component);<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {
        <span class="hljs-keyword">int</span> a, b;
        <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b;<font></font>
        g[a].push_back(b);<font></font>
    }<font></font>
<font></font>
    dfs(<span class="hljs-number">1</span>);<font></font>
}<font></font>
</code></pre>
<h3 class="code-line" data-line-start="4384" data-line-end="4385"><a id="57_Topological_Sort___4384"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.7 Topological Sort / Topological Sort</font></font></h3>
<blockquote>
<p class="has-line-data" data-line-start="4386" data-line-end="4387">Topological Sorting on Directed Acyclic Graph (DAG)</p>
<p class="has-line-data" data-line-start="4388" data-line-end="4389"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time complexity </font></font><code>O(N)</code></p>
</blockquote>
<pre><code class="has-line-data" data-line-start="4391" data-line-end="4458"><span class="hljs-keyword">struct</span> Graph {
    <span class="hljs-keyword">struct</span> Edge {
        <span class="hljs-keyword">int</span> to;<font></font>
    };<font></font>
<font></font>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAXNODE = <span class="hljs-number">3</span> * <span class="hljs-number">1e5</span> + <span class="hljs-number">2</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; g[MAXNODE];
    <span class="hljs-built_in">vector</span>&lt;Edge&gt; edge;
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nn)</span> </span>{<font></font>
        n = nn;<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<font></font>
            g[i].clear();<font></font>
        edge.clear();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_e</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{<font></font>
        Edge e = {y};<font></font>
        g[x].push_back(edge.size());<font></font>
        edge.push_back(e);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d:"</span>, i);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie : g[i])
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>, edge[ie].to);
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
        }<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// Node index ~ [0, N)</span>
    <span class="hljs-comment">// matters for topological sort</span>
    <span class="hljs-comment">// </span>
    <span class="hljs-keyword">int</span> in_order[MAXNODE];
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_in_order</span><span class="hljs-params">()</span> </span>{<font></font>
        fill_n(in_order, n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie : g[i])<font></font>
                in_order[edge[ie].to]++;<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">topological_sort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; result)</span> </span>{<font></font>
        init_in_order();<font></font>
        <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
            <span class="hljs-keyword">if</span> (in_order[i] == <span class="hljs-number">0</span>)<font></font>
                q.push(i);<font></font>
        <span class="hljs-keyword">while</span> (q.size()) {
            <span class="hljs-keyword">int</span> cur = q.front(); q.pop();<font></font>
            result.push_back(cur);<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie : g[cur]) {
                <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie];<font></font>
                in_order[e.to]--;<font></font>
                <span class="hljs-keyword">if</span> (in_order[e.to] == <span class="hljs-number">0</span>)<font></font>
                    q.push(e.to);<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> result.size() == n;<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_order</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"in_order[%d] = %d\n"</span>, i, in_order[i]);<font></font>
    }<font></font>
};<font></font>
</code></pre>
<h3 class="code-line" data-line-start="4460" data-line-end="4461"><a id="58_Euler_CyclePath_Hamilton_CyclePath_4460"></a>5.8 Euler Cycle/Path, Hamilton Cycle/Path</h3>
<blockquote>
<p class="has-line-data" data-line-start="4462" data-line-end="4463">place holder</p>
</blockquote>
<h3 class="code-line" data-line-start="4464" data-line-end="4465"><a id="59_find_negative_weight_Cycle_on_a_graph_4464"></a>5.9 find negative (weight) Cycle on a graph</h3>
<blockquote>
<p class="has-line-data" data-line-start="4466" data-line-end="4467"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">place holder</font></font></p>
</blockquote>
<h2 class="code-line" data-line-start="4469" data-line-end="4470"><a id="6_Number__Mathematics_4469"></a>6. Number + Mathematics</h2>
<h3 class="code-line" data-line-start="4471" data-line-end="4472"><a id="61_BigInteger__BigDecimal_4471"></a>6.1 BigInteger + BigDecimal</h3>
<h4 class="code-line" data-line-start="4473" data-line-end="4474"><a id="611_C_Big_Integer_4473"></a>6.1.1 C++ Big Integer</h4>
<pre><code class="has-line-data" data-line-start="4476" data-line-end="4621"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> BASE_LENGTH = <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> BASE = (<span class="hljs-keyword">int</span>) <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, BASE_LENGTH);
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_LENGTH = <span class="hljs-number">500</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">int_to_string</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">bool</span> zero)</span> </span>{
    <span class="hljs-built_in">string</span> res = <span class="hljs-string">""</span>;
    <span class="hljs-keyword">while</span> (width--) {
        <span class="hljs-keyword">if</span> (!zero &amp;&amp; i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<font></font>
        res = (<span class="hljs-keyword">char</span>)(i%<span class="hljs-number">10</span> + <span class="hljs-string">'0'</span>) + res;<font></font>
        i /= <span class="hljs-number">10</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> res;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">struct</span> bigint {
    <span class="hljs-keyword">int</span> len, s[MAX_LENGTH];<font></font>
<font></font>
    bigint() {  <font></font>
        <span class="hljs-built_in">memset</span>(s, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(s));  <font></font>
        len = <span class="hljs-number">1</span>;  <font></font>
    }<font></font>
<font></font>
    bigint(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> num) {<font></font>
        len = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (num &gt;= BASE) {<font></font>
            s[len] = num % BASE;<font></font>
            num /= BASE;<font></font>
            len ++;<font></font>
        }<font></font>
        s[len++] = num;<font></font>
    }<font></font>
<font></font>
    bigint(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* num) {
        <span class="hljs-keyword">int</span> l = <span class="hljs-built_in">strlen</span>(num);<font></font>
        len = l/BASE_LENGTH;<font></font>
        <span class="hljs-keyword">if</span> (l % BASE_LENGTH) len++;
        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = l - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -= BASE_LENGTH) {
            <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">int</span> k = i - BASE_LENGTH + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">0</span>) k = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = k; j &lt;= i; j++) {<font></font>
                tmp = tmp*<span class="hljs-number">10</span> + num[j] - <span class="hljs-string">'0'</span>;<font></font>
            }<font></font>
            s[index++] = tmp;<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clean</span><span class="hljs-params">()</span> </span>{  
        <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">1</span> &amp;&amp; !s[len-<span class="hljs-number">1</span>]) len--;  <font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">str</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-built_in">string</span> ret = <span class="hljs-string">""</span>;
        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span> &amp;&amp; !s[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> <span class="hljs-string">"0"</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) {<font></font>
                ret += int_to_string(s[len - i - <span class="hljs-number">1</span>], BASE_LENGTH, <span class="hljs-literal">false</span>);<font></font>
            } <span class="hljs-keyword">else</span> {<font></font>
                ret += int_to_string(s[len - i - <span class="hljs-number">1</span>], BASE_LENGTH, <span class="hljs-literal">true</span>);<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> ret;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">ll</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ret = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = len-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<font></font>
            ret *= BASE;<font></font>
            ret += s[i];<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> ret;<font></font>
    }<font></font>
<font></font>
    bigint <span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">const</span> bigint&amp; b) <span class="hljs-keyword">const</span> {<font></font>
        bigint c = b;<font></font>
        <span class="hljs-keyword">while</span> (c.len &lt; len) c.s[c.len++] = <span class="hljs-number">0</span>;<font></font>
        c.s[c.len++] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">bool</span> r = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len || r; i++) {<font></font>
            c.s[i] += (i&lt;len)*s[i] + r;<font></font>
            r = c.s[i] &gt;= BASE;<font></font>
            <span class="hljs-keyword">if</span> (r) c.s[i] -= BASE;<font></font>
        }<font></font>
        c.clean();<font></font>
        <span class="hljs-keyword">return</span> c;<font></font>
    }<font></font>
<font></font>
    bigint <span class="hljs-keyword">operator</span> - (<span class="hljs-keyword">const</span> bigint&amp; b) <span class="hljs-keyword">const</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">operator</span> &lt; (b)) <span class="hljs-keyword">throw</span> <span class="hljs-string">"cannot do subtract"</span>;<font></font>
        bigint c = *<span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">bool</span> r = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; b.len || r; i++) {<font></font>
            c.s[i] -= b.s[i];<font></font>
            r = c.s[i] &lt; <span class="hljs-number">0</span>;
            <span class="hljs-keyword">if</span> (r) c.s[i] += BASE;<font></font>
        }<font></font>
        c.clean();<font></font>
        <span class="hljs-keyword">return</span> c;<font></font>
    }<font></font>
<font></font>
    bigint <span class="hljs-keyword">operator</span> * (<span class="hljs-keyword">const</span> bigint&amp; b) <span class="hljs-keyword">const</span> {  <font></font>
        bigint c;<font></font>
        c.len = len + b.len;  <font></font>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)  
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; b.len; j++)  <font></font>
                c.s[i+j] += s[i] * b.s[j];  <font></font>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; c.len-<span class="hljs-number">1</span>; i++){  <font></font>
            c.s[i+<span class="hljs-number">1</span>] += c.s[i] / BASE;  <font></font>
            c.s[i] %= BASE;  <font></font>
        }  <font></font>
        c.clean();  <font></font>
        <span class="hljs-keyword">return</span> c;  <font></font>
    }<font></font>
<font></font>
    bigint <span class="hljs-keyword">operator</span> / (<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b) <span class="hljs-keyword">const</span> {<font></font>
        bigint ret;<font></font>
        <span class="hljs-keyword">int</span> down = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<font></font>
            ret.s[i] = (s[i] + down * BASE) / b;<font></font>
            down = s[i] + down * BASE - ret.s[i] * b;<font></font>
        }<font></font>
        ret.len = len;<font></font>
        ret.clean();<font></font>
        <span class="hljs-keyword">return</span> ret;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> bigint&amp; b) <span class="hljs-keyword">const</span> {
        <span class="hljs-keyword">if</span> (len &lt; b.len) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len &gt; b.len) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)
            <span class="hljs-keyword">if</span> (s[i] &lt; b.s[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] &gt; b.s[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-keyword">const</span> bigint&amp; b) <span class="hljs-keyword">const</span> {
        <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span>&lt;b) &amp;&amp; !(b&lt;(*<span class="hljs-keyword">this</span>));<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &gt; (<span class="hljs-keyword">const</span> bigint&amp; b) <span class="hljs-keyword">const</span> {
        <span class="hljs-keyword">return</span> b &lt; *<span class="hljs-keyword">this</span>;<font></font>
    }<font></font>
};<font></font>
</code></pre>
<p class="has-line-data" data-line-start="4622" data-line-end="4623">Examples</p>
<pre><code class="has-line-data" data-line-start="4625" data-line-end="4640">ASSERT((a+b).str()==<span class="hljs-string">"10001"</span>)<font></font>
ASSERT((a+b)==bigint(<span class="hljs-number">10001</span>))<font></font>
ASSERT((b/<span class="hljs-number">2</span>)==<span class="hljs-number">4999</span>)<font></font>
ASSERT(c == <span class="hljs-number">12345</span>)<font></font>
ASSERT(c &lt; <span class="hljs-number">123456</span>)<font></font>
ASSERT(c &gt; <span class="hljs-number">123</span>)<font></font>
ASSERT(!(c &gt; <span class="hljs-number">123456</span>))<font></font>
ASSERT(!(c &lt; <span class="hljs-number">123</span>))<font></font>
ASSERT(!(c == <span class="hljs-number">12346</span>))<font></font>
ASSERT(!(c == <span class="hljs-number">12344</span>))<font></font>
ASSERT(c.str() == <span class="hljs-string">"12345"</span>)<font></font>
ASSERT((b-<span class="hljs-number">1</span>)==<span class="hljs-number">9998</span>)<font></font>
ASSERT(a.ll() == <span class="hljs-number">2</span>)<font></font>
ASSERT(b.ll() == <span class="hljs-number">9999</span>)
</code></pre>
<h4 class="code-line" data-line-start="4642" data-line-end="4643"><a id="612_The_Java_Approach_4642"></a>6.1.2 The Java Approach</h4>
<p class="has-line-data" data-line-start="4644" data-line-end="4645">BigInteger &amp; BigDecimal</p>
<h3 class="code-line" data-line-start="4646" data-line-end="4647"><a id="62_Matrix_4646"></a>6.2 Matrix</h3>
<pre><code class="has-line-data" data-line-start="4649" data-line-end="4652"><span class="hljs-keyword">operator</span>+
<span class="hljs-keyword">operator</span>*
</code></pre>
<blockquote>
<p class="has-line-data" data-line-start="4653" data-line-end="4654">Square matrix</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="4656" data-line-end="4712">
<span class="hljs-keyword">struct</span> Matrix {
    <span class="hljs-comment">// int height;</span>
    <span class="hljs-comment">// int width;</span><font></font>
<font></font>
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> value[<span class="hljs-number">32</span>][<span class="hljs-number">32</span>];<font></font>
<font></font>
    Matrix <span class="hljs-keyword">operator</span>* (<span class="hljs-keyword">const</span> Matrix&amp; that);<font></font>
    Matrix <span class="hljs-keyword">operator</span>+ (<span class="hljs-keyword">const</span> Matrix&amp; that);
    <span class="hljs-function">Matrix <span class="hljs-title">mirror</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">cout</span> &lt;&lt; endl;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)
                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;value[i][j] &lt;&lt; <span class="hljs-string">" "</span>;
            <span class="hljs-built_in">cout</span> &lt;&lt; endl;<font></font>
        }<font></font>
    }<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mod_it</span><span class="hljs-params">(Matrix&amp; temp)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<font></font>
            temp.value[i][j] %= m;<font></font>
}<font></font>
<font></font>
Matrix Matrix::<span class="hljs-keyword">operator</span>* (<span class="hljs-keyword">const</span> Matrix&amp; that) {<font></font>
    Matrix temp;<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) {<font></font>
            temp.value[i][j] = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; n; k++)<font></font>
                temp.value[i][j] += <span class="hljs-keyword">this</span>-&gt;value[i][k] * that.value[k][j];<font></font>
        }<font></font>
    }<font></font>
    mod_it(temp);<font></font>
    <span class="hljs-keyword">return</span> temp;<font></font>
}<font></font>
<font></font>
Matrix Matrix::<span class="hljs-keyword">operator</span>+ (<span class="hljs-keyword">const</span> Matrix&amp; that) {<font></font>
    Matrix temp;<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<font></font>
            temp.value[i][j] = <span class="hljs-keyword">this</span>-&gt;value[i][j] + that.value[i][j];<font></font>
    mod_it(temp);<font></font>
    <span class="hljs-keyword">return</span> temp;<font></font>
}<font></font>
<font></font>
Matrix Matrix::mirror() {<font></font>
    Matrix temp;<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<font></font>
            temp.value[i][j] = <span class="hljs-keyword">this</span>-&gt;value[i][j];
    <span class="hljs-keyword">return</span> temp;<font></font>
}<font></font>
</code></pre>
<h3 class="code-line" data-line-start="4713" data-line-end="4714"><a id="63_Number_Theory_4713"></a>6.3 Number Theory</h3>
<h4 class="code-line" data-line-start="4715" data-line-end="4716"><a id="631___4715"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.1 Euler function?</font></font></h4>
<h4 class="code-line" data-line-start="4717" data-line-end="4718"><a id="632___gcd_4717"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.2 Euclid's algorithm/gcd</font></font></h4>
<pre><code class="has-line-data" data-line-start="4720" data-line-end="4732"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a % b);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
   <span class="hljs-keyword">if</span>(gcd(a,b)&gt;<span class="hljs-number">0</span>){ 
    <span class="hljs-keyword">return</span> (a / gcd(a, b)) * b;<font></font>
   }<font></font>
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
   <font></font>
}<font></font>
</code></pre>
<h4 class="code-line" data-line-start="4733" data-line-end="4734"><a id="633__4733"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.3 Extended Euclidean Algorithm</font></font></h4>
<p class="has-line-data" data-line-start="4735" data-line-end="4736"><code>http://www.cnblogs.com/frog112111/archive/2012/08/19/2646012.html</code></p>
<blockquote>
<p class="has-line-data" data-line-start="4737" data-line-end="4738"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For non-negative integers a, b that are not completely 0, there must be an integer pair (x, y), such that gcd(a, b) = ax + by</font></font></p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4739" data-line-end="4740">suppose: a &gt; b, we want to get (x1, y1)</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4741" data-line-end="4742">(i) if b == 0, then gcd(a, b) = a = ax + 0, then x1 = 1, y1 = 0</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4743" data-line-end="4744">(ii) if b != 0:</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4745" data-line-end="4746">(1): a * x1 + b * y1 = gcd(a, b)</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4747" data-line-end="4748">(2): b * x2 + (a % b) * y2 = gcd(b, a % b)</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4749" data-line-end="4750">(1) == (2)</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4751" data-line-end="4752">so: a * x1 + b * y1 = b * x2 + (a % b) * y2</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4753" data-line-end="4754">so: a * x1 + b * y1 = b * x2 + (a - (int)(a / b) * b) * y2</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4755" data-line-end="4756">so: a * x1 + b * y1 = a * y2 + b * (x2 - (int)(a / b) * y2)</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4757" data-line-end="4758">so: x1 = y2, y1 = x2 - (int)(a / b) * y2, can get (x1, y1) from (x2, y2)</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4759" data-line-end="4760">next:</p>
</blockquote>
<blockquote>
<pre><code>  (1): b * x2 + (a % b) * y2 = gcd(b, a % b)
</code></pre>
</blockquote>
<blockquote>
<pre><code>  (2): (a % b) * x3 + b % (a % b) * y3 = gcd(a % b, b % (a % b))
</code></pre>
</blockquote>
<blockquote>
<pre><code>  so: can get (x2, y2) from (x3, y3)
</code></pre>
</blockquote>
<blockquote>
<pre><code>  next: ... until in gcd(a, b), b == 0, then xi = 1, yi = 0, go back ...
</code></pre>
</blockquote>
<pre><code class="has-line-data" data-line-start="4770" data-line-end="4798"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ansx, ansy, ansd;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">euclidean</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b)</span> </span>{
    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) {<font></font>
        ansx = <span class="hljs-number">1</span>;<font></font>
        ansy = <span class="hljs-number">0</span>;<font></font>
        ansd = a;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
        euclidean(b, a % b);<font></font>
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> temp = ansx;<font></font>
        ansx = ansy;<font></font>
        ansy = temp - a / b * ansy;<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])</span> </span>{
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a, b, c;
    <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;<font></font>
<font></font>
    ansx = <span class="hljs-number">0</span>;<font></font>
    ansy = <span class="hljs-number">0</span>;<font></font>
    ansd = <span class="hljs-number">0</span>;<font></font>
    euclidean(a, b);<font></font>
<font></font>
    <span class="hljs-comment">// now (ansx, ansy) is the answer (x, y) for a * x1 + b * y1 = gcd(a, b)</span>
    <span class="hljs-comment">// ansd is the a when b == 0, which is just gcd(a, b)</span><font></font>
}<font></font>
</code></pre>
<h4 class="code-line" data-line-start="4799" data-line-end="4800"><a id="634__4799"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.4 Solving indeterminate equations</font></font></h4>
<blockquote>
<p class="has-line-data" data-line-start="4801" data-line-end="4802">for: p * a + q * b = c</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4803" data-line-end="4804"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if c% gcd(a, b) == 0, then has an integer solution (p, q), else NO</font></font></p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4806" data-line-end="4807">if we get (p0, q0) for p0 * a + q0 * b = gcd(a, b)</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4808" data-line-end="4809">then: for p * a + q * b = gcd(a, b) (k is any integer)</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4810" data-line-end="4811">p = p0 + b / gcd(a, b) * k</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4812" data-line-end="4813">q = q0 - a / gcd(a, b) * k</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4815" data-line-end="4816">then: for p * a + q * b = c = c / gcd(a, b) * gcd(a, b) (k is any integer)</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4817" data-line-end="4818">p = (p0 + b / gcd(a, b) * k) * c / gcd(a, b)</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4819" data-line-end="4820">q = (q0 - a / gcd(a, b) * k) * c / gcd(a, b)</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="4822" data-line-end="4828"><span class="hljs-comment">// after get ansx, ansy, ansd</span>
<span class="hljs-comment">// test if c % ansd == 0</span>
<span class="hljs-comment">// ansx = (ansx + b / gcd(a, b) * k) * c / gcd(a, b)</span>
<span class="hljs-comment">// ansy = (ansy - a / gcd(a, b) * k) * c / gcd(a, b)</span>
<span class="hljs-comment">// smallest: ansx % (b / gcd(a, b) + b / gcd(a, b)) % (b / gcd(a, b))</span>
</code></pre>
<h4 class="code-line" data-line-start="4829" data-line-end="4830"><a id="635__4829"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.5 Solve modular linear equations (linear congruence equations)</font></font></h4>
<blockquote>
<p class="has-line-data" data-line-start="4831" data-line-end="4832">(a * x) % n = b % n, x = ?</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4833" data-line-end="4834">same as: a * x + n * y= b</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4835" data-line-end="4836">so: one answer for a * x + n * y= b is: x * b / gcd(a, n)</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4837" data-line-end="4838">so: one answer for (a * x) % n = b % n is: x0 = (x * b / gcd(a, n)) % n</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4839" data-line-end="4840">other answer xi = (x0 + i * (n / gcd(a, n))) % n, i = 0…gcd(a, n)-1</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4841" data-line-end="4842">smallest answer is x0 % (n / gcd(a, n) + gcd(a, n)) % gcd(a, n)</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="4844" data-line-end="4845"></code></pre>
<h4 class="code-line" data-line-start="4846" data-line-end="4847"><a id="636__4846"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.6 Solve the inverse element of the module</font></font></h4>
<blockquote>
<p class="has-line-data" data-line-start="4848" data-line-end="4849">(a * x) % n = 1, x = ?</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4850" data-line-end="4851">if gcd(a, n) != 1, then NO answer</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4852" data-line-end="4853">else:</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4854" data-line-end="4855">same as: a * x + n * y = 1</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="4856" data-line-end="4857">can get only one answer x</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="4859" data-line-end="4863"><span class="hljs-comment">// after get ansx, ansy, ansd</span>
<span class="hljs-comment">// if ansd != 1, then NO answer</span>
<span class="hljs-comment">// smallest ansx = (ansx % (n / gcd(a, n)) + (n / gcd(a, n))) % (n / gcd(a, n))</span>
</code></pre>
<h4 class="code-line" data-line-start="4864" data-line-end="4865"><a id="637__4864"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.7 The Chinese Remainder Theorem</font></font></h4>
<h4 class="code-line" data-line-start="4866" data-line-end="4867"><a id="638__4866"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.8 Least common multiple</font></font></h4>
<pre><code class="has-line-data" data-line-start="4869" data-line-end="4871">a / gcd(a, b) * b
</code></pre>
<h4 class="code-line" data-line-start="4872" data-line-end="4873"><a id="639__4872"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.9 Decompose prime factors</font></font></h4>
<pre><code class="has-line-data" data-line-start="4875" data-line-end="4884"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x;
<span class="hljs-built_in">cin</span> &gt;&gt; x;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> factor = <span class="hljs-number">2</span>; x != <span class="hljs-number">1</span>; factor++) {
    <span class="hljs-keyword">if</span> (x % factor == <span class="hljs-number">0</span>)
        <span class="hljs-built_in">cout</span> &lt;&lt; factor &lt;&lt; <span class="hljs-string">" is a prime factor"</span> &lt;&lt; endl;
    <span class="hljs-keyword">while</span> (x % factor == <span class="hljs-number">0</span>)<font></font>
        x = x / factor;<font></font>
}<font></font>
</code></pre>
<h4 class="code-line" data-line-start="4885" data-line-end="4886"><a id="6310__4885"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.10 Number of factors</font></font></h4>
<pre><code class="has-line-data" data-line-start="4888" data-line-end="4891">n = p1 ^ x1 * p2 ^ x2 * ... * pn ^ xn<font></font>
total = (x1 + <span class="hljs-number">1</span>) * (x2 + <span class="hljs-number">1</span>) * ... * (xn + <span class="hljs-number">1</span>)
</code></pre>
<h4 class="code-line" data-line-start="4892" data-line-end="4893"><a id="6311__4892"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.11 Primality test</font></font></h4>
<blockquote>
<p class="has-line-data" data-line-start="4894" data-line-end="4895"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prime numbers greater than 3 can be expressed as 6n-1 or 6n + 1</font></font></p>
</blockquote>
<pre><code class="has-line-data" data-line-start="4897" data-line-end="4917"><span class="hljs-comment">// A prime number greater than 3 can be written in the form 6n - 1 or 6n + 1 </span>
<span class="hljs-comment">// This is of the order O(sqrt(n))  with reduced leading constant</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <font></font>
    }<font></font>
       <font></font>
    <span class="hljs-keyword">if</span> ((n == <span class="hljs-number">2</span>)||(n==<span class="hljs-number">3</span>)){
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">int</span> t = <span class="hljs-built_in">sqrt</span>(n);
    <span class="hljs-keyword">int</span> k = t / <span class="hljs-number">6</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=k; i++){
        <span class="hljs-keyword">if</span>((n%(<span class="hljs-number">6</span>*t - <span class="hljs-number">1</span>)==<span class="hljs-number">0</span>)||(n%(<span class="hljs-number">6</span>*t + <span class="hljs-number">1</span>)==<span class="hljs-number">0</span>)){
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre>
<h5 class="code-line" data-line-start="4918" data-line-end="4919"><a id="63111_Miller_Rabin_Primality_Test_4918"></a>6.3.11.1 Miller Rabin Primality Test</h5>
<blockquote>
<p class="has-line-data" data-line-start="4920" data-line-end="4921"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (k (logN) ^ 3)</font></font></p>
</blockquote>
<pre><code class="has-line-data" data-line-start="4923" data-line-end="4988"><span class="hljs-keyword">class</span> MillerRabin { <span class="hljs-comment">// O(k(logX)^3)</span>
    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">mulmod</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c)</span> </span>{
        <span class="hljs-keyword">if</span> (a &lt; b)<font></font>
            swap(a, b);<font></font>
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>, x = a;
        <span class="hljs-keyword">while</span> (b &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) {<font></font>
                res = res + x;<font></font>
                <span class="hljs-keyword">if</span> (res &gt;= c)<font></font>
                    res -= c;<font></font>
            }<font></font>
            x = x * <span class="hljs-number">2</span>;
            <span class="hljs-keyword">if</span> (x &gt;= c)<font></font>
                x -= c;<font></font>
            b &gt;&gt;= <span class="hljs-number">1</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> res % c;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">bigmod</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> p, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> mod)</span> </span>{
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x = a, res = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (p) {
            <span class="hljs-keyword">if</span> (p &amp; <span class="hljs-number">1</span>)<font></font>
                res = mulmod(res, x, mod);<font></font>
            x = mulmod(x, x, mod);<font></font>
            p &gt;&gt;= <span class="hljs-number">1</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> res;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">witness</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> d, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> s, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n)</span> </span>{
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> r = bigmod(a, d, n);
        <span class="hljs-keyword">if</span> (r == <span class="hljs-number">1</span> || r == n - <span class="hljs-number">1</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s - <span class="hljs-number">1</span>; i++) {<font></font>
            r = mulmod(r, r, n);<font></font>
            <span class="hljs-keyword">if</span> (r == <span class="hljs-number">1</span>)
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span> (r == n - <span class="hljs-number">1</span>)
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
    }<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; aaa{<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">23</span>, <span class="hljs-number">29</span>, <span class="hljs-number">31</span>, <span class="hljs-number">37</span>}; <span class="hljs-comment">// enough for N &lt; 2^64</span><font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n)</span> </span>{
        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
<font></font>
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> p = n - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> s = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (!(p &amp; <span class="hljs-number">1</span>)) {<font></font>
            p /= <span class="hljs-number">2</span>;<font></font>
            s++;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; aaa.size() &amp;&amp; aaa[i] &lt; n; i++)
            <span class="hljs-keyword">if</span> (witness(aaa[i], p, s, n))
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
    }<font></font>
};<font></font>
</code></pre>
<h4 class="code-line" data-line-start="4989" data-line-end="4990"><a id="63121__4989"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.12.1 Base conversion</font></font></h4>
<pre><code class="has-line-data" data-line-start="4992" data-line-end="5009"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">convert_dec_to_base</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> base)</span> </span>{
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;
    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">int</span> e = n % base;
        <span class="hljs-built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="hljs-string">" "</span>; <span class="hljs-comment">// printing in reverse order</span><font></font>
        n /= base;<font></font>
    } <span class="hljs-built_in">cout</span> &lt;&lt; endl;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">convert_base_to_dec</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> s[], <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> base)</span> </span>{
    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<font></font>
        result = result * base + s[i];<font></font>
    <span class="hljs-keyword">return</span> result;<font></font>
}<font></font>
</code></pre>
<h4 class="code-line" data-line-start="5009" data-line-end="5010"><a id="63122_5009"></a>6.3.12.2</h4>
<h4 class="code-line" data-line-start="5011" data-line-end="5012"><a id="6313_A__C_5011"></a>6.3.13 A / C</h4>
<blockquote>
<p class="has-line-data" data-line-start="5013" data-line-end="5014">C(n, k) = C(n-1, k) + C(n-1, k-1)</p>
<p class="has-line-data" data-line-start="5015" data-line-end="5016">C(n, k) = C(n, n-k)</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="5018" data-line-end="5030"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MAXN <span class="hljs-number">1002</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MOD <span class="hljs-number">1000000007</span></span>
<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> choose[MAXN][MAXN];<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_choose_n_k</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; MAXN; i++) {<font></font>
        choose[i][i] = choose[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++)<font></font>
            choose[i][j] = (choose[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + choose[i-<span class="hljs-number">1</span>][j]) % MOD;<font></font>
    }<font></font>
}<font></font>
</code></pre>
<h4 class="code-line" data-line-start="5031" data-line-end="5032"><a id="6314__5031"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.14 Prime Number Table</font></font></h4>
<pre><code class="has-line-data" data-line-start="5034" data-line-end="5044"><span class="hljs-keyword">int</span> is_prime[UP_LIMIT + <span class="hljs-number">1</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= UP_LIMIT; i++) <span class="hljs-comment">// init to 1</span>
    is_prime[i] = <span class="hljs-number">1</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">4</span>; i &lt;= UP_LIMIT; i += <span class="hljs-number">2</span>) <span class="hljs-comment">// even number is not</span>
    is_prime[i] = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">3</span>; k*k &lt;= UP_LIMIT; k++) <span class="hljs-comment">// start from 9, end at sqrt</span>
    <span class="hljs-keyword">if</span> (is_prime[k])
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = k*k; i &lt;= UP_LIMIT; i += <span class="hljs-number">2</span>*k) <span class="hljs-comment">// every two is not </span>
            is_prime[i] = <span class="hljs-number">0</span>;
</code></pre>
<h4 class="code-line" data-line-start="5045" data-line-end="5046"><a id="6315_Fast_Exponention_5045"></a>6.3.15 Fast Exponention</h4>
<blockquote>
<p class="has-line-data" data-line-start="5047" data-line-end="5048">To calculate n ^ p % M</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="5050" data-line-end="5061"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">power_modulo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> M)</span> </span>{
    <span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (p &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> (p % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<font></font>
            result = (result*n) % M;<font></font>
        p /= <span class="hljs-number">2</span>;<font></font>
        n = (n*n) % M;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> result;<font></font>
}<font></font>
</code></pre>
<h4 class="code-line" data-line-start="5062" data-line-end="5063"><a id="6316_Fast_Fourier_Transform_FFT_5062"></a>6.3.16 Fast Fourier Transform FFT</h4>
<blockquote>
<p class="has-line-data" data-line-start="5064" data-line-end="5065"><a href="www.gatevin.moe/acm/fft%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Reference 1</a></p>
<p class="has-line-data" data-line-start="5066" data-line-end="5067"><a href="https://github.com/marioyc/ACM-ICPC-Library/blob/master/math/fft.cpp">Reference 2</a></p>
<p class="has-line-data" data-line-start="5068" data-line-end="5069">Example: calculate two number C = A * B</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="5071" data-line-end="5184"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;complex&gt;</span></span><font></font>
<font></font>
<span class="hljs-preprocessor">#<span class="hljs-keyword">ifndef</span> M_PI</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> M_PI = <span class="hljs-built_in">acos</span>(-<span class="hljs-number">1</span>);
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">complex</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span>&gt; Complex;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FFT</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;Complex&gt; &amp;A, <span class="hljs-keyword">int</span> s)</span> </span>{
    <span class="hljs-keyword">int</span> n = A.size();
    <span class="hljs-keyword">int</span> p = __builtin_ctz(n);<font></font>
    <font></font>
    <span class="hljs-built_in">vector</span>&lt;Complex&gt; a = A;<font></font>
    <font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {
        <span class="hljs-keyword">int</span> rev = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; p; ++j) {<font></font>
            rev &lt;&lt;= <span class="hljs-number">1</span>;<font></font>
            rev |= ((i &gt;&gt; j) &amp; <span class="hljs-number">1</span>);<font></font>
        }<font></font>
        A[i] = a[rev];<font></font>
    }<font></font>
    <font></font>
    Complex w, wn;<font></font>
    <font></font>
    <font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= p; ++i) {
        <span class="hljs-keyword">int</span> M = (<span class="hljs-number">1</span>&lt;&lt;i), K = (M&gt;&gt;<span class="hljs-number">1</span>);<font></font>
        wn = Complex(<span class="hljs-built_in">cos</span>(s*<span class="hljs-number">2.0</span>*M_PI/(<span class="hljs-keyword">double</span>)M), <span class="hljs-built_in">sin</span>(s*<span class="hljs-number">2.0</span>*M_PI/(<span class="hljs-keyword">double</span>)M));<font></font>
        <font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j += M) {<font></font>
            w = Complex(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = j; l &lt; K + j; ++l) {<font></font>
                Complex t = w;<font></font>
                t *= A[l + K];<font></font>
                Complex u = A[l];<font></font>
                A[l] += t;<font></font>
                u -= t;<font></font>
                A[l + K] = u;<font></font>
                w *= wn;<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">if</span> (s == -<span class="hljs-number">1</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<font></font>
            A[i] /= (<span class="hljs-keyword">double</span>)n;<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">vector</span>&lt;Complex&gt; FFT_Multiply(<span class="hljs-built_in">vector</span>&lt;Complex&gt; &amp;P, <span class="hljs-built_in">vector</span>&lt;Complex&gt; &amp;Q) {
    <span class="hljs-keyword">int</span> n = P.size() + Q.size();<font></font>
<font></font>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> lowbit(x) (((x) ^ (x-<span class="hljs-number">1</span>)) &amp; (x))</span>
    <span class="hljs-keyword">while</span> (n != lowbit(n)) n += lowbit(n);
<span class="hljs-preprocessor">#<span class="hljs-keyword">undef</span> lowbit</span><font></font>
    <font></font>
    P.resize(n, <span class="hljs-number">0</span>);<font></font>
    Q.resize(n, <span class="hljs-number">0</span>);<font></font>
    <font></font>
    FFT(P, <span class="hljs-number">1</span>);<font></font>
    FFT(Q, <span class="hljs-number">1</span>);<font></font>
    <font></font>
    <span class="hljs-built_in">vector</span>&lt;Complex&gt; R;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) R.push_back(P[i] * Q[i]);<font></font>
    <font></font>
    FFT(R, -<span class="hljs-number">1</span>);<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> R;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// multiply two number </span>
    <span class="hljs-built_in">string</span> sa; <span class="hljs-comment">// [a1 * 10^(?)] + [a2 * 10^(?)] + ... + [an * 10^(?)]</span>
    <span class="hljs-built_in">string</span> sb; <span class="hljs-comment">// [b1 * 10^(?)] + [b2 * 10^(?)] + ... + [bm * 10^(?)]</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; sa &gt;&gt; sb) {
        <span class="hljs-built_in">vector</span>&lt;Complex&gt; a;
        <span class="hljs-built_in">vector</span>&lt;Complex&gt; b;<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sa.length(); i++)<font></font>
            a.push_back(Complex(sa[sa.length() - i - <span class="hljs-number">1</span>] - <span class="hljs-string">'0'</span>, <span class="hljs-number">0</span>)); <span class="hljs-comment">// add [a_ * (x)^(?)]</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sb.length(); i++)<font></font>
            b.push_back(Complex(sb[sb.length() - i - <span class="hljs-number">1</span>] - <span class="hljs-string">'0'</span>, <span class="hljs-number">0</span>)); <span class="hljs-comment">// add [b_ * (x)^(?)]</span><font></font>
<font></font>
        <span class="hljs-comment">// [c1 * 10^(?)] + [c2 * 10^(?)] + ... + [cn * 10^(?)]</span>
        <span class="hljs-comment">// =</span>
        <span class="hljs-comment">// [a1 * 10^(?)] + [a2 * 10^(?)] + ... + [an * 10^(?)]</span>
        <span class="hljs-comment">// *</span>
        <span class="hljs-comment">// [b1 * 10^(?)] + [b2 * 10^(?)] + ... + [bm * 10^(?)]</span>
        <span class="hljs-built_in">vector</span>&lt;Complex&gt; c = FFT_Multiply(a, b);<font></font>
<font></font>
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans(c.size());
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; c.size(); i++)<font></font>
            ans[i] = c[i].real() + <span class="hljs-number">0.5</span>; <span class="hljs-comment">// extract [c_ * (x)^(?)] // equivalent to [c_ * (x=10)^(?)]</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.size() - <span class="hljs-number">1</span>; i++) { <span class="hljs-comment">// process carry</span>
            ans[i + <span class="hljs-number">1</span>] += ans[i] / <span class="hljs-number">10</span>;<font></font>
            ans[i] %= <span class="hljs-number">10</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = ans.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) { <span class="hljs-comment">// print from most significant digit</span>
            <span class="hljs-keyword">if</span> (ans[i])
                <span class="hljs-built_in">cout</span> &lt;&lt; ans[i], flag = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flag || i == <span class="hljs-number">0</span>)
                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-number">0</span>;<font></font>
        }<font></font>
        <span class="hljs-built_in">cout</span> &lt;&lt; endl;<font></font>
    }<font></font>
}<font></font>
</code></pre>
<h3 class="code-line" data-line-start="5185" data-line-end="5186"><a id="64_Game_Theory__5185"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.4 Game Theory</font></font></h3>
<h4 class="code-line" data-line-start="5187" data-line-end="5188"><a id="641_Impartial_Combinatorial_Game_5187"></a>6.4.1 Impartial Combinatorial Game</h4>
<blockquote>
<p class="has-line-data" data-line-start="5189" data-line-end="5190">In combinatorial game theory, an impartial game is a game in which the allowable moves depend only on the position and not on which of the two players is currently moving, and where the payoffs are symmetric. In other words, the only difference between player 1 and player 2 is that player 1 goes first.</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="5191" data-line-end="5192">Impartial games can be analyzed using the Sprague–Grundy theorem.</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="5193" data-line-end="5194">Impartial games include Nim, Sprouts, Kayles, Quarto, Cram, Chomp, and poset games. Go and chess are not impartial, as each player can only place or move pieces of their own color. Games like ZÈRTZ and Chameleon are also not impartial, since although they are played with shared pieces, the payoffs are not necessarily symmetric for any given position.</p>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="5195" data-line-end="5196">A game that is not impartial is called a partisan game.</p>
<p class="has-line-data" data-line-start="5197" data-line-end="5198"><a href="https://en.wikipedia.org/wiki/Impartial_game">source: wiki</a></p>
<p class="has-line-data" data-line-start="5199" data-line-end="5200"><a href="https://www.topcoder.com/community/data-science/data-science-tutorials/algorithm-games/">tutorial: topcoder</a></p>
</blockquote>
<h5 class="code-line" data-line-start="5201" data-line-end="5202"><a id="6411_Nim_Game_5201"></a>6.4.1.1 Nim Game</h5>
<blockquote>
<p class="has-line-data" data-line-start="5203" data-line-end="5204">One good choice: brute force to find some pattern.</p>
<p class="has-line-data" data-line-start="5205" data-line-end="5206">We will not be able to play many of the games without decomposing them to smaller parts (sub-games), pre-computing some values for them, and then obtaining the result by combining these values.</p>
<p class="has-line-data" data-line-start="5207" data-line-end="5208">Positions have the following properties:</p>
<ul>
<li class="has-line-data" data-line-start="5209" data-line-end="5210">All terminal positions are losing.</li>
<li class="has-line-data" data-line-start="5210" data-line-end="5211">If a player is able to move to a losing position then he is in a winning position.</li>
<li class="has-line-data" data-line-start="5211" data-line-end="5213">If a player is able to move only to the winning positions then he is in a losing position.</li>
</ul>
<p class="has-line-data" data-line-start="5213" data-line-end="5214">Rules of the Game of Nim: There are n piles of coins. When it is a player’s turn he chooses one pile and takes at least one coin from it. If someone is unable to move he loses (so the one who removes the last coin is the winner).</p>
<p class="has-line-data" data-line-start="5215" data-line-end="5216">Let n1, n2, …, nk, be the sizes of the piles. It is a losing position for the player whose turn it is if and only if n1 xor n2 xor … xor nk = 0.</p>
</blockquote>
<h5 class="code-line" data-line-start="5217" data-line-end="5218"><a id="6411_Composite_Games__SpragueGrundy_Theorem_and_Nim_Value_5217"></a>6.4.1.1 Composite Games – Sprague-Grundy Theorem and Nim Value</h5>
<blockquote>
<ul>
<li class="has-line-data" data-line-start="5219" data-line-end="5220">Break composite game into subgames</li>
<li class="has-line-data" data-line-start="5220" data-line-end="5221">Assign grundy number to every subgame according to which size of the pile in the Game of Nim it is equivalent to.</li>
<li class="has-line-data" data-line-start="5221" data-line-end="5222">Now we have some subgames (piles), each subgame has its grundy number (size of pile)</li>
<li class="has-line-data" data-line-start="5222" data-line-end="5223">xor all subgames</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li class="has-line-data" data-line-start="5224" data-line-end="5225">Losing position of subgame has grundy number = 0.</li>
<li class="has-line-data" data-line-start="5225" data-line-end="5226">A position has grundy number = smallest number among its next positions don’t have.</li>
</ul>
</blockquote>
<blockquote>
<p class="has-line-data" data-line-start="5227" data-line-end="5228">If the table of grundy number is too large, we can precompute and find the pattern.</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="5230" data-line-end="5284"><span class="hljs-comment">// hihocoer 1173</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXSTATE = <span class="hljs-number">2e4</span> + <span class="hljs-number">2</span>;<font></font>
<font></font>
<span class="hljs-keyword">bool</span> appear[MAXSTATE];
<span class="hljs-keyword">int</span> sg[MAXSTATE]; <span class="hljs-comment">// Sprague-Grundy // Nim Value</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_sg</span><span class="hljs-params">()</span> </span>{<font></font>
    sg[state] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> state = <span class="hljs-number">1</span>; state &lt; MAXSTATE; state++) { <span class="hljs-comment">// sg(x) = mex{sg(y) | y是x的后继局面} // mex{a[i]}表示a中未出现的最小非负整数</span>
        fill_n(appear, MAXSTATE, <span class="hljs-literal">false</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> nx = <span class="hljs-number">0</span>; nx &lt; state; nx++)<font></font>
            appear[sg[nx]] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">int</span> pile_a = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> pile_b = state - pile_a;
        <span class="hljs-keyword">while</span> (pile_a &lt;= pile_b) {<font></font>
            appear[sg[pile_a] ^ sg[pile_b]] = <span class="hljs-literal">true</span>;<font></font>
            pile_a++;<font></font>
            pile_b--;<font></font>
        }<font></font>
        <span class="hljs-keyword">while</span> (appear[sg[state]])<font></font>
            sg[state]++;<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<font></font>
<font></font>
    init_sg();<font></font>
<font></font>
    <span class="hljs-comment">// --- start of finding pattern ---</span>
    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// --- end of finding pattern ---</span><font></font>
<font></font>
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-built_in">cin</span> &gt;&gt; n;
    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        <span class="hljs-keyword">int</span> a;
        <span class="hljs-built_in">cin</span> &gt;&gt; a;<font></font>
<font></font>
        <span class="hljs-comment">// by grundy number </span>
        <span class="hljs-comment">// result ^= sg[a];</span><font></font>
        <font></font>
        <span class="hljs-comment">// by pattern</span>
        <span class="hljs-comment">// if (a % 4 == 0)</span>
        <span class="hljs-comment">//  a--;</span>
        <span class="hljs-comment">// else if (a % 4 == 3)</span>
        <span class="hljs-comment">//  a++;</span>
        <span class="hljs-comment">// result ^= a; </span><font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (result)
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Alice"</span> &lt;&lt; endl;
    <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Bob"</span> &lt;&lt; endl;<font></font>
}<font></font>
</code></pre>
<h2 class="code-line" data-line-start="5287" data-line-end="5288"><a id="7_Geometry_5287"></a>7. Geometry</h2>
<h3 class="code-line" data-line-start="5289" data-line-end="5290"><a id="71_2Dimension_Space_5289"></a>7.1 2-Dimension Space</h3>
<h4 class="code-line" data-line-start="5291" data-line-end="5292"><a id="711_Template_of_Point_5291"></a>7.1.1 Template of Point</h4>
<pre><code class="has-line-data" data-line-start="5294" data-line-end="5363"><span class="hljs-keyword">struct</span> point {
    <span class="hljs-keyword">int</span> x, y;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(x*x + y*y);<font></font>
    }<font></font>
    <font></font>
    point <span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">const</span> point &amp;rhs) <span class="hljs-keyword">const</span> {
        <span class="hljs-keyword">return</span> (point){x + rhs.x, y + rhs.y};<font></font>
    }<font></font>
<font></font>
    point <span class="hljs-keyword">operator</span> - (<span class="hljs-keyword">const</span> point &amp;rhs) <span class="hljs-keyword">const</span> {
        <span class="hljs-keyword">return</span> (point){x - rhs.x, y - rhs.y};<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">operator</span>* (<span class="hljs-keyword">const</span> point&amp; b) {
        <span class="hljs-keyword">return</span> x*b.y - y*b.x;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">cross_product</span><span class="hljs-params">(<span class="hljs-keyword">const</span> point&amp; b)</span> </span>{
      <span class="hljs-keyword">return</span> x * b.x + y * b.y;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">at_right_of</span><span class="hljs-params">(<span class="hljs-keyword">const</span> point&amp; a, <span class="hljs-keyword">const</span> point&amp; b)</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-comment">// a: relative point, b: base</span><font></font>
        point vec_self = {x - b.x, y - b.y};<font></font>
        point vec_that = {a.x - b.x, a.y - b.y};<font></font>
        <span class="hljs-keyword">long</span> product = vec_self * vec_that;
        <span class="hljs-keyword">if</span> (product&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (product==<span class="hljs-number">0</span> &amp;&amp; vec_self.length()&gt;vec_that.length()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">to_point</span><span class="hljs-params">(<span class="hljs-keyword">const</span> point&amp; b)</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">pow</span>(x-b.x,<span class="hljs-number">2</span>) + <span class="hljs-built_in">pow</span>(y-b.y,<span class="hljs-number">2</span>));<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">to_segment</span><span class="hljs-params">(<span class="hljs-keyword">const</span> point&amp; a, <span class="hljs-keyword">const</span> point&amp; b)</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">double</span> len_ab = a.to_point(b);
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(len_ab)&lt;E) <span class="hljs-keyword">return</span> to_point(a);
        <span class="hljs-keyword">double</span> r = ((a.y-y)*(a.y-b.y) - (a.x-x)*(a.x-b.x))/<span class="hljs-built_in">pow</span>(len_ab,<span class="hljs-number">2</span>);
        <span class="hljs-keyword">if</span> (r&gt;<span class="hljs-number">1</span> || r&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> min(to_point(a), to_point(b));
        <span class="hljs-comment">// projection of p is on extension of AB</span>
        r = ((a.y - y)*(b.y - y) - (a.x - x)*(b.y - a.y))/<span class="hljs-built_in">pow</span>(len_ab,<span class="hljs-number">2</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>(r*len_ab);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">to_segment</span><span class="hljs-params">(<span class="hljs-keyword">const</span> point&amp; a, <span class="hljs-keyword">const</span> point&amp; b)</span> <span class="hljs-keyword">const</span> </span>{<font></font>
        point vec_ab = {b.x - a.x, b.y - a.y};<font></font>
        point vec_ia = {x - a.x, y - a.y};<font></font>
        point vec_ib = {x - b.x, y - b.y};<font></font>
        <span class="hljs-keyword">if</span> (vec_ia.cross_product(vec_ab) &lt; <span class="hljs-number">0</span> || vec_ib.cross_product(vec_ab) &gt; <span class="hljs-number">0</span>)
            <span class="hljs-keyword">return</span> min(to_point(a), to_point(b));
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(vec_ab * vec_ia) / vec_ab.length();<font></font>
    } <span class="hljs-comment">// same meaning with v1, need test</span><font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">to_line</span><span class="hljs-params">(<span class="hljs-keyword">const</span> point&amp; a, <span class="hljs-keyword">const</span> point&amp; b)</span> <span class="hljs-keyword">const</span> </span>{<font></font>
        point vec_ab = {b.x - a.x, b.y - a.y};<font></font>
        point vec_ia = {x - a.x, y - a.y};<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(vec_ab * vec_ia) / vec_ab.length();<font></font>
    } <span class="hljs-comment">// same meaning with v1, need test</span><font></font>
    <font></font>
    <span class="hljs-function">point <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> point &amp;rhs, <span class="hljs-keyword">double</span> angle)</span> <span class="hljs-keyword">const</span> </span>{<font></font>
        point t = (*<span class="hljs-keyword">this</span>) - rhs;
        <span class="hljs-keyword">double</span> c = <span class="hljs-built_in">cos</span>(angle), s = <span class="hljs-built_in">sin</span>(angle);
        <span class="hljs-keyword">return</span> (point){rhs.x + t.x * c - t.y * s, rhs.y + t.x * s + t.y * c};<font></font>
    }<font></font>
};<font></font>
</code></pre>
<h4 class="code-line" data-line-start="5364" data-line-end="5365"><a id="712___5364"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1.2 Vector dot product and cross product</font></font></h4>
<blockquote>
<p class="has-line-data" data-line-start="5366" data-line-end="5367">a = (x1, y1)</p>
<p class="has-line-data" data-line-start="5368" data-line-end="5369">b = (x2, y2)</p>
<p class="has-line-data" data-line-start="5370" data-line-end="5371">i … |i| = 1, vertical to a-b surface</p>
</blockquote>
<h4 class="code-line" data-line-start="5372" data-line-end="5373"><a id="713_dot_product_5372"></a>7.1.3 dot product</h4>
<blockquote>
<p class="has-line-data" data-line-start="5373" data-line-end="5374">a dot b = x1 * x2 + y1 * y2 = |a| * |b| * cos(angle)</p>
<p class="has-line-data" data-line-start="5375" data-line-end="5376">if = 0: 90 degree</p>
<p class="has-line-data" data-line-start="5377" data-line-end="5378">a dot b / |b| = a project to b</p>
</blockquote>
<h4 class="code-line" data-line-start="5379" data-line-end="5380"><a id="714_cross_product_5379"></a>7.1.4 cross product</h4>
<blockquote>
<p class="has-line-data" data-line-start="5380" data-line-end="5381">a x b = x1 * y2 - x2 * y1 = |a| * |b| * sin(angle) * i</p>
<p class="has-line-data" data-line-start="5382" data-line-end="5383">if &lt; 0: b is at left of a</p>
<p class="has-line-data" data-line-start="5384" data-line-end="5385">if = 0: a, b in a line</p>
<p class="has-line-data" data-line-start="5386" data-line-end="5387">if 0: b is at right of a</p>
<p class="has-line-data" data-line-start="5388" data-line-end="5389"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">axb = area of &ZeroWidthSpace;&ZeroWidthSpace;parallelogram</font></font></p>
<p class="has-line-data" data-line-start="5390" data-line-end="5391"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">axbxc = area of &ZeroWidthSpace;&ZeroWidthSpace;parallelepiped, c = (x3, y3)</font></font></p>
</blockquote>
<h4 class="code-line" data-line-start="5392" data-line-end="5393"><a id="715__5392"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1.5 Straight line formula</font></font></h4>
<blockquote>
<p class="has-line-data" data-line-start="5394" data-line-end="5395">(x, y) = (x1, y1) + k * ((x2, y2) - (x1, y1))</p>
</blockquote>
<h4 class="code-line" data-line-start="5396" data-line-end="5397"><a id="716_Convex_Hull_5396"></a>7.1.6 Convex Hull</h4>
<h5 class="code-line" data-line-start="5398" data-line-end="5399"><a id="Gift_Wrapping_5398"></a>Gift Wrapping</h5>
<blockquote>
<p class="has-line-data" data-line-start="5400" data-line-end="5401">place holder</p>
</blockquote>
<h5 class="code-line" data-line-start="5402" data-line-end="5403"><a id="QuickHull_5402"></a>QuickHull</h5>
<blockquote>
<p class="has-line-data" data-line-start="5404" data-line-end="5405"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">place holder</font></font></p>
</blockquote>
<h5 class="code-line" data-line-start="5406" data-line-end="5407"><a id="Graham_scan_5406"></a>Graham scan</h5>
<blockquote>
<p class="has-line-data" data-line-start="5408" data-line-end="5409"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (VlogV)</font></font></p>
</blockquote>
<pre><code class="has-line-data" data-line-start="5411" data-line-end="5504"><span class="hljs-keyword">struct</span> Point {
    <span class="hljs-keyword">long</span> x;
    <span class="hljs-keyword">long</span> y;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">at_right_of</span><span class="hljs-params">(Point&amp; that, Point&amp; base)</span> </span>{<font></font>
        Point vec_self = {<span class="hljs-keyword">this</span>-&gt;x - base.x, <span class="hljs-keyword">this</span>-&gt;y - base.y};<font></font>
        Point vec_that = {that.x - base.x, that.y - base.y};<font></font>
<font></font>
        <span class="hljs-keyword">long</span> product = vec_self * vec_that;
        <span class="hljs-keyword">if</span> (product &gt; <span class="hljs-number">0</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// "this" is at right of "that"</span>
        <span class="hljs-keyword">if</span> (product == <span class="hljs-number">0</span> &amp;&amp; vec_self.length() &gt; vec_that.length())
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// "this" is at right of "that"</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// "this" is NOT at right of "that"</span><font></font>
    };<font></font>
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">operator</span>* (Point&amp; that) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;x * that.y - <span class="hljs-keyword">this</span>-&gt;y * that.x;<font></font>
    };<font></font>
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">distance_to</span><span class="hljs-params">(Point&amp; that)</span> </span>{
        <span class="hljs-keyword">long</span> x_diff = <span class="hljs-keyword">this</span>-&gt;x - that.x;
        <span class="hljs-keyword">long</span> y_diff = <span class="hljs-keyword">this</span>-&gt;y - that.y;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(x_diff * x_diff + y_diff * y_diff);<font></font>
    };<font></font>
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(<span class="hljs-keyword">this</span>-&gt;x * <span class="hljs-keyword">this</span>-&gt;x + <span class="hljs-keyword">this</span>-&gt;y * <span class="hljs-keyword">this</span>-&gt;y);<font></font>
    }<font></font>
};<font></font>
<font></font>
Point p[<span class="hljs-number">1005</span>];
<span class="hljs-keyword">int</span> my_stack[<span class="hljs-number">1005</span>];
<span class="hljs-keyword">int</span> n, l, my_stack_top = -<span class="hljs-number">1</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(Point p1, Point p2)</span> </span>{
    <span class="hljs-keyword">return</span> p1.at_right_of(p2, p[<span class="hljs-number">0</span>]);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>{<font></font>
    my_stack[++my_stack_top] = index;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> temp = my_stack[my_stack_top--];
    <span class="hljs-keyword">return</span> temp;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">graham_scan</span><span class="hljs-params">()</span> </span>{<font></font>
    push(<span class="hljs-number">0</span>);<font></font>
    push(<span class="hljs-number">1</span>);<font></font>
<font></font>
    <span class="hljs-keyword">int</span> pre;
    <span class="hljs-keyword">int</span> prepre;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) {<font></font>
        pre = my_stack_top;<font></font>
        prepre = my_stack_top - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (p[i].at_right_of(p[my_stack[pre]], p[my_stack[prepre]])) {<font></font>
            pop();<font></font>
            <span class="hljs-keyword">if</span> (my_stack_top == <span class="hljs-number">0</span>)
                <span class="hljs-keyword">break</span>;<font></font>
            pre = my_stack_top;<font></font>
            prepre = my_stack_top - <span class="hljs-number">1</span>;<font></font>
        }<font></font>
        push(i);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">int</span> last = my_stack_top;
    <span class="hljs-keyword">if</span> (p[<span class="hljs-number">0</span>].at_right_of(p[my_stack[last]], p[my_stack[pre]]))<font></font>
        pop();<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])</span> </span>{
    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; l;<font></font>
    <font></font>
    <span class="hljs-keyword">int</span> minimun = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {
        <span class="hljs-keyword">int</span> temp_x, temp_y;
        <span class="hljs-built_in">cin</span> &gt;&gt; temp_x &gt;&gt; temp_y;<font></font>
        p[i] = {temp_x, temp_y};<font></font>
<font></font>
        <span class="hljs-keyword">if</span> ((p[i].y &lt; p[minimun].y) || (p[i].y == p[minimun].y &amp;&amp; p[i].x &lt; p[minimun].x))<font></font>
            minimun = i;<font></font>
    }<font></font>
<font></font>
    Point temp = {p[minimun].x, p[minimun].y}; <span class="hljs-comment">// swap lowest and most left point to p[0]</span>
    p[minimun] = p[<span class="hljs-number">0</span>];<font></font>
    p[<span class="hljs-number">0</span>] = temp;<font></font>
<font></font>
    sort(p + <span class="hljs-number">1</span>, p + n, compare); <span class="hljs-comment">// use p[0] as base, sort according to polar angle</span><font></font>
    graham_scan();<font></font>
    <span class="hljs-comment">// now all points in the stack is on Convex Hull // size of stack = 1 + stack_top</span><font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= my_stack_top; i++)
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"point "</span> &lt;&lt; my_stack[i] &lt;&lt; <span class="hljs-string">" is on Convex Hull"</span> &lt;&lt; endl;<font></font>
}<font></font>
</code></pre>
<h2 class="code-line" data-line-start="5507" data-line-end="5508"><a id="8_Tricks__Miscellaneous_5507"></a>8. Tricks + Miscellaneous</h2>
<h3 class="code-line" data-line-start="5509" data-line-end="5510"><a id="81_Bit_Manipulation_5509"></a>8.1 Bit Manipulation</h3>
<pre><code class="has-line-data" data-line-start="5512" data-line-end="5516"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> GET_BIT(n, i) (((n) &amp; (<span class="hljs-number">1L</span>L &lt;&lt; ((i)-<span class="hljs-number">1</span>))) &gt;&gt; ((i)-<span class="hljs-number">1</span>)) <span class="hljs-comment">// i start from 1</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> SET_BIT(n, i) ((n) | (<span class="hljs-number">1L</span>L &lt;&lt; ((i)-<span class="hljs-number">1</span>)))</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> CLR_BIT(n, i) ((n) &amp; ~(<span class="hljs-number">1L</span>L &lt;&lt; ((i)-<span class="hljs-number">1</span>)))</span>
</code></pre>
<h3 class="code-line" data-line-start="5517" data-line-end="5518"><a id="81_Cantor_Expansion__Reverse_Cantor_Expansion_5517"></a>8.1 Cantor Expansion / Reverse Cantor Expansion</h3>
<blockquote>
<p class="has-line-data" data-line-start="5519" data-line-end="5520">for hashing, or …</p>
</blockquote>
<pre><code class="has-line-data" data-line-start="5522" data-line-end="5575"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<font></font>
<font></font>
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = n;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<font></font>
        ans = ans * i;<font></font>
    <span class="hljs-keyword">return</span> ans;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">cantor_expansion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> permutation[], <span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-comment">// input: (m-th permutation of n numbers, n)</span>
    <span class="hljs-comment">// return: m</span>
    <span class="hljs-keyword">int</span> used[n + <span class="hljs-number">1</span>];
    <span class="hljs-built_in">memset</span>(used, n, <span class="hljs-keyword">sizeof</span>(used));<font></font>
<font></font>
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<font></font>
        used[permutation[i]] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; permutation[i]; j++)
            <span class="hljs-keyword">if</span> (used[j] != <span class="hljs-number">1</span>)<font></font>
                temp += <span class="hljs-number">1</span>;<font></font>
        ans += factorial(n - <span class="hljs-number">1</span> - i) * temp;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> ans + <span class="hljs-number">1</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverse_cantor_expansion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m)</span> </span>{
    <span class="hljs-comment">// m-th permutation of n numbers</span>
    <span class="hljs-keyword">int</span> ans[n + <span class="hljs-number">1</span>], used[n + <span class="hljs-number">1</span>];
    <span class="hljs-built_in">memset</span>(ans, -<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span> (ans));
    <span class="hljs-built_in">memset</span>(used, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> (used));<font></font>
<font></font>
    m = m - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> fac = factorial(i);
        <span class="hljs-keyword">int</span> temp = m / fac + <span class="hljs-number">1</span>;<font></font>
        m = m - (temp - <span class="hljs-number">1</span>) * fac;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= temp; j++)
            <span class="hljs-keyword">if</span> (used[j] == <span class="hljs-number">1</span>)<font></font>
                temp++;<font></font>
<font></font>
        ans[n - i] = temp;<font></font>
        used[temp] = <span class="hljs-number">1</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)
        <span class="hljs-built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n"</span>;<font></font>
}<font></font>
</code></pre>
<h3 class="code-line" data-line-start="5576" data-line-end="5577"><a id="82_pass_2D_array_5576"></a>8.2 pass 2-D array</h3>
<pre><code class="has-line-data" data-line-start="5579" data-line-end="5605"><span class="hljs-comment">// The parameter is a 2D array</span>
<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">passFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[][<span class="hljs-number">10</span>])</span> </span>{
    <span class="hljs-comment">// ...</span><font></font>
}<font></font>
passFunc(<span class="hljs-built_in">array</span>);<font></font>
<font></font>
<span class="hljs-comment">// The parameter is an array containing pointers</span>
<span class="hljs-keyword">int</span> *<span class="hljs-built_in">array</span>[<span class="hljs-number">10</span>];
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)
    <span class="hljs-built_in">array</span>[i] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">passFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a[<span class="hljs-number">10</span>])</span> </span>{
    <span class="hljs-comment">// ...</span><font></font>
}<font></font>
passFunc(<span class="hljs-built_in">array</span>);<font></font>
<font></font>
<span class="hljs-comment">// The parameter is a pointer to a pointer</span>
<span class="hljs-keyword">int</span> **<span class="hljs-built_in">array</span>;
<span class="hljs-built_in">array</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> *[<span class="hljs-number">10</span>];
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">10</span>; i++)
    <span class="hljs-built_in">array</span>[i] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">passFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> **a)</span> </span>{
    <span class="hljs-comment">// ...</span><font></font>
}<font></font>
passFunc(<span class="hljs-built_in">array</span>);
</code></pre>
<h3 class="code-line" data-line-start="5606" data-line-end="5607"><a id="83_Binary_Display_5606"></a>8.3 Binary Display</h3>
<pre><code class="has-line-data" data-line-start="5609" data-line-end="5614"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_binary</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x)</span> </span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, <span class="hljs-built_in">bitset</span>&lt;64&gt;(x).to_string().c_str());<font></font>
}<font></font>
</code></pre>
<h3 class="code-line" data-line-start="5615" data-line-end="5616"><a id="84_Fast_Log_5615"></a>8.4 Fast Log</h3>
<blockquote>
<p class="has-line-data" data-line-start="5617" data-line-end="5618">Built-in <code>log(double)</code> is not accurate for integer.</p>
<p class="has-line-data" data-line-start="5619" data-line-end="5620">Should <code>(int)(log(double)+0.000....001)</code></p>
</blockquote>
<pre><code class="has-line-data" data-line-start="5622" data-line-end="5637"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fastlog</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> base)</span> </span>{
    <span class="hljs-comment">// ERROR VALUE IF X == BASE == ULLONG_MAX</span><font></font>
<font></font>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> HALF = <span class="hljs-number">1U</span>LL &lt;&lt; <span class="hljs-number">32</span>;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> cache[<span class="hljs-number">7</span>];
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> INIT(i) { cache[i] = base; <span class="hljs-keyword">if</span> (base &lt; HALF) base *= base; <span class="hljs-keyword">else</span> base = ULLONG_MAX; }</span>
    INIT(<span class="hljs-number">0</span>); INIT(<span class="hljs-number">1</span>); INIT(<span class="hljs-number">2</span>); INIT(<span class="hljs-number">3</span>); INIT(<span class="hljs-number">4</span>); INIT(<span class="hljs-number">5</span>); INIT(<span class="hljs-number">6</span>);
<span class="hljs-preprocessor">#<span class="hljs-keyword">undef</span> INIT</span><font></font>
<font></font>
    <span class="hljs-keyword">int</span> ret = -(x == <span class="hljs-number">0</span>);
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> S(i, k) <span class="hljs-keyword">if</span> (x &gt;= cache[i]) ret += k, x /= cache[i]; <span class="hljs-keyword">else</span> return ret;</span>
    S(<span class="hljs-number">6</span>, <span class="hljs-number">64</span>); S(<span class="hljs-number">5</span>, <span class="hljs-number">32</span>); S(<span class="hljs-number">4</span>, <span class="hljs-number">16</span>); S(<span class="hljs-number">3</span>, <span class="hljs-number">8</span>); S(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>); S(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); S(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>); 
<span class="hljs-preprocessor">#<span class="hljs-keyword">undef</span> S</span><font></font>
}<font></font>
</code></pre>
<h3 class="code-line" data-line-start="5638" data-line-end="5639"><a id="85_Squre_Root_5638"></a>8.5 Squre Root</h3>
<pre><code class="has-line-data" data-line-start="5641" data-line-end="5654"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sq</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a)</span> </span>{
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> l = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> r = a + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (l + <span class="hljs-number">1</span> &lt; r) {
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m = (l + r) / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span> (a / m &lt; m)<font></font>
            r = m;<font></font>
        <span class="hljs-keyword">else</span><font></font>
            l = m;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> l;<font></font>
}<font></font>
</code></pre><div id="goog-gt-tt" class="skiptranslate" dir="ltr"><div style="padding: 8px;"><div><div class="logo"><img src="https://www.gstatic.com/images/branding/product/1x/translate_24dp.png" width="20" height="20" alt="Google Translate"></div></div></div><div class="top" style="padding: 8px; float: left; width: 100%;"><h1 class="title gray">Original text</h1></div><div class="middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">Contribute a better translation</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>
<div id="goog-gt-tt" class="skiptranslate" dir="ltr"><div style="padding: 8px;"><div><div class="logo"><img src="https://www.gstatic.com/images/branding/product/1x/translate_24dp.png" width="20" height="20" alt="Google Translate"></div></div></div><div class="top" style="padding: 8px; float: left; width: 100%;"><h1 class="title gray">Original text</h1></div><div class="middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">Contribute a better translation</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div><div class="goog-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div><div class="goog-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>